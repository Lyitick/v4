===== AUDIT_household_payments_ui.md =====

# Audit: household payments UI

## Почему не менялись вопросы
- Текущий вопрос удалялся сразу после ответа, поэтому `edit_message_text` применялся к уже удалённому сообщению.
- В некоторых ветках отсутствовал корректный `last_question_message_id`, из-за чего редактирование не попадало в нужное сообщение.

## Почему не работал отсчёт
- Отсчёт был на 3 секунды и сообщение не фиксировалось в едином списке UI-сообщений, поэтому часть сообщений оставалась до появления главного меню.

## Почему удалялось 4/6 вопросов
- Список сообщений для очистки хранился непоследовательно (`ui_message_ids` vs `household_ui_message_ids`), часть сообщений не попадала в общий реестр и удалялась только при последующем переходе к главному меню.

## Что исправлено
- Все вопросы сохраняются в единый список `household_ui_message_ids` с логированием при отправке.
- После ответа вопрос не удаляется: редактируется в ✅/❌!!! формат, затем задаётся следующий.
- Отсчёт выполняется 5→1 с `await asyncio.sleep(1)` между изменениями, сообщение отсчёта тоже хранится в `household_ui_message_ids`.
- Полная очистка всех вопросов и сообщения отсчёта выполняется до показа главного меню.


===== Bot/__init__.py =====

"""Package initializer for finance bot modules."""



===== Bot/config/__init__.py =====



===== Bot/config/logging_config.py =====

"""Logging configuration for the bot."""
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path

LOG_FORMAT = "[%(asctime)s] [%(levelname)s] %(message)s"
LOG_LEVEL = logging.INFO
LOG_FILE = Path(__file__).resolve().parents[2] / "finance_bot.log"


def setup_logging() -> None:
    """Configure logging for application."""

    LOG_FILE.touch(exist_ok=True)
    formatter = logging.Formatter(LOG_FORMAT)

    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5_000_000, backupCount=3, encoding="utf-8")
    file_handler.setLevel(LOG_LEVEL)
    file_handler.setFormatter(formatter)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(LOG_LEVEL)
    console_handler.setFormatter(formatter)

    root_logger = logging.getLogger()
    root_logger.setLevel(LOG_LEVEL)
    root_logger.handlers.clear()
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)


===== Bot/config/settings.py =====

"""Bot settings module."""
from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from zoneinfo import ZoneInfo


def _load_env_file(env_path: Path) -> dict[str, str]:
    if not env_path.exists():
        return {}

    data: dict[str, str] = {}
    for line in env_path.read_text(encoding="utf-8").splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#") or "=" not in stripped:
            continue
        key, value = stripped.split("=", 1)
        data[key.strip()] = value.strip().strip("\"'")
    return data


def _resolve_bot_token() -> tuple[str, str]:
    if "BOT_TOKEN" in os.environ:
        return os.environ.get("BOT_TOKEN", ""), "env"

    env_path = Path(__file__).resolve().parents[2] / ".env"
    env_values = _load_env_file(env_path)
    if "BOT_TOKEN" in env_values:
        os.environ.setdefault("BOT_TOKEN", env_values["BOT_TOKEN"])
        return env_values["BOT_TOKEN"], ".env"

    return "", "missing"


BOT_TOKEN, BOT_TOKEN_SOURCE = _resolve_bot_token()
ADMIN_ID: int = 838347504
TIMEZONE = ZoneInfo("Europe/Moscow")


@dataclass
class Settings:
    """Container for application settings."""

    bot_token: str = BOT_TOKEN
    bot_token_source: str = BOT_TOKEN_SOURCE
    admin_id: int = ADMIN_ID
    timezone: ZoneInfo = TIMEZONE


def get_settings() -> Settings:
    """Get current settings.

    Returns:
        Settings: Dataclass with bot settings.
    """

    return Settings()


===== Bot/database/__init__.py =====



===== Bot/database/crud.py =====

"""Database CRUD operations for finance bot."""
from __future__ import annotations

import logging
import sqlite3
import time
from datetime import datetime, timedelta
from pathlib import Path
from threading import Lock
from typing import Any, Dict, List, Optional

from Bot.config.settings import get_settings
from Bot.utils.datetime_utils import add_one_month, now_tz


LOGGER = logging.getLogger(__name__)
DB_PATH = Path(__file__).resolve().parents[2] / "finance.db"


def _get_bot_user_id() -> int | None:
    try:
        token = get_settings().bot_token
        if not token:
            return None
        return int(str(token).split(":")[0])
    except (AttributeError, IndexError, TypeError, ValueError):
        return None


BOT_USER_ID = _get_bot_user_id()
DEFAULT_HOUSEHOLD_ITEMS = [
    {"code": "phone", "text": "Телефон 600р?", "amount": 600},
    {"code": "internet", "text": "Интернет 700р?", "amount": 700},
    {"code": "vpn", "text": "VPN 100р?", "amount": 100},
    {"code": "gpt", "text": "GPT 2000р?", "amount": 2000},
    {"code": "yandex_sub", "text": "Яндекс подписка 400р?", "amount": 400},
    {"code": "rent", "text": "Квартплата 4000р? Папе скинул?", "amount": 4000},
    {"code": "training_495", "text": "Оплатил тренировки 495 - 5000р?", "amount": 5000},
]

DEFAULT_INCOME_CATEGORIES = [
    {"code": "долги", "title": "Убил боль?", "percent": 30, "position": 1},
    {
        "code": "быт",
        "title": "бытовые расходы на Тиньк",
        "percent": 20,
        "position": 2,
    },
    {
        "code": "инвестиции",
        "title": "Инвестиции на Альфу",
        "percent": 20,
        "position": 3,
    },
    {
        "code": "сбережения",
        "title": "Сбережения на Сбер",
        "percent": 20,
        "position": 4,
    },
    {
        "code": "спонтанные траты",
        "title": "спонтанные траты на Яндекс",
        "percent": 10,
        "position": 5,
    },
]

DEFAULT_EXPENSE_CATEGORIES = [
    {"code": "базовые", "title": "Базовые расходы", "percent": 40, "position": 1},
    {"code": "жилье", "title": "Жилье и ЖКУ", "percent": 20, "position": 2},
    {"code": "транспорт", "title": "Транспорт", "percent": 15, "position": 3},
    {"code": "еда", "title": "Еда", "percent": 15, "position": 4},
    {"code": "другое", "title": "Другое", "percent": 10, "position": 5},
]

DEFAULT_WISHLIST_CATEGORIES = [
    {"title": "инвестиции в работу", "position": 1},
    {"title": "вклад в себя", "position": 2},
    {"title": "кайфы", "position": 3},
    {"title": "БЫТ", "position": 4},
]


class FinanceDatabase:
    """Singleton class handling all database interactions."""

    _instance: Optional["FinanceDatabase"] = None
    _lock: Lock = Lock()

    def __new__(cls) -> "FinanceDatabase":
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize_connection()
        return cls._instance

    def _initialize_connection(self) -> None:
        """Initialize SQLite connection and create tables."""

        DB_PATH.touch(exist_ok=True)
        self.connection = sqlite3.connect(DB_PATH, check_same_thread=False)
        self.connection.row_factory = sqlite3.Row
        self.init_db()
        LOGGER.info("Database initialized at %s", DB_PATH)

    @staticmethod
    def _to_float(value: Any) -> float:
        """Safely convert a value to float, returning 0.0 on failure."""

        try:
            return float(value) if value is not None else 0.0
        except (TypeError, ValueError):
            return 0.0

    def init_db(self) -> None:
        """Create required tables if they do not exist."""

        cursor = self.connection.cursor()
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS savings (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                category TEXT,
                current REAL,
                goal REAL,
                purpose TEXT
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS wishes (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                name TEXT,
                price REAL,
                url TEXT,
                category TEXT,
                is_purchased INTEGER,
                saved_amount REAL DEFAULT 0,
                purchased_at TEXT,
                deferred_until TEXT
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS purchases (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                wish_name TEXT,
                price REAL,
                category TEXT,
                purchased_at TEXT
            )
            """
        )
        self._add_column_if_missing(cursor, "wishes", "deferred_until", "TEXT")
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS household_payments (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                month TEXT,
                question_code TEXT,
                is_paid INTEGER DEFAULT 0,
                UNIQUE(user_id, month, question_code)
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS household_payment_items (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                code TEXT,
                text TEXT,
                amount INTEGER,
                position INTEGER DEFAULT 0,
                is_active INTEGER DEFAULT 1,
                paid_month TEXT,
                is_paid INTEGER DEFAULT 0,
                created_at TEXT,
                UNIQUE(user_id, code)
            )
            """
        )
        self._add_column_if_missing(
            cursor, "household_payment_items", "paid_month", "TEXT"
        )
        self._add_column_if_missing(
            cursor, "household_payment_items", "is_paid", "INTEGER DEFAULT 0"
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS income_categories (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                code TEXT NOT NULL,
                title TEXT NOT NULL,
                percent INTEGER NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS expense_categories (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                code TEXT NOT NULL,
                title TEXT NOT NULL,
                percent INTEGER NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS wishlist_categories (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                title TEXT NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                purchased_mode TEXT DEFAULT 'days',
                purchased_days INTEGER DEFAULT 30
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS user_settings (
                user_id INTEGER PRIMARY KEY,
                purchased_keep_days INTEGER NOT NULL DEFAULT 30,
                byt_reminders_enabled INTEGER NOT NULL DEFAULT 1,
                byt_defer_enabled INTEGER NOT NULL DEFAULT 1,
                byt_defer_max_days INTEGER NOT NULL DEFAULT 365
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS byt_timer_times (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                hour INTEGER NOT NULL,
                minute INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1
            )
            """
        )
        self._add_column_if_missing(cursor, "wishes", "purchased_at", "TEXT")
        self._add_column_if_missing(cursor, "wishlist_categories", "purchased_mode", "TEXT DEFAULT 'days'")
        self._add_column_if_missing(cursor, "wishlist_categories", "purchased_days", "INTEGER DEFAULT 30")
        self.connection.commit()

    def ensure_household_items_seeded(self, user_id: int) -> None:
        """No-op: household items are managed by user and stored in DB."""
        LOGGER.debug("Household item seeding disabled (user_id=%s)", user_id)

    def list_active_household_items(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active household payment items for user ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT code, text, amount, position
                FROM household_payment_items
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list active household items for user %s: %s",
                user_id,
                error,
            )
            return []

    def get_household_item_by_code(
        self, user_id: int, code: str
    ) -> Optional[Dict[str, Any]]:
        """Return household payment item by code."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT code, text, amount, position
                FROM household_payment_items
                WHERE user_id = ? AND code = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, code),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch household item %s for user %s: %s",
                code,
                user_id,
                error,
            )
            return None

    def get_next_household_position(self, user_id: int) -> int:
        """Return next position value for household items."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT MAX(position) FROM household_payment_items WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            max_pos = row[0] if row and row[0] is not None else 0
            return int(max_pos) + 1
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get next household position for user %s: %s", user_id, error
            )
            return 1

    def add_household_payment_item(
        self, user_id: int, code: str, text: str, amount: int, position: int
    ) -> None:
        """Add new household payment item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT INTO household_payment_items (
                    user_id, code, text, amount, position, is_active, created_at
                )
                VALUES (?, ?, ?, ?, ?, 1, ?)
                """,
                (user_id, code, text, amount, position, now_tz().isoformat()),
            )
            self.connection.commit()
            LOGGER.info("Added household payment item %s for user %s", code, user_id)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to add household item %s for user %s: %s",
                code,
                user_id,
                error,
            )

    def deactivate_household_payment_item(self, user_id: int, code: str) -> None:
        """Deactivate household payment item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE household_payment_items
                SET is_active = 0
                WHERE user_id = ? AND code = ?
                """,
                (user_id, code),
            )
            self.connection.commit()
            LOGGER.info("Deactivated household payment item %s for user %s", code, user_id)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate household item %s for user %s: %s",
                code,
                user_id,
                error,
            )

    def ensure_income_categories_seeded(self, user_id: int) -> None:
        """Seed default income categories if user has none."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM income_categories WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for item in DEFAULT_INCOME_CATEGORIES:
                cursor.execute(
                    """
                    INSERT INTO income_categories (
                        user_id, code, title, percent, position, is_active
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                    """,
                    (
                        user_id,
                        item["code"],
                        item["title"],
                        item["percent"],
                        item["position"],
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default income categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed income categories for user %s: %s", user_id, error)

    def list_active_income_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active income categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM income_categories
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list income categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def ensure_expense_categories_seeded(self, user_id: int) -> None:
        """Seed default expense categories if user has none."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM expense_categories WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for item in DEFAULT_EXPENSE_CATEGORIES:
                cursor.execute(
                    """
                    INSERT INTO expense_categories (
                        user_id, code, title, percent, position, is_active
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                    """,
                    (
                        user_id,
                        item["code"],
                        item["title"],
                        item["percent"],
                        item["position"],
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default expense categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed expense categories for user %s: %s", user_id, error)

    def ensure_wishlist_categories_seeded(self, user_id: int) -> None:
        """Seed default wishlist categories if user has none."""

        try:
            cursor = self.connection.cursor()
            self.ensure_user_settings(user_id)
            cursor.execute(
                "SELECT 1 FROM wishlist_categories WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                cursor.execute(
                    "SELECT purchased_keep_days FROM user_settings WHERE user_id = ?",
                    (user_id,),
                )
                row = cursor.fetchone()
                default_days = int(row[0]) if row and row[0] is not None else 30
                cursor.execute(
                    "UPDATE wishlist_categories SET purchased_mode = COALESCE(purchased_mode, 'days') WHERE user_id = ?",
                    (user_id,),
                )
                cursor.execute(
                    "UPDATE wishlist_categories SET purchased_days = COALESCE(purchased_days, ?) WHERE user_id = ?",
                    (default_days, user_id),
                )
                self.connection.commit()
                return

            self.ensure_user_settings(user_id)
            cursor.execute(
                "SELECT purchased_keep_days FROM user_settings WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            default_days = int(row[0]) if row and row[0] is not None else 30
            for item in DEFAULT_WISHLIST_CATEGORIES:
                cursor.execute(
                    """
                    INSERT INTO wishlist_categories (
                        user_id, title, position, is_active, purchased_mode, purchased_days
                    )
                    VALUES (?, ?, ?, 1, 'days', ?)
                    """,
                    (
                        user_id,
                        item["title"],
                        item["position"],
                        default_days,
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default wishlist categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed wishlist categories for user %s: %s", user_id, error)

    def ensure_user_settings(self, user_id: int) -> None:
        """Ensure user_settings row exists with defaults."""

        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT 1 FROM user_settings WHERE user_id = ?", (user_id,))
            if cursor.fetchone():
                return

            cursor.execute(
                """
                INSERT OR IGNORE INTO user_settings (
                    user_id, purchased_keep_days, byt_reminders_enabled, byt_defer_enabled, byt_defer_max_days
                )
                VALUES (?, 30, 1, 1, 365)
                """,
                (user_id,),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to ensure user_settings for user %s: %s", user_id, error)

    def ensure_byt_timer_defaults(self, user_id: int) -> None:
        """Seed default BYT timer times (12:00, 18:00)."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM byt_timer_times WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for hour, minute in [(12, 0), (18, 0)]:
                cursor.execute(
                    """
                    INSERT INTO byt_timer_times (user_id, hour, minute, is_active)
                    VALUES (?, ?, ?, 1)
                    """,
                    (user_id, hour, minute),
                )
            self.connection.commit()
            LOGGER.info("Seeded default BYT timer times for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed BYT timer times for user %s: %s", user_id, error)

    def list_active_expense_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active expense categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM expense_categories
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list expense categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def list_active_wishlist_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active wishlist categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM wishlist_categories
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list wishlist categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def create_income_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new income category with zero percent."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(MAX(position), 0) FROM income_categories WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            code = f"custom_{time.time_ns()}"
            cursor.execute(
                """
                INSERT INTO income_categories (user_id, code, title, percent, position)
                VALUES (?, ?, ?, 0, ?)
                """,
                (user_id, code, title, current_position + 1),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create income category for user %s: %s", user_id, error)
            return None

    def create_expense_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new expense category with zero percent."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(MAX(position), 0) FROM expense_categories WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            code = f"custom_{time.time_ns()}"
            cursor.execute(
                """
                INSERT INTO expense_categories (user_id, code, title, percent, position)
                VALUES (?, ?, ?, 0, ?)
                """,
                (user_id, code, title, current_position + 1),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create expense category for user %s: %s", user_id, error)
            return None

    def create_wishlist_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(MAX(position), 0) FROM wishlist_categories WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            self.ensure_user_settings(user_id)
            cursor.execute(
                "SELECT purchased_keep_days FROM user_settings WHERE user_id = ?", (user_id,)
            )
            row = cursor.fetchone()
            default_days = int(row[0]) if row and row[0] is not None else 30
            cursor.execute(
                """
                INSERT INTO wishlist_categories (user_id, title, position, purchased_mode, purchased_days)
                VALUES (?, ?, ?, 'days', ?)
                """,
                (user_id, title, current_position + 1, default_days),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create wishlist category for user %s: %s", user_id, error)
            return None

    def deactivate_income_category(self, user_id: int, category_id: int) -> None:
        """Deactivate income category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE income_categories
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate income category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    def deactivate_expense_category(self, user_id: int, category_id: int) -> None:
        """Deactivate expense category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE expense_categories
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate expense category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_income_category_percent(self, user_id: int, category_id: int, percent: int) -> None:
        """Update percent for income category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE income_categories
                SET percent = ?
                WHERE user_id = ? AND id = ?
                """,
                (percent, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update percent for income category %s of user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_expense_category_percent(
        self, user_id: int, category_id: int, percent: int
    ) -> None:
        """Update percent for expense category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE expense_categories
                SET percent = ?
                WHERE user_id = ? AND id = ?
                """,
                (percent, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update percent for expense category %s of user %s: %s",
                category_id,
                user_id,
                error,
            )

    def sum_income_category_percents(self, user_id: int) -> int:
        """Return sum of percents for active income categories."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(SUM(percent), 0) FROM income_categories WHERE user_id = ? AND is_active = 1",
                (user_id,),
            )
            result = cursor.fetchone()
            return int(result[0]) if result and result[0] is not None else 0
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to calculate percent sum for user %s: %s",
                user_id,
                error,
            )
            return 0

    def sum_expense_category_percents(self, user_id: int) -> int:
        """Return sum of percents for active expense categories."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(SUM(percent), 0) FROM expense_categories WHERE user_id = ? AND is_active = 1",
                (user_id,),
            )
            result = cursor.fetchone()
            return int(result[0]) if result and result[0] is not None else 0
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to calculate expense percent sum for user %s: %s",
                user_id,
                error,
            )
            return 0

    def get_income_category_by_id(self, user_id: int, category_id: int) -> Optional[Dict[str, Any]]:
        """Return income category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM income_categories
                WHERE user_id = ? AND id = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch income category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def get_expense_category_by_id(
        self, user_id: int, category_id: int
    ) -> Optional[Dict[str, Any]]:
        """Return expense category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM expense_categories
                WHERE user_id = ? AND id = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch expense category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def get_user_settings(self, user_id: int) -> Dict[str, Any]:
        """Return user settings ensuring defaults exist."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT user_id, purchased_keep_days, byt_reminders_enabled, byt_defer_enabled, byt_defer_max_days
                FROM user_settings
                WHERE user_id = ?
                LIMIT 1
                """,
                (user_id,),
            )
            row = cursor.fetchone()
            return dict(row) if row else {}
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch user settings for %s: %s", user_id, error)
            return {}

    def update_purchased_keep_days(self, user_id: int, days: int) -> None:
        """Update purchased_keep_days value."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET purchased_keep_days = ? WHERE user_id = ?",
                (days, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased_keep_days for user %s: %s", user_id, error
            )

    def update_wishlist_category_purchased_mode(
        self, user_id: int, category_id: int, mode: str
    ) -> None:
        """Update purchased display mode for wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE wishlist_categories SET purchased_mode = ? WHERE user_id = ? AND id = ?",
                (mode, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased mode for category %s user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_wishlist_category_purchased_days(
        self, user_id: int, category_id: int, days: int
    ) -> None:
        """Update purchased days retention for wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE wishlist_categories SET purchased_days = ? WHERE user_id = ? AND id = ?",
                (days, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased days for category %s user %s: %s",
                category_id,
                user_id,
                error,
            )

    def set_byt_reminders_enabled(self, user_id: int, enabled: bool) -> None:
        """Toggle BYT reminders enabled flag."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET byt_reminders_enabled = ? WHERE user_id = ?",
                (1 if enabled else 0, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_reminders_enabled for user %s: %s", user_id, error
            )

    def set_byt_defer_enabled(self, user_id: int, enabled: bool) -> None:
        """Toggle BYT defer feature flag."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET byt_defer_enabled = ? WHERE user_id = ?",
                (1 if enabled else 0, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_defer_enabled for user %s: %s", user_id, error
            )

    def set_byt_defer_max_days(self, user_id: int, max_days: int) -> None:
        """Update max defer days setting."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET byt_defer_max_days = ? WHERE user_id = ?",
                (max_days, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_defer_max_days for user %s: %s", user_id, error
            )

    def update_byt_defer_max_days(self, user_id: int, days: int) -> None:
        """Alias for set_byt_defer_max_days for compatibility."""

        self.set_byt_defer_max_days(user_id, days)

    def get_wishlist_category_by_id(
        self, user_id: int, category_id: int
    ) -> Optional[Dict[str, Any]]:
        """Return wishlist category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM wishlist_categories
                WHERE user_id = ? AND id = ?
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch wishlist category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def deactivate_wishlist_category(self, user_id: int, category_id: int) -> None:
        """Soft delete wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE wishlist_categories
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate wishlist category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    @staticmethod
    def _column_exists(cursor: sqlite3.Cursor, table: str, column: str) -> bool:
        """Return True if column exists in table."""

        cursor.execute(f"PRAGMA table_info({table})")
        return any(row[1] == column for row in cursor.fetchall())

    def _add_column_if_missing(
        self, cursor: sqlite3.Cursor, table: str, column: str, definition: str
    ) -> None:
        """Add column to table if it does not already exist."""

        if not self._column_exists(cursor, table, column):
            cursor.execute(f"ALTER TABLE {table} ADD COLUMN {column} {definition}")

    def get_user_savings(self, user_id: int) -> Dict[str, Dict[str, Any]]:
        """Get all savings for a user.

        Args:
            user_id (int): Telegram user id.

        Returns:
            dict: Mapping category to saving details.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT category, current, goal, purpose FROM savings WHERE user_id = ?",
                (user_id,),
            )
            rows = cursor.fetchall()
            savings = {}
            for row in rows:
                current = self._to_float(row["current"])
                goal = self._to_float(row["goal"])
                savings[row["category"]] = {
                    "current": current,
                    "goal": goal,
                    "purpose": row["purpose"],
                }
            LOGGER.info("Fetched savings for user %s", user_id)
            return savings
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch savings for user %s: %s", user_id, error)
            return {}

    def get_user_savings_map(self, user_id: int) -> Dict[str, float]:
        """Return a simple mapping of category to current savings.

        Args:
            user_id (int): Telegram user id.

        Returns:
            dict[str, float]: Mapping of category names to current amount.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT category, current FROM savings WHERE user_id = ?",
                (user_id,),
            )
            rows = cursor.fetchall()
            mapping = {}
            for row in rows:
                mapping[row["category"]] = self._to_float(row["current"])
            LOGGER.info("Fetched savings map for user %s", user_id)
            return mapping
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch savings map for user %s: %s", user_id, error)
            return {}

    def update_saving(self, user_id: int, category: str, amount_delta: float) -> None:
        """Update saving for category by amount delta.

        Args:
            user_id (int): Telegram user id.
            category (str): Category name.
            amount_delta (float): Amount to add or subtract.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id, current FROM savings WHERE user_id = ? AND category = ?",
                (user_id, category),
            )
            row = cursor.fetchone()
            delta = self._to_float(amount_delta)
            if row:
                current = self._to_float(row["current"])
                new_value = current + delta
                cursor.execute(
                    "UPDATE savings SET current = ? WHERE id = ?",
                    (new_value, row["id"]),
                )
            else:
                cursor.execute(
                    "INSERT INTO savings (user_id, category, current, goal, purpose) VALUES (?, ?, ?, 0, '')",
                    (user_id, category, delta),
                )
            self.connection.commit()
            LOGGER.info(
                "Updated saving for user %s category %s by %s",
                user_id,
                category,
                amount_delta,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update saving for user %s category %s: %s",
                user_id,
                category,
                error,
            )

    def _update_saving_in_transaction(
        self,
        cursor: sqlite3.Cursor,
        user_id: int,
        category: str,
        amount_delta: float,
    ) -> None:
        cursor.execute(
            "SELECT id, current FROM savings WHERE user_id = ? AND category = ?",
            (user_id, category),
        )
        row = cursor.fetchone()
        delta = self._to_float(amount_delta)
        if row:
            current = self._to_float(row["current"])
            new_value = current + delta
            cursor.execute(
                "UPDATE savings SET current = ? WHERE id = ?",
                (new_value, row["id"]),
            )
        else:
            cursor.execute(
                "INSERT INTO savings (user_id, category, current, goal, purpose) VALUES (?, ?, ?, 0, '')",
                (user_id, category, delta),
            )

    def decrease_savings(self, user_id: int, category: str, amount: float) -> None:
        """Decrease savings for category by amount."""

        self.update_saving(user_id, category, -abs(amount))

    def set_goal(self, user_id: int, category: str, goal: float, purpose: str) -> None:
        """Set goal and purpose for saving category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id FROM savings WHERE user_id = ? AND category = ?",
                (user_id, category),
            )
            row = cursor.fetchone()
            if row:
                cursor.execute(
                    "UPDATE savings SET goal = ?, purpose = ? WHERE id = ?",
                    (goal, purpose, row["id"]),
                )
            else:
                cursor.execute(
                    "INSERT INTO savings (user_id, category, current, goal, purpose) VALUES (?, ?, 0, ?, ?)",
                    (user_id, category, goal, goal, purpose),
                )
            self.connection.commit()
            LOGGER.info("Set goal for user %s category %s", user_id, category)
        except sqlite3.Error as error:
            LOGGER.error("Failed to set goal for user %s category %s: %s", user_id, category, error)

    def reset_goals(self, user_id: int) -> None:
        """Reset goals for user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute("UPDATE savings SET goal = 0, purpose = '' WHERE user_id = ?", (user_id,))
            self.connection.commit()
            LOGGER.info("Reset goals for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to reset goals for user %s: %s", user_id, error)

    def add_wish(self, user_id: int, name: str, price: float, url: Optional[str], category: str) -> int:
        """Add a wish to the wishlist."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "INSERT INTO wishes (user_id, name, price, url, category, is_purchased, saved_amount, purchased_at) VALUES (?, ?, ?, ?, ?, 0, 0, NULL)",
                (user_id, name, price, url, category),
            )
            self.connection.commit()
            wish_id = cursor.lastrowid
            LOGGER.info("Added wish %s for user %s", wish_id, user_id)
            return wish_id
        except sqlite3.Error as error:
            LOGGER.error("Failed to add wish for user %s: %s", user_id, error)
            return 0

    def get_wishes_by_user(self, user_id: int) -> List[Dict[str, Any]]:
        """Get all wishes for a user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE user_id = ?
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched wishes for user %s", user_id)
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch wishes for user %s: %s", user_id, error)
            return []

    def get_wish(self, wish_id: int) -> Optional[Dict[str, Any]]:
        """Get wish by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE id = ?
                """,
                (wish_id,),
            )
            row = cursor.fetchone()
            LOGGER.info("Fetched wish %s", wish_id)
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch wish %s: %s", wish_id, error)
            return None

    def get_active_byt_wishes(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active BYT wishes for user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE user_id = ? AND category IN ('byt', 'БЫТ') AND (is_purchased = 0 OR is_purchased IS NULL)
                ORDER BY id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched active BYT wishes for user %s", user_id)
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch BYT wishes for user %s: %s", user_id, error)
            return []

    def list_active_byt_items_for_reminder(
        self, user_id: int, now_dt: datetime
    ) -> List[Dict[str, Any]]:
        """Return BYT wishlist items available for reminders at given time."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE user_id = ?
                  AND category IN ('byt', 'БЫТ')
                  AND (is_purchased = 0 OR is_purchased IS NULL)
                  AND (deferred_until IS NULL OR deferred_until <= ?)
                ORDER BY id
                """,
                (user_id, now_dt.isoformat()),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT reminder wishes for user %s: %s", user_id, error
            )
            return []

    def set_wishlist_item_deferred_until(
        self, user_id: int, item_id: int, deferred_until_iso: Optional[str]
    ) -> None:
        """Set deferred_until for wishlist item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE wishes
                SET deferred_until = ?
                WHERE id = ? AND user_id = ?
                """,
                (deferred_until_iso, item_id, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Set deferred_until for wish %s user %s to %s",
                item_id,
                user_id,
                deferred_until_iso,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to set deferred_until for wish %s user %s: %s",
                item_id,
                user_id,
                error,
            )

    def mark_wish_purchased(self, wish_id: int, purchased_at: Optional[datetime] = None) -> None:
        """Mark wish as purchased with timestamp."""

        try:
            cursor = self.connection.cursor()
            purchased_value = (purchased_at or now_tz()).isoformat()
            cursor.execute(
                """
                UPDATE wishes
                SET is_purchased = 1, purchased_at = ?, deferred_until = NULL
                WHERE id = ?
                """,
                (purchased_value, wish_id),
            )
            self.connection.commit()
            LOGGER.info("Marked wish %s as purchased", wish_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to mark wish %s as purchased: %s", wish_id, error)

    def add_purchase(
        self,
        user_id: int,
        wish_name: str,
        price: float,
        category: str,
        purchased_at: Optional[datetime] = None,
    ) -> None:
        """Add purchase record."""

        try:
            cursor = self.connection.cursor()
            purchased_value = (purchased_at or now_tz()).isoformat()
            cursor.execute(
                "INSERT INTO purchases (user_id, wish_name, price, category, purchased_at) VALUES (?, ?, ?, ?, ?)",
                (user_id, wish_name, price, category, purchased_value),
            )
            self.connection.commit()
            LOGGER.info("Added purchase for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to add purchase for user %s: %s", user_id, error)

    async def household_status_exists(self, user_id: int, month: str) -> bool:
        """Check if household payment statuses exist for month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM household_payments WHERE user_id = ? AND month = ? LIMIT 1",
                (user_id, month),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to check household status for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def init_household_questions_for_month(self, user_id: int, month: str) -> None:
        """Initialize household payment questions for month."""

        try:
            if BOT_USER_ID is not None and user_id == BOT_USER_ID:
                LOGGER.warning(
                    "Skipping household questions init for bot user %s", user_id
                )
                return
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT OR IGNORE INTO household_payments (user_id, month, question_code, is_paid)
                SELECT ?, ?, code, 0
                FROM household_payment_items
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id, month, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Initialized household questions for user %s month %s", user_id, month
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to init household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )

    async def mark_household_question_paid(
        self, user_id: int, month: str, question_code: str
    ) -> None:
        """Mark household question as paid."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT INTO household_payments (user_id, month, question_code, is_paid)
                VALUES (?, ?, ?, 1)
                ON CONFLICT(user_id, month, question_code)
                DO UPDATE SET is_paid = excluded.is_paid
                """,
                (user_id, month, question_code),
            )
            self.connection.commit()
            LOGGER.info(
                "Marked household question %s as paid for user %s month %s",
                question_code,
                user_id,
                month,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to mark household question %s paid for user %s month %s: %s",
                question_code,
                user_id,
                month,
                error,
            )

    async def mark_household_question_unpaid(
        self, user_id: int, month: str, question_code: str
    ) -> None:
        """Mark household question as unpaid."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT INTO household_payments (user_id, month, question_code, is_paid)
                VALUES (?, ?, ?, 0)
                ON CONFLICT(user_id, month, question_code)
                DO UPDATE SET is_paid = excluded.is_paid
                """,
                (user_id, month, question_code),
            )
            self.connection.commit()
            LOGGER.info(
                "Marked household question %s as unpaid for user %s month %s",
                question_code,
                user_id,
                month,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to mark household question %s unpaid for user %s month %s: %s",
                question_code,
                user_id,
                month,
                error,
            )

    def apply_household_payment_answer(
        self,
        user_id: int,
        month: str,
        question_code: str,
        amount: float | None,
        answer: str,
    ) -> bool:
        """Apply household answer and savings update atomically.

        Returns True if state changed, False if it was already applied.
        """

        try:
            cursor = self.connection.cursor()
            self.connection.execute("BEGIN")
            cursor.execute(
                """
                SELECT is_paid
                FROM household_payments
                WHERE user_id = ? AND month = ? AND question_code = ?
                """,
                (user_id, month, question_code),
            )
            row = cursor.fetchone()
            if row is None:
                cursor.execute(
                    """
                    INSERT INTO household_payments (user_id, month, question_code, is_paid)
                    VALUES (?, ?, ?, 0)
                    """,
                    (user_id, month, question_code),
                )
                current_paid = 0
            else:
                current_paid = int(row["is_paid"])

            target_paid = 1 if answer == "yes" else 0
            if current_paid == target_paid:
                self.connection.commit()
                return False

            cursor.execute(
                """
                UPDATE household_payments
                SET is_paid = ?
                WHERE user_id = ? AND month = ? AND question_code = ?
                """,
                (target_paid, user_id, month, question_code),
            )
            if amount is not None:
                delta = -abs(amount) if answer == "yes" else abs(amount)
                self._update_saving_in_transaction(cursor, user_id, "быт", delta)
            self.connection.commit()
            return True
        except sqlite3.Error as error:
            self.connection.rollback()
            LOGGER.error(
                "Failed to apply household answer for user %s month %s code %s: %s",
                user_id,
                month,
                question_code,
                error,
            )
            return False

    async def get_unpaid_household_questions(self, user_id: int, month: str) -> List[str]:
        """Get unpaid household question codes for user and month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT items.code
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                ORDER BY items.position, items.id
                """,
                (month, user_id),
            )
            rows = cursor.fetchall()
            return [row["code"] for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get unpaid household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return []

    async def get_household_payment_status_map(
        self, user_id: int, month: str
    ) -> Dict[str, int]:
        """Return mapping: question_code -> is_paid (0/1) for the given month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT items.code, COALESCE(payments.is_paid, 0) AS is_paid
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ? AND items.is_active = 1
                """,
                (month, user_id),
            )
            rows = cursor.fetchall()
            return {row["code"]: int(row["is_paid"]) for row in rows}
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get household payment status for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return {}

    async def has_unpaid_household_questions(self, user_id: int, month: str) -> bool:
        """Return True if unpaid household questions exist for month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT 1
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                LIMIT 1
                """,
                (month, user_id),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to check unpaid household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def should_show_household_payments_button(
        self, user_id: int, month: str
    ) -> bool:
        """Return True if any active household payment is unpaid for the month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT 1
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                LIMIT 1
                """,
                (month, user_id),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to decide household payments button for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def reset_household_questions_for_month(self, user_id: int, month: str) -> None:
        """Reset household payment progress for a specific month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE household_payments
                SET is_paid = 0
                WHERE user_id = ? AND month = ?
                """,
                (user_id, month),
            )
            cursor.execute(
                """
                INSERT OR IGNORE INTO household_payments (user_id, month, question_code, is_paid)
                SELECT ?, ?, code, 0
                FROM household_payment_items
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id, month, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Reset household questions for user %s month %s", user_id, month
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to reset household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )

    def get_purchases_by_user(self, user_id: int) -> List[Dict[str, Any]]:
        """Get purchases for user honoring retention settings."""

        self.ensure_user_settings(user_id)
        self.ensure_wishlist_categories_seeded(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id, wish_name, price, category, purchased_at FROM purchases WHERE user_id = ? ORDER BY purchased_at DESC",
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched purchases for user %s", user_id)
            purchases = [dict(row) for row in rows]
            filtered: list[Dict[str, Any]] = []
            current_time = now_tz()
            settings_row = self.get_user_settings(user_id)
            default_days = int(settings_row.get("purchased_keep_days", 30) or 30)
            categories = self.list_active_wishlist_categories(user_id)
            category_map = {
                cat.get("title", ""): {
                    "mode": (cat.get("purchased_mode") or "days"),
                    "days": int(cat.get("purchased_days") or default_days),
                }
                for cat in categories
            }
            for purchase in purchases:
                cat_settings = category_map.get(
                    str(purchase.get("category", "")),
                    {"mode": "days", "days": default_days},
                )
                if cat_settings.get("mode") == "always":
                    filtered.append(purchase)
                    continue
                keep_delta = timedelta(days=int(cat_settings.get("days", default_days)))
                timestamp = purchase.get("purchased_at")
                if timestamp:
                    try:
                        purchase_dt = datetime.fromisoformat(str(timestamp))
                        if purchase_dt.tzinfo is None:
                            purchase_dt = purchase_dt.replace(tzinfo=settings.TIMEZONE)
                    except ValueError:
                        continue
                    if purchase_dt + keep_delta <= current_time:
                        continue
                filtered.append(purchase)
            return filtered
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch purchases for user %s: %s", user_id, error)
            return []

    def list_active_byt_timer_times(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active BYT timer times for user."""

        self.ensure_byt_timer_defaults(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, hour, minute
                FROM byt_timer_times
                WHERE user_id = ? AND is_active = 1
                ORDER BY hour, minute, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT timer times for user %s: %s", user_id, error
            )
            return []

    def add_byt_timer_time(self, user_id: int, hour: int, minute: int) -> Optional[int]:
        """Add a new BYT timer time if not duplicate."""

        self.ensure_byt_timer_defaults(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id FROM byt_timer_times
                WHERE user_id = ? AND hour = ? AND minute = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, hour, minute),
            )
            existing = cursor.fetchone()
            if existing:
                return int(existing["id"])

            cursor.execute(
                """
                INSERT INTO byt_timer_times (user_id, hour, minute, is_active)
                VALUES (?, ?, ?, 1)
                """,
                (user_id, hour, minute),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to add BYT timer time for user %s: %s", user_id, error)
            return None

    def deactivate_byt_timer_time(self, user_id: int, timer_id: int) -> None:
        """Deactivate specific BYT timer time."""

