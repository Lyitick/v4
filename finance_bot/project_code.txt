===== .env =====

BOT_TOKEN=

===== .pytest_cache/.gitignore =====

# Created by pytest automatically.
*

===== .pytest_cache/CACHEDIR.TAG =====

Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

===== .pytest_cache/README.md =====

# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

===== .pytest_cache/v/cache/lastfailed =====

{}

===== .pytest_cache/v/cache/nodeids =====

[
  "tests/unit/test_byt_reminder_schedule.py::test_get_next_reminder_dt_default",
  "tests/unit/test_byt_reminder_schedule.py::test_get_next_reminder_dt_today",
  "tests/unit/test_byt_reminder_schedule.py::test_get_next_reminder_dt_tomorrow",
  "tests/unit/test_byt_reminder_settings.py::test_defer_confirmation_text_contains_details",
  "tests/unit/test_byt_reminder_settings.py::test_toggle_byt_category_and_times"
]

===== AUDIT_household_payments_ui.md =====

# Audit: household payments UI

## ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ Ð½Ðµ Ð¼ÐµÐ½ÑÐ»Ð¸ÑÑŒ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹
- Ð¢ÐµÐºÑƒÑ‰Ð¸Ð¹ Ð²Ð¾Ð¿Ñ€Ð¾Ñ ÑƒÐ´Ð°Ð»ÑÐ»ÑÑ ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ð°, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ `edit_message_text` Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÑÐ»ÑÑ Ðº ÑƒÐ¶Ðµ ÑƒÐ´Ð°Ð»Ñ‘Ð½Ð½Ð¾Ð¼Ñƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑŽ.
- Ð’ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… Ð²ÐµÑ‚ÐºÐ°Ñ… Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²Ð¾Ð²Ð°Ð» ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ `last_question_message_id`, Ð¸Ð·-Ð·Ð° Ñ‡ÐµÐ³Ð¾ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð½Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð»Ð¾ Ð² Ð½ÑƒÐ¶Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ.

## ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð» Ð¾Ñ‚ÑÑ‡Ñ‘Ñ‚
- ÐžÑ‚ÑÑ‡Ñ‘Ñ‚ Ð±Ñ‹Ð» Ð½Ð° 3 ÑÐµÐºÑƒÐ½Ð´Ñ‹ Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð½Ðµ Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð»Ð¾ÑÑŒ Ð² ÐµÐ´Ð¸Ð½Ð¾Ð¼ ÑÐ¿Ð¸ÑÐºÐµ UI-ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ñ‡Ð°ÑÑ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð¾ÑÑ‚Ð°Ð²Ð°Ð»Ð°ÑÑŒ Ð´Ð¾ Ð¿Ð¾ÑÐ²Ð»ÐµÐ½Ð¸Ñ Ð³Ð»Ð°Ð²Ð½Ð¾Ð³Ð¾ Ð¼ÐµÐ½ÑŽ.

## ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ ÑƒÐ´Ð°Ð»ÑÐ»Ð¾ÑÑŒ 4/6 Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ¾Ð²
- Ð¡Ð¿Ð¸ÑÐ¾Ðº ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð´Ð»Ñ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ¸ Ñ…Ñ€Ð°Ð½Ð¸Ð»ÑÑ Ð½ÐµÐ¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ (`ui_message_ids` vs `household_ui_message_ids`), Ñ‡Ð°ÑÑ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð½Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð»Ð° Ð² Ð¾Ð±Ñ‰Ð¸Ð¹ Ñ€ÐµÐµÑÑ‚Ñ€ Ð¸ ÑƒÐ´Ð°Ð»ÑÐ»Ð°ÑÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¼ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ðµ Ðº Ð³Ð»Ð°Ð²Ð½Ð¾Ð¼Ñƒ Ð¼ÐµÐ½ÑŽ.

## Ð§Ñ‚Ð¾ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾
- Ð’ÑÐµ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÑŽÑ‚ÑÑ Ð² ÐµÐ´Ð¸Ð½Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº `household_ui_message_ids` Ñ Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð¿Ñ€Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ.
- ÐŸÐ¾ÑÐ»Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð²Ð¾Ð¿Ñ€Ð¾Ñ Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÐµÑ‚ÑÑ: Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð² âœ…/âŒ!!! Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚, Ð·Ð°Ñ‚ÐµÐ¼ Ð·Ð°Ð´Ð°Ñ‘Ñ‚ÑÑ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹.
- ÐžÑ‚ÑÑ‡Ñ‘Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ 5â†’1 Ñ `await asyncio.sleep(1)` Ð¼ÐµÐ¶Ð´Ñƒ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸ÑÐ¼Ð¸, ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ÑÑ‡Ñ‘Ñ‚Ð° Ñ‚Ð¾Ð¶Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ Ð² `household_ui_message_ids`.
- ÐŸÐ¾Ð»Ð½Ð°Ñ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ° Ð²ÑÐµÑ… Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¾Ñ‚ÑÑ‡Ñ‘Ñ‚Ð° Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ Ð´Ð¾ Ð¿Ð¾ÐºÐ°Ð·Ð° Ð³Ð»Ð°Ð²Ð½Ð¾Ð³Ð¾ Ð¼ÐµÐ½ÑŽ.

===== Bot/__init__.py =====

"""Package initializer for finance bot modules."""

===== Bot/config/__init__.py =====



===== Bot/config/logging_config.py =====

"""Logging configuration for the bot."""
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path

LOG_FORMAT = "[%(asctime)s] [%(levelname)s] %(message)s"
LOG_LEVEL = logging.INFO
LOG_FILE = Path(__file__).resolve().parents[2] / "finance_bot.log"


def setup_logging() -> None:
    """Configure logging for application."""

    LOG_FILE.touch(exist_ok=True)
    formatter = logging.Formatter(LOG_FORMAT)

    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5_000_000, backupCount=3, encoding="utf-8")
    file_handler.setLevel(LOG_LEVEL)
    file_handler.setFormatter(formatter)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(LOG_LEVEL)
    console_handler.setFormatter(formatter)

    root_logger = logging.getLogger()
    root_logger.setLevel(LOG_LEVEL)
    root_logger.handlers.clear()
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)

===== Bot/config/settings.py =====

"""Bot settings module."""
from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from zoneinfo import ZoneInfo


def _load_env_file(env_path: Path) -> dict[str, str]:
    if not env_path.exists():
        return {}

    data: dict[str, str] = {}
    for line in env_path.read_text(encoding="utf-8").splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#") or "=" not in stripped:
            continue
        key, value = stripped.split("=", 1)
        data[key.strip()] = value.strip().strip("\"'")
    return data


def _resolve_bot_token() -> tuple[str, str]:
    if "BOT_TOKEN" in os.environ:
        return os.environ.get("BOT_TOKEN", ""), "env"

    env_path = Path(__file__).resolve().parents[2] / ".env"
    env_values = _load_env_file(env_path)
    if "BOT_TOKEN" in env_values:
        os.environ.setdefault("BOT_TOKEN", env_values["BOT_TOKEN"])
        return env_values["BOT_TOKEN"], ".env"

    return "", "missing"


BOT_TOKEN, BOT_TOKEN_SOURCE = _resolve_bot_token()
ADMIN_ID: int = 838347504
TIMEZONE = ZoneInfo("Europe/Moscow")


@dataclass
class Settings:
    """Container for application settings."""

    bot_token: str = BOT_TOKEN
    bot_token_source: str = BOT_TOKEN_SOURCE
    admin_id: int = ADMIN_ID
    timezone: ZoneInfo = TIMEZONE


def get_settings() -> Settings:
    """Get current settings.

    Returns:
        Settings: Dataclass with bot settings.
    """

    return Settings()

===== Bot/constants/__init__.py =====

"""Constants for bot behavior."""

===== Bot/constants/ui.py =====

WELCOME_TEXT = "ÐŸÐ¾Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÐ¼ Ð±Ð»"

===== Bot/constants/ui_labels.py =====

"""UI label constants."""

WISHLIST_DEBIT_CATEGORY_BUTTON = "ðŸ’° ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ ÑÐ¿Ð¸ÑÐ°Ð½Ð¸Ñ"
WISHLIST_DEBIT_CATEGORY_NONE = "âŒ ÐÐµ ÑÐ¿Ð¸ÑÑ‹Ð²Ð°Ñ‚ÑŒ"
WISHLIST_DEBIT_CATEGORY_BACK = "â¬…ï¸ ÐÐ°Ð·Ð°Ð´"
WISHLIST_BYT_CATEGORY_BUTTON = "Ð’Ñ‹Ð±Ð¾Ñ€ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸ Ð´Ð»Ñ Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹"

===== Bot/database/__init__.py =====



===== Bot/database/crud.py =====

"""Database CRUD operations for finance bot."""
from __future__ import annotations

import logging
import sqlite3
import time
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from threading import Lock
from typing import Any, Dict, List, Optional

from Bot.config.settings import get_settings
from Bot.utils.datetime_utils import add_one_month, now_tz
from Bot.utils.text_sanitizer import sanitize_income_title


LOGGER = logging.getLogger(__name__)
DB_PATH = Path(__file__).resolve().parents[2] / "finance.db"
TARGET_SCHEMA_VERSION = 1


@dataclass(frozen=True)
class TableNames:
    savings: str = "Ð½Ð°ÐºÐ¾Ð¿Ð»ÐµÐ½Ð¸Ñ"
    wishes: str = "Ð¶ÐµÐ»Ð°Ð½Ð¸Ñ"
    purchases: str = "Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸"
    household_payments: str = "Ð±Ñ‹Ñ‚Ð¾Ð²Ñ‹Ðµ_Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð¸"
    household_payment_items: str = "Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸_Ð±Ñ‹Ñ‚Ð¾Ð²Ñ‹Ñ…_Ð¿Ð»Ð°Ñ‚ÐµÐ¶ÐµÐ¹"
    ui_pins: str = "Ð·Ð°ÐºÑ€ÐµÐ¿Ñ‹_Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°"
    income_categories: str = "ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸_Ð´Ð¾Ñ…Ð¾Ð´Ð¾Ð²"
    expense_categories: str = "ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸_Ñ€Ð°ÑÑ…Ð¾Ð´Ð¾Ð²"
    wishlist_categories: str = "ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸_Ð¶ÐµÐ»Ð°Ð½Ð¸Ð¹"
    user_settings: str = "Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸_Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ"
    byt_timer_times: str = "Ð²Ñ€ÐµÐ¼Ñ_Ð±Ñ‹Ñ‚_Ñ‚Ð°Ð¹Ð¼ÐµÑ€Ð°"
    byt_reminder_categories: str = "ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸_Ð±Ñ‹Ñ‚_Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹"
    byt_reminder_times: str = "Ð²Ñ€ÐµÐ¼Ñ_Ð±Ñ‹Ñ‚_Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹"


TABLES = TableNames()
TABLE_RENAMES: dict[str, str] = {
    "savings": TABLES.savings,
    "wishes": TABLES.wishes,
    "purchases": TABLES.purchases,
    "household_payments": TABLES.household_payments,
    "household_payment_items": TABLES.household_payment_items,
    "ui_pins": TABLES.ui_pins,
    "income_categories": TABLES.income_categories,
    "expense_categories": TABLES.expense_categories,
    "wishlist_categories": TABLES.wishlist_categories,
    "user_settings": TABLES.user_settings,
    "byt_timer_times": TABLES.byt_timer_times,
    "byt_reminder_categories": TABLES.byt_reminder_categories,
    "byt_reminder_times": TABLES.byt_reminder_times,
}
LEGACY_TABLE_NAMES = tuple(TABLE_RENAMES.keys())


def _get_bot_user_id() -> int | None:
    try:
        token = get_settings().bot_token
        if not token:
            return None
        return int(str(token).split(":")[0])
    except (AttributeError, IndexError, TypeError, ValueError):
        return None


BOT_USER_ID = _get_bot_user_id()
DEFAULT_HOUSEHOLD_ITEMS = [
    {"code": "phone", "text": "Ð¢ÐµÐ»ÐµÑ„Ð¾Ð½ 600Ñ€?", "amount": 600},
    {"code": "internet", "text": "Ð˜Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚ 700Ñ€?", "amount": 700},
    {"code": "vpn", "text": "VPN 100Ñ€?", "amount": 100},
    {"code": "gpt", "text": "GPT 2000Ñ€?", "amount": 2000},
    {"code": "yandex_sub", "text": "Ð¯Ð½Ð´ÐµÐºÑ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ° 400Ñ€?", "amount": 400},
    {"code": "rent", "text": "ÐšÐ²Ð°Ñ€Ñ‚Ð¿Ð»Ð°Ñ‚Ð° 4000Ñ€? ÐŸÐ°Ð¿Ðµ ÑÐºÐ¸Ð½ÑƒÐ»?", "amount": 4000},
    {"code": "training_495", "text": "ÐžÐ¿Ð»Ð°Ñ‚Ð¸Ð» Ñ‚Ñ€ÐµÐ½Ð¸Ñ€Ð¾Ð²ÐºÐ¸ 495 - 5000Ñ€?", "amount": 5000},
]

DEFAULT_EXPENSE_CATEGORIES = [
    {"code": "Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ", "title": "Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹", "percent": 40, "position": 1},
    {"code": "Ð¶Ð¸Ð»ÑŒÐµ", "title": "Ð–Ð¸Ð»ÑŒÐµ Ð¸ Ð–ÐšÐ£", "percent": 20, "position": 2},
    {"code": "Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚", "title": "Ð¢Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚", "percent": 15, "position": 3},
    {"code": "ÐµÐ´Ð°", "title": "Ð•Ð´Ð°", "percent": 15, "position": 4},
    {"code": "Ð´Ñ€ÑƒÐ³Ð¾Ðµ", "title": "Ð”Ñ€ÑƒÐ³Ð¾Ðµ", "percent": 10, "position": 5},
]



def _get_user_version(cursor: sqlite3.Cursor) -> int:
    cursor.execute("PRAGMA user_version")
    row = cursor.fetchone()
    return int(row[0]) if row and row[0] is not None else 0


def _list_user_tables(cursor: sqlite3.Cursor) -> list[str]:
    cursor.execute(
        """
        SELECT name
        FROM sqlite_master
        WHERE type='table' AND name NOT LIKE 'sqlite_%'
        ORDER BY name
        """
    )
    return [str(row[0]) for row in cursor.fetchall()]


def _fetch_schema_definitions(cursor: sqlite3.Cursor) -> list[tuple[str, str]]:
    cursor.execute(
        """
        SELECT name, sql
        FROM sqlite_master
        WHERE type IN ('table', 'index', 'trigger', 'view') AND sql IS NOT NULL
        """
    )
    return [(str(row[0]), str(row[1])) for row in cursor.fetchall()]


def _assert_no_legacy_table_names(cursor: sqlite3.Cursor) -> None:
    schema_rows = _fetch_schema_definitions(cursor)
    for name, sql in schema_rows:
        for legacy_name in LEGACY_TABLE_NAMES:
            if legacy_name in sql:
                raise RuntimeError(
                    f"Legacy table name '{legacy_name}' found in schema object '{name}'"
                )


def migrate_schema(connection: sqlite3.Connection) -> None:
    cursor = connection.cursor()
    current_version = _get_user_version(cursor)
    if current_version >= TARGET_SCHEMA_VERSION:
        return

    existing_tables = set(_list_user_tables(cursor))
    LOGGER.info(
        "DB_MIGRATION start from_version=%s to_version=%s",
        current_version,
        TARGET_SCHEMA_VERSION,
    )
    renamed = 0
    try:
        cursor.execute("BEGIN IMMEDIATE")
        cursor.execute("PRAGMA foreign_keys = OFF")
        for old_name, new_name in TABLE_RENAMES.items():
            if old_name in existing_tables and new_name not in existing_tables:
                cursor.execute(
                    f'ALTER TABLE "{old_name}" RENAME TO "{new_name}"'
                )
                renamed += 1
                LOGGER.info("DB_MIGRATION rename %s->%s", old_name, new_name)
                existing_tables.discard(old_name)
                existing_tables.add(new_name)
        cursor.execute("PRAGMA foreign_keys = ON")
        cursor.execute("PRAGMA foreign_key_check")
        fk_issues = cursor.fetchall()
        if fk_issues:
            raise RuntimeError(f"Foreign key issues after migration: {fk_issues}")
        _assert_no_legacy_table_names(cursor)
        cursor.execute(f"PRAGMA user_version = {TARGET_SCHEMA_VERSION}")
        cursor.execute("COMMIT")
        LOGGER.info("DB_MIGRATION success renamed=%s", renamed)
    except Exception:
        cursor.execute("ROLLBACK")
        LOGGER.error("DB_MIGRATION failed", exc_info=True)
        raise


class FinanceDatabase:
    """Singleton class handling all database interactions."""

    _instance: Optional["FinanceDatabase"] = None
    _lock: Lock = Lock()

    def __new__(cls) -> "FinanceDatabase":
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize_connection()
        return cls._instance

    def _initialize_connection(self) -> None:
        """Initialize SQLite connection and create tables."""

        DB_PATH.touch(exist_ok=True)
        self.connection = sqlite3.connect(DB_PATH, check_same_thread=False)
        self.connection.row_factory = sqlite3.Row
        migrate_schema(self.connection)
        self.init_db()
        LOGGER.info("Database initialized at %s", DB_PATH)

    @staticmethod
    def _to_float(value: Any) -> float:
        """Safely convert a value to float, returning 0.0 on failure."""

        try:
            return float(value) if value is not None else 0.0
        except (TypeError, ValueError):
            return 0.0

    def init_db(self) -> None:
        """Create required tables if they do not exist."""

        cursor = self.connection.cursor()
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.savings}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                category TEXT,
                current REAL,
                goal REAL,
                purpose TEXT
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.wishes}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                name TEXT,
                price REAL,
                url TEXT,
                category TEXT,
                is_purchased INTEGER,
                saved_amount REAL DEFAULT 0,
                purchased_at TEXT,
                debited_at TEXT,
                deferred_until TEXT
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.purchases}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                wish_name TEXT,
                price REAL,
                category TEXT,
                purchased_at TEXT
            )
            """
        )
        self._add_column_if_missing(
            cursor, TABLES.wishes, "deferred_until", "TEXT"
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.household_payments}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                month TEXT,
                question_code TEXT,
                is_paid INTEGER DEFAULT 0,
                UNIQUE(user_id, month, question_code)
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.household_payment_items}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                code TEXT,
                text TEXT,
                amount INTEGER,
                position INTEGER DEFAULT 0,
                is_active INTEGER DEFAULT 1,
                paid_month TEXT,
                is_paid INTEGER DEFAULT 0,
                created_at TEXT,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.ui_pins}" (
                chat_id INTEGER PRIMARY KEY,
                welcome_message_id INTEGER,
                updated_at TEXT
            )
            """
        )
        self._add_column_if_missing(
            cursor, TABLES.household_payment_items, "paid_month", "TEXT"
        )
        self._add_column_if_missing(
            cursor, TABLES.household_payment_items, "is_paid", "INTEGER DEFAULT 0"
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.income_categories}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                code TEXT NOT NULL,
                title TEXT NOT NULL,
                percent INTEGER NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.expense_categories}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                code TEXT NOT NULL,
                title TEXT NOT NULL,
                percent INTEGER NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.wishlist_categories}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                title TEXT NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                purchased_mode TEXT DEFAULT 'days',
                purchased_days INTEGER DEFAULT 30
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.user_settings}" (
                user_id INTEGER PRIMARY KEY,
                purchased_keep_days INTEGER NOT NULL DEFAULT 30,
                byt_reminders_enabled INTEGER NOT NULL DEFAULT 1,
                byt_defer_enabled INTEGER NOT NULL DEFAULT 1,
                byt_defer_max_days INTEGER NOT NULL DEFAULT 365,
                household_debit_category TEXT,
                wishlist_debit_category_id TEXT,
                byt_wishlist_category_id TEXT
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.byt_timer_times}" (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                hour INTEGER NOT NULL,
                minute INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.byt_reminder_categories}" (
                user_id INTEGER NOT NULL,
                category_id INTEGER NOT NULL,
                enabled INTEGER NOT NULL DEFAULT 1,
                PRIMARY KEY (user_id, category_id)
            )
            """
        )
        cursor.execute(
            f"""
            CREATE TABLE IF NOT EXISTS "{TABLES.byt_reminder_times}" (
                user_id INTEGER NOT NULL,
                category_id INTEGER NOT NULL,
                time_hhmm TEXT NOT NULL,
                PRIMARY KEY (user_id, category_id, time_hhmm)
            )
            """
        )
        self._add_column_if_missing(cursor, TABLES.wishes, "purchased_at", "TEXT")
        self._add_column_if_missing(
            cursor, TABLES.wishlist_categories, "purchased_mode", "TEXT DEFAULT 'days'"
        )
        self._add_column_if_missing(
            cursor, TABLES.wishlist_categories, "purchased_days", "INTEGER DEFAULT 30"
        )
        self._add_column_if_missing(
            cursor, TABLES.user_settings, "household_debit_category", "TEXT"
        )
        self._add_column_if_missing(
            cursor, TABLES.user_settings, "wishlist_debit_category_id", "TEXT"
        )
        self._add_column_if_missing(
            cursor, TABLES.user_settings, "byt_wishlist_category_id", "TEXT"
        )
        self._add_column_if_missing(cursor, TABLES.wishes, "debited_at", "TEXT")
        self.connection.commit()
        self.sanitize_income_category_titles()

    def ensure_household_items_seeded(self, user_id: int) -> None:
        """No-op: household items are managed by user and stored in DB."""
        LOGGER.debug("Household item seeding disabled (user_id=%s)", user_id)

    def list_active_household_items(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active household payment items for user ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT code, text, amount, position
                FROM {TABLES.household_payment_items}
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list active household items for user %s: %s",
                user_id,
                error,
            )
            return []

    def get_household_item_by_code(
        self, user_id: int, code: str
    ) -> Optional[Dict[str, Any]]:
        """Return household payment item by code."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT code, text, amount, position
                FROM {TABLES.household_payment_items}
                WHERE user_id = ? AND code = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, code),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch household item %s for user %s: %s",
                code,
                user_id,
                error,
            )
            return None

    def get_next_household_position(self, user_id: int) -> int:
        """Return next position value for household items."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT MAX(position) FROM {TABLES.household_payment_items} WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            max_pos = row[0] if row and row[0] is not None else 0
            return int(max_pos) + 1
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get next household position for user %s: %s", user_id, error
            )
            return 1

    def add_household_payment_item(
        self, user_id: int, code: str, text: str, amount: int, position: int
    ) -> None:
        """Add new household payment item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                INSERT INTO {TABLES.household_payment_items} (
                    user_id, code, text, amount, position, is_active, created_at
                )
                VALUES (?, ?, ?, ?, ?, 1, ?)
                """,
                (user_id, code, text, amount, position, now_tz().isoformat()),
            )
            self.connection.commit()
            LOGGER.info("Added household payment item %s for user %s", code, user_id)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to add household item %s for user %s: %s",
                code,
                user_id,
                error,
            )

    def deactivate_household_payment_item(self, user_id: int, code: str) -> None:
        """Deactivate household payment item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.household_payment_items}
                SET is_active = 0
                WHERE user_id = ? AND code = ?
                """,
                (user_id, code),
            )
            self.connection.commit()
            LOGGER.info("Deactivated household payment item %s for user %s", code, user_id)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate household item %s for user %s: %s",
                code,
                user_id,
                error,
            )

    def sanitize_income_category_titles(self) -> None:
        """Sanitize stored income category titles."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(f"SELECT id, title FROM {TABLES.income_categories}")
            rows = cursor.fetchall()
            updates = []
            for row in rows:
                current_title = str(row["title"])
                sanitized = sanitize_income_title(current_title)
                if sanitized != current_title:
                    updates.append((sanitized, int(row["id"])))
            if updates:
                cursor.executemany(
                    f"UPDATE {TABLES.income_categories} SET title = ? WHERE id = ?",
                    updates,
                )
                self.connection.commit()
                LOGGER.info("Sanitized income category titles: %s", len(updates))
        except sqlite3.Error as error:
            LOGGER.error("Failed to sanitize income category titles: %s", error)

    def get_welcome_message_id(self, chat_id: int) -> int | None:
        """Fetch persisted welcome message id for chat."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT welcome_message_id FROM {TABLES.ui_pins} WHERE chat_id = ?",
                (chat_id,),
            )
            row = cursor.fetchone()
            if row and row["welcome_message_id"] is not None:
                return int(row["welcome_message_id"])
            return None
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch welcome message id for chat %s: %s", chat_id, error)
            return None

    def set_welcome_message_id(self, chat_id: int, message_id: int) -> None:
        """Persist welcome message id for chat."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                INSERT INTO {TABLES.ui_pins} (chat_id, welcome_message_id, updated_at)
                VALUES (?, ?, ?)
                ON CONFLICT(chat_id) DO UPDATE SET
                    welcome_message_id=excluded.welcome_message_id,
                    updated_at=excluded.updated_at
                """,
                (chat_id, message_id, datetime.utcnow().isoformat()),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to persist welcome message id for chat %s: %s", chat_id, error)

    def list_active_income_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active income categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, code, title, percent, position
                FROM {TABLES.income_categories}
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list income categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def get_income_categories_map(self, user_id: int) -> Dict[str, str]:
        """Return mapping of income category code to title."""

        categories = self.list_active_income_categories(user_id)
        category_map: Dict[str, str] = {}
        for item in categories:
            code = str(item.get("code", "")).strip()
            if not code:
                continue
            title = str(item.get("title", "")).strip()
            category_map[code] = title
        return category_map

    def ensure_expense_categories_seeded(self, user_id: int) -> None:
        """Seed default expense categories if user has none."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT 1 FROM {TABLES.expense_categories} WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for item in DEFAULT_EXPENSE_CATEGORIES:
                cursor.execute(
                    f"""
                    INSERT INTO {TABLES.expense_categories} (
                        user_id, code, title, percent, position, is_active
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                    """,
                    (
                        user_id,
                        item["code"],
                        item["title"],
                        item["percent"],
                        item["position"],
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default expense categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed expense categories for user %s: %s", user_id, error)

    def ensure_user_settings(self, user_id: int) -> None:
        """Ensure user_settings row exists with defaults."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT 1 FROM {TABLES.user_settings} WHERE user_id = ?",
                (user_id,),
            )
            if cursor.fetchone():
                return

            cursor.execute(
                f"""
                INSERT OR IGNORE INTO {TABLES.user_settings} (
                    user_id,
                    purchased_keep_days,
                    byt_reminders_enabled,
                    byt_defer_enabled,
                    byt_defer_max_days,
                    household_debit_category,
                    wishlist_debit_category_id,
                    byt_wishlist_category_id
                )
                VALUES (?, 30, 1, 1, 365, NULL, NULL, NULL)
                """,
                (user_id,),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to ensure user_settings for user %s: %s", user_id, error)

    def ensure_byt_timer_defaults(self, user_id: int) -> None:
        """Seed default BYT timer times (12:00, 18:00)."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT 1 FROM {TABLES.byt_timer_times} WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for hour, minute in [(12, 0), (18, 0)]:
                cursor.execute(
                    f"""
                    INSERT INTO {TABLES.byt_timer_times} (user_id, hour, minute, is_active)
                    VALUES (?, ?, ?, 1)
                    """,
                    (user_id, hour, minute),
                )
            self.connection.commit()
            LOGGER.info("Seeded default BYT timer times for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed BYT timer times for user %s: %s", user_id, error)

    def ensure_byt_reminder_migration(self, user_id: int) -> None:
        """Migrate legacy BYT category/time settings into per-category tables."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT 1
                FROM {TABLES.byt_reminder_categories}
                WHERE user_id = ?
                LIMIT 1
                """,
                (user_id,),
            )
            if cursor.fetchone():
                return
            self.ensure_byt_timer_defaults(user_id)
            settings_row = self.get_user_settings(user_id)
            raw_category_id = settings_row.get("byt_wishlist_category_id")
            try:
                category_id = int(raw_category_id) if raw_category_id is not None else None
            except (TypeError, ValueError):
                category_id = None
            if category_id is None:
                return
            cursor.execute(
                f"""
                INSERT OR IGNORE INTO {TABLES.byt_reminder_categories} (user_id, category_id, enabled)
                VALUES (?, ?, 1)
                """,
                (user_id, category_id),
            )
            cursor.execute(
                f"""
                SELECT hour, minute
                FROM {TABLES.byt_timer_times}
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id,),
            )
            for row in cursor.fetchall():
                time_hhmm = f"{int(row['hour']):02d}:{int(row['minute']):02d}"
                cursor.execute(
                    f"""
                    INSERT OR IGNORE INTO {TABLES.byt_reminder_times} (user_id, category_id, time_hhmm)
                    VALUES (?, ?, ?)
                    """,
                    (user_id, category_id, time_hhmm),
                )
            self.connection.commit()
            LOGGER.info(
                "Migrated legacy BYT settings to reminder tables (user_id=%s, category_id=%s)",
                user_id,
                category_id,
            )
        except sqlite3.Error as error:
            LOGGER.error("Failed to migrate BYT reminder settings for user %s: %s", user_id, error)

    def list_byt_reminder_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return wishlist categories with BYT reminder enabled flag."""

        self.ensure_byt_reminder_migration(user_id)
        categories = self.list_active_wishlist_categories(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT category_id, enabled
                FROM {TABLES.byt_reminder_categories}
                WHERE user_id = ?
                """,
                (user_id,),
            )
            enabled_map = {int(row["category_id"]): int(row["enabled"]) for row in cursor.fetchall()}
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT reminder categories for user %s: %s",
                user_id,
                error,
            )
            enabled_map = {}
        for category in categories:
            category_id = int(category.get("id") or 0)
            category["enabled"] = int(enabled_map.get(category_id, 0))
        return categories

    def list_enabled_byt_reminder_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return enabled wishlist categories for BYT reminders."""

        self.ensure_byt_reminder_migration(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT wc.id, wc.title, wc.position
                FROM {TABLES.wishlist_categories} AS wc
                JOIN {TABLES.byt_reminder_categories} AS brc
                  ON wc.id = brc.category_id
                WHERE wc.user_id = ? AND wc.is_active = 1 AND brc.enabled = 1
                ORDER BY wc.position, wc.id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list enabled BYT reminder categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def toggle_byt_reminder_category(self, user_id: int, category_id: int) -> bool:
        """Toggle BYT reminder category enabled flag and return new state."""

        self.ensure_byt_reminder_migration(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT enabled
                FROM {TABLES.byt_reminder_categories}
                WHERE user_id = ? AND category_id = ?
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            if row is None:
                new_enabled = 1
                cursor.execute(
                    f"""
                    INSERT INTO {TABLES.byt_reminder_categories} (user_id, category_id, enabled)
                    VALUES (?, ?, 1)
                    """,
                    (user_id, category_id),
                )
            else:
                current = int(row["enabled"])
                new_enabled = 0 if current else 1
                cursor.execute(
                    f"""
                    UPDATE {TABLES.byt_reminder_categories}
                    SET enabled = ?
                    WHERE user_id = ? AND category_id = ?
                    """,
                    (new_enabled, user_id, category_id),
                )
            self.connection.commit()
            return bool(new_enabled)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to toggle BYT reminder category for user %s: %s",
                user_id,
                error,
            )
            return False

    def get_byt_reminder_category_enabled(self, user_id: int, category_id: int) -> bool:
        """Return True when BYT reminders are enabled for category."""

        self.ensure_byt_reminder_migration(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT enabled
                FROM {TABLES.byt_reminder_categories}
                WHERE user_id = ? AND category_id = ?
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return bool(row and int(row["enabled"]))
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get BYT reminder category status for user %s: %s",
                user_id,
                error,
            )
            return False

    def list_byt_reminder_times(self, user_id: int, category_id: int) -> List[Dict[str, Any]]:
        """Return BYT reminder times for category."""

        self.ensure_byt_reminder_migration(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT time_hhmm
                FROM {TABLES.byt_reminder_times}
                WHERE user_id = ? AND category_id = ?
                ORDER BY time_hhmm
                """,
                (user_id, category_id),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT reminder times for user %s: %s",
                user_id,
                error,
            )
            return []

    def add_byt_reminder_time(
        self, user_id: int, category_id: int, time_hhmm: str
    ) -> None:
        """Add a new BYT reminder time for category."""

        self.ensure_byt_reminder_migration(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                INSERT OR IGNORE INTO {TABLES.byt_reminder_times} (user_id, category_id, time_hhmm)
                VALUES (?, ?, ?)
                """,
                (user_id, category_id, time_hhmm),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to add BYT reminder time for user %s: %s",
                user_id,
                error,
            )

    def remove_byt_reminder_time(
        self, user_id: int, category_id: int, time_hhmm: str
    ) -> None:
        """Remove BYT reminder time for category."""

        self.ensure_byt_reminder_migration(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                DELETE FROM {TABLES.byt_reminder_times}
                WHERE user_id = ? AND category_id = ? AND time_hhmm = ?
                """,
                (user_id, category_id, time_hhmm),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to remove BYT reminder time for user %s: %s",
                user_id,
                error,
            )

    def get_users_with_byt_reminder_times(self) -> List[int]:
        """Return users that have BYT reminder times configured."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT DISTINCT user_id
                FROM {TABLES.byt_reminder_times}
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with BYT reminder times: %s", error)
            return []

    def list_active_expense_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active expense categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, code, title, percent, position
                FROM {TABLES.expense_categories}
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list expense categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def list_active_wishlist_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active wishlist categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM {TABLES.wishlist_categories}
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list wishlist categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def create_income_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new income category with zero percent."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT COALESCE(MAX(position), 0) FROM {TABLES.income_categories} WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            code = f"custom_{time.time_ns()}"
            cursor.execute(
                f"""
                INSERT INTO {TABLES.income_categories} (user_id, code, title, percent, position)
                VALUES (?, ?, ?, 0, ?)
                """,
                (user_id, code, title, current_position + 1),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create income category for user %s: %s", user_id, error)
            return None

    def create_expense_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new expense category with zero percent."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT COALESCE(MAX(position), 0) FROM {TABLES.expense_categories} WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            code = f"custom_{time.time_ns()}"
            cursor.execute(
                f"""
                INSERT INTO {TABLES.expense_categories} (user_id, code, title, percent, position)
                VALUES (?, ?, ?, 0, ?)
                """,
                (user_id, code, title, current_position + 1),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create expense category for user %s: %s", user_id, error)
            return None

    def create_wishlist_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT COALESCE(MAX(position), 0) FROM {TABLES.wishlist_categories} WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            self.ensure_user_settings(user_id)
            cursor.execute(
                f"SELECT purchased_keep_days FROM {TABLES.user_settings} WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            default_days = int(row[0]) if row and row[0] is not None else 30
            cursor.execute(
                f"""
                INSERT INTO {TABLES.wishlist_categories} (user_id, title, position, purchased_mode, purchased_days)
                VALUES (?, ?, ?, 'days', ?)
                """,
                (user_id, title, current_position + 1, default_days),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create wishlist category for user %s: %s", user_id, error)
            return None

    def deactivate_income_category(self, user_id: int, category_id: int) -> None:
        """Deactivate income category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.income_categories}
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate income category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    def deactivate_expense_category(self, user_id: int, category_id: int) -> None:
        """Deactivate expense category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.expense_categories}
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate expense category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_income_category_percent(self, user_id: int, category_id: int, percent: int) -> None:
        """Update percent for income category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.income_categories}
                SET percent = ?
                WHERE user_id = ? AND id = ?
                """,
                (percent, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update percent for income category %s of user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_expense_category_percent(
        self, user_id: int, category_id: int, percent: int
    ) -> None:
        """Update percent for expense category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.expense_categories}
                SET percent = ?
                WHERE user_id = ? AND id = ?
                """,
                (percent, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update percent for expense category %s of user %s: %s",
                category_id,
                user_id,
                error,
            )

    def sum_income_category_percents(self, user_id: int) -> int:
        """Return sum of percents for active income categories."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT COALESCE(SUM(percent), 0) FROM {TABLES.income_categories} WHERE user_id = ? AND is_active = 1",
                (user_id,),
            )
            result = cursor.fetchone()
            return int(result[0]) if result and result[0] is not None else 0
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to calculate percent sum for user %s: %s",
                user_id,
                error,
            )
            return 0

    def sum_expense_category_percents(self, user_id: int) -> int:
        """Return sum of percents for active expense categories."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT COALESCE(SUM(percent), 0) FROM {TABLES.expense_categories} WHERE user_id = ? AND is_active = 1",
                (user_id,),
            )
            result = cursor.fetchone()
            return int(result[0]) if result and result[0] is not None else 0
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to calculate expense percent sum for user %s: %s",
                user_id,
                error,
            )
            return 0

    def get_income_category_by_id(self, user_id: int, category_id: int) -> Optional[Dict[str, Any]]:
        """Return income category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, code, title, percent, position
                FROM {TABLES.income_categories}
                WHERE user_id = ? AND id = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch income category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def get_income_category_by_code(
        self, user_id: int, code: str
    ) -> Optional[Dict[str, Any]]:
        """Return income category by code."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, code, title, percent, position
                FROM {TABLES.income_categories}
                WHERE user_id = ? AND code = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, code),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch income category %s for user %s: %s",
                code,
                user_id,
                error,
            )
            return None

    def get_expense_category_by_id(
        self, user_id: int, category_id: int
    ) -> Optional[Dict[str, Any]]:
        """Return expense category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, code, title, percent, position
                FROM {TABLES.expense_categories}
                WHERE user_id = ? AND id = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch expense category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def get_user_settings(self, user_id: int) -> Dict[str, Any]:
        """Return user settings ensuring defaults exist."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT
                    user_id,
                    purchased_keep_days,
                    byt_reminders_enabled,
                    byt_defer_enabled,
                    byt_defer_max_days,
                    household_debit_category,
                    wishlist_debit_category_id,
                    byt_wishlist_category_id
                FROM {TABLES.user_settings}
                WHERE user_id = ?
                LIMIT 1
                """,
                (user_id,),
            )
            row = cursor.fetchone()
            return dict(row) if row else {}
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch user settings for %s: %s", user_id, error)
            return {}

    def get_household_debit_category(self, user_id: int) -> str | None:
        """Return household debit category for user."""

        try:
            self.ensure_user_settings(user_id)
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT household_debit_category FROM {TABLES.user_settings} WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            if row:
                return row["household_debit_category"]
            return None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch household debit category for user %s: %s",
                user_id,
                error,
            )
            return None

    def set_household_debit_category(self, user_id: int, category: str) -> None:
        """Set household debit category for user."""

        try:
            self.ensure_user_settings(user_id)
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.user_settings}
                SET household_debit_category = ?
                WHERE user_id = ?
                """,
                (category, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update household debit category for user %s: %s",
                user_id,
                error,
            )

    def get_wishlist_debit_category(self, user_id: int) -> str | None:
        """Return wishlist debit category for user."""

        try:
            self.ensure_user_settings(user_id)
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT wishlist_debit_category_id FROM {TABLES.user_settings} WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            if row:
                return row["wishlist_debit_category_id"]
            return None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch wishlist debit category for user %s: %s",
                user_id,
                error,
            )
            return None

    def set_wishlist_debit_category(self, user_id: int, category: str | None) -> None:
        """Set wishlist debit category for user."""

        try:
            self.ensure_user_settings(user_id)
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.user_settings}
                SET wishlist_debit_category_id = ?
                WHERE user_id = ?
                """,
                (category, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "USER=%s ACTION=WISHLIST_DEBIT_CATEGORY_SET META=category_id=%s",
                user_id,
                category,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update wishlist debit category for user %s: %s",
                user_id,
                error,
            )

    def get_byt_wishlist_category_id(self, user_id: int) -> int | None:
        """Return BYT wishlist category id for user."""

        try:
            self.ensure_user_settings(user_id)
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT byt_wishlist_category_id FROM {TABLES.user_settings} WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            if row and row["byt_wishlist_category_id"] is not None:
                try:
                    return int(row["byt_wishlist_category_id"])
                except (TypeError, ValueError):
                    return None
            return None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT wishlist category for user %s: %s",
                user_id,
                error,
            )
            return None

    def set_byt_wishlist_category_id(self, user_id: int, category_id: int | None) -> None:
        """Set BYT wishlist category id for user."""

        try:
            self.ensure_user_settings(user_id)
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.user_settings}
                SET byt_wishlist_category_id = ?
                WHERE user_id = ?
                """,
                (category_id, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update BYT wishlist category for user %s: %s",
                user_id,
                error,
            )

    def get_wishlist_category_by_title(
        self, user_id: int, title: str
    ) -> Optional[Dict[str, Any]]:
        """Return wishlist category by title (case-insensitive)."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM {TABLES.wishlist_categories}
                WHERE user_id = ?
                  AND is_active = 1
                  AND lower(trim(title)) = lower(trim(?))
                LIMIT 1
                """,
                (user_id, title),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch wishlist category by title for user %s: %s",
                user_id,
                error,
            )
            return None

    def resolve_household_debit_category(self, user_id: int) -> tuple[str, str]:
        """Resolve household debit category code and title with fallback."""

        categories = self.list_active_income_categories(user_id)
        category_map = {str(item.get("code", "")): str(item.get("title", "")) for item in categories}
        selected = self.get_household_debit_category(user_id)
        if selected and selected in category_map:
            return selected, category_map[selected]

        fallback_code = None
        if "Ð±Ñ‹Ñ‚" in category_map:
            fallback_code = "Ð±Ñ‹Ñ‚"
        elif categories:
            fallback_code = str(categories[0].get("code", "Ð±Ñ‹Ñ‚"))
        else:
            fallback_code = "Ð±Ñ‹Ñ‚"

        if selected and selected not in category_map:
            LOGGER.warning(
                "Household debit category invalid for user %s: %s, fallback to %s",
                user_id,
                selected,
                fallback_code,
            )

        return fallback_code, category_map.get(fallback_code, fallback_code)

    def update_purchased_keep_days(self, user_id: int, days: int) -> None:
        """Update purchased_keep_days value."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.user_settings} SET purchased_keep_days = ? WHERE user_id = ?",
                (days, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased_keep_days for user %s: %s", user_id, error
            )

    def update_wishlist_category_purchased_mode(
        self, user_id: int, category_id: int, mode: str
    ) -> None:
        """Update purchased display mode for wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.wishlist_categories} SET purchased_mode = ? WHERE user_id = ? AND id = ?",
                (mode, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased mode for category %s user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_wishlist_category_purchased_days(
        self, user_id: int, category_id: int, days: int
    ) -> None:
        """Update purchased days retention for wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.wishlist_categories} SET purchased_days = ? WHERE user_id = ? AND id = ?",
                (days, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased days for category %s user %s: %s",
                category_id,
                user_id,
                error,
            )

    def set_byt_reminders_enabled(self, user_id: int, enabled: bool) -> None:
        """Toggle BYT reminders enabled flag."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.user_settings} SET byt_reminders_enabled = ? WHERE user_id = ?",
                (1 if enabled else 0, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_reminders_enabled for user %s: %s", user_id, error
            )

    def set_byt_defer_enabled(self, user_id: int, enabled: bool) -> None:
        """Toggle BYT defer feature flag."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.user_settings} SET byt_defer_enabled = ? WHERE user_id = ?",
                (1 if enabled else 0, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_defer_enabled for user %s: %s", user_id, error
            )

    def set_byt_defer_max_days(self, user_id: int, max_days: int) -> None:
        """Update max defer days setting."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.user_settings} SET byt_defer_max_days = ? WHERE user_id = ?",
                (max_days, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_defer_max_days for user %s: %s", user_id, error
            )

    def update_byt_defer_max_days(self, user_id: int, days: int) -> None:
        """Alias for set_byt_defer_max_days for compatibility."""

        self.set_byt_defer_max_days(user_id, days)

    def get_wishlist_category_by_id(
        self, user_id: int, category_id: int
    ) -> Optional[Dict[str, Any]]:
        """Return wishlist category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM {TABLES.wishlist_categories}
                WHERE user_id = ? AND id = ?
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch wishlist category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def deactivate_wishlist_category(self, user_id: int, category_id: int) -> None:
        """Soft delete wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.wishlist_categories}
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate wishlist category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    @staticmethod
    def _column_exists(cursor: sqlite3.Cursor, table: str, column: str) -> bool:
        """Return True if column exists in table."""

        cursor.execute(f'PRAGMA table_info("{table}")')
        return any(row[1] == column for row in cursor.fetchall())

    def _add_column_if_missing(
        self, cursor: sqlite3.Cursor, table: str, column: str, definition: str
    ) -> None:
        """Add column to table if it does not already exist."""

        if not self._column_exists(cursor, table, column):
            cursor.execute(f'ALTER TABLE "{table}" ADD COLUMN {column} {definition}')

    def get_user_savings(self, user_id: int) -> Dict[str, Dict[str, Any]]:
        """Get all savings for a user.

        Args:
            user_id (int): Telegram user id.

        Returns:
            dict: Mapping category to saving details.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT category, current, goal, purpose FROM {TABLES.savings} WHERE user_id = ?",
                (user_id,),
            )
            rows = cursor.fetchall()
            savings = {}
            for row in rows:
                current = self._to_float(row["current"])
                goal = self._to_float(row["goal"])
                savings[row["category"]] = {
                    "current": current,
                    "goal": goal,
                    "purpose": row["purpose"],
                }
            LOGGER.info("Fetched savings for user %s", user_id)
            return savings
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch savings for user %s: %s", user_id, error)
            return {}

    def get_user_savings_map(self, user_id: int) -> Dict[str, float]:
        """Return a simple mapping of category to current savings.

        Args:
            user_id (int): Telegram user id.

        Returns:
            dict[str, float]: Mapping of category names to current amount.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT category, current FROM {TABLES.savings} WHERE user_id = ?",
                (user_id,),
            )
            rows = cursor.fetchall()
            mapping = {}
            for row in rows:
                mapping[row["category"]] = self._to_float(row["current"])
            LOGGER.info("Fetched savings map for user %s", user_id)
            return mapping
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch savings map for user %s: %s", user_id, error)
            return {}

    def update_saving(self, user_id: int, category: str, amount_delta: float) -> None:
        """Update saving for category by amount delta.

        Args:
            user_id (int): Telegram user id.
            category (str): Category name.
            amount_delta (float): Amount to add or subtract.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT id, current FROM {TABLES.savings} WHERE user_id = ? AND category = ?",
                (user_id, category),
            )
            row = cursor.fetchone()
            delta = self._to_float(amount_delta)
            if row:
                current = self._to_float(row["current"])
                new_value = current + delta
                cursor.execute(
                    f"UPDATE {TABLES.savings} SET current = ? WHERE id = ?",
                    (new_value, row["id"]),
                )
            else:
                cursor.execute(
                    f"INSERT INTO {TABLES.savings} (user_id, category, current, goal, purpose) VALUES (?, ?, ?, 0, '')",
                    (user_id, category, delta),
                )
            self.connection.commit()
            LOGGER.info(
                "Updated saving for user %s category %s by %s",
                user_id,
                category,
                amount_delta,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update saving for user %s category %s: %s",
                user_id,
                category,
                error,
            )

    def _update_saving_in_transaction(
        self,
        cursor: sqlite3.Cursor,
        user_id: int,
        category: str,
