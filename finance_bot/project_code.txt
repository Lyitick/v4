===== Bot/__init__.py =====
"""Package initializer for finance bot modules."""

===== Bot/config/__init__.py =====


===== Bot/config/logging_config.py =====
"""Logging configuration for the bot."""
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path

LOG_FORMAT = "[%(asctime)s] [%(levelname)s] %(message)s"
LOG_LEVEL = logging.INFO
LOG_FILE = Path(__file__).resolve().parents[2] / "finance_bot.log"


def setup_logging() -> None:
    """Configure logging for application."""

    LOG_FILE.touch(exist_ok=True)
    formatter = logging.Formatter(LOG_FORMAT)

    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5_000_000, backupCount=3, encoding="utf-8")
    file_handler.setLevel(LOG_LEVEL)
    file_handler.setFormatter(formatter)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(LOG_LEVEL)
    console_handler.setFormatter(formatter)

    root_logger = logging.getLogger()
    root_logger.setLevel(LOG_LEVEL)
    root_logger.handlers.clear()
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)

===== Bot/config/settings.py =====
"""Bot settings module."""
from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from zoneinfo import ZoneInfo


def _load_env_file(env_path: Path) -> dict[str, str]:
    if not env_path.exists():
        return {}

    data: dict[str, str] = {}
    for line in env_path.read_text(encoding="utf-8").splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#") or "=" not in stripped:
            continue
        key, value = stripped.split("=", 1)
        data[key.strip()] = value.strip().strip("\"'")
    return data


def _resolve_bot_token() -> tuple[str, str]:
    if "BOT_TOKEN" in os.environ:
        return os.environ.get("BOT_TOKEN", ""), "env"

    env_path = Path(__file__).resolve().parents[2] / ".env"
    env_values = _load_env_file(env_path)
    if "BOT_TOKEN" in env_values:
        os.environ.setdefault("BOT_TOKEN", env_values["BOT_TOKEN"])
        return env_values["BOT_TOKEN"], ".env"

    return "", "missing"


BOT_TOKEN, BOT_TOKEN_SOURCE = _resolve_bot_token()
ADMIN_ID: int = 838347504
TIMEZONE = ZoneInfo("Europe/Moscow")


@dataclass
class Settings:
    """Container for application settings."""

    bot_token: str = BOT_TOKEN
    bot_token_source: str = BOT_TOKEN_SOURCE
    admin_id: int = ADMIN_ID
    timezone: ZoneInfo = TIMEZONE


def get_settings() -> Settings:
    """Get current settings.

    Returns:
        Settings: Dataclass with bot settings.
    """

    return Settings()

===== Bot/database/__init__.py =====


===== Bot/database/crud.py =====
"""Database CRUD operations for finance bot."""
from __future__ import annotations

import logging
import sqlite3
import time
from datetime import datetime, timedelta
from pathlib import Path
from threading import Lock
from typing import Any, Dict, List, Optional

from Bot.config.settings import get_settings
from Bot.utils.datetime_utils import add_one_month, now_tz


LOGGER = logging.getLogger(__name__)
DB_PATH = Path(__file__).resolve().parents[2] / "finance.db"


def _get_bot_user_id() -> int | None:
    try:
        token = get_settings().bot_token
        if not token:
            return None
        return int(str(token).split(":")[0])
    except (AttributeError, IndexError, TypeError, ValueError):
        return None


BOT_USER_ID = _get_bot_user_id()
DEFAULT_HOUSEHOLD_ITEMS = [
    {"code": "phone", "text": "Телефон 600р?", "amount": 600},
    {"code": "internet", "text": "Интернет 700р?", "amount": 700},
    {"code": "vpn", "text": "VPN 100р?", "amount": 100},
    {"code": "gpt", "text": "GPT 2000р?", "amount": 2000},
    {"code": "yandex_sub", "text": "Яндекс подписка 400р?", "amount": 400},
    {"code": "rent", "text": "Квартплата 4000р? Папе скинул?", "amount": 4000},
    {"code": "training_495", "text": "Оплатил тренировки 495 - 5000р?", "amount": 5000},
]

DEFAULT_INCOME_CATEGORIES = [
    {"code": "долги", "title": "Убил боль?", "percent": 30, "position": 1},
    {
        "code": "быт",
        "title": "бытовые расходы на Тиньк",
        "percent": 20,
        "position": 2,
    },
    {
        "code": "инвестиции",
        "title": "Инвестиции на Альфу",
        "percent": 20,
        "position": 3,
    },
    {
        "code": "сбережения",
        "title": "Сбережения на Сбер",
        "percent": 20,
        "position": 4,
    },
    {
        "code": "спонтанные траты",
        "title": "спонтанные траты на Яндекс",
        "percent": 10,
        "position": 5,
    },
]

DEFAULT_EXPENSE_CATEGORIES = [
    {"code": "базовые", "title": "Базовые расходы", "percent": 40, "position": 1},
    {"code": "жилье", "title": "Жилье и ЖКУ", "percent": 20, "position": 2},
    {"code": "транспорт", "title": "Транспорт", "percent": 15, "position": 3},
    {"code": "еда", "title": "Еда", "percent": 15, "position": 4},
    {"code": "другое", "title": "Другое", "percent": 10, "position": 5},
]

DEFAULT_WISHLIST_CATEGORIES = [
    {"title": "инвестиции в работу", "position": 1},
    {"title": "вклад в себя", "position": 2},
    {"title": "кайфы", "position": 3},
    {"title": "БЫТ", "position": 4},
]


class FinanceDatabase:
    """Singleton class handling all database interactions."""

    _instance: Optional["FinanceDatabase"] = None
    _lock: Lock = Lock()

    def __new__(cls) -> "FinanceDatabase":
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize_connection()
        return cls._instance

    def _initialize_connection(self) -> None:
        """Initialize SQLite connection and create tables."""

        DB_PATH.touch(exist_ok=True)
        self.connection = sqlite3.connect(DB_PATH, check_same_thread=False)
        self.connection.row_factory = sqlite3.Row
        self.init_db()
        LOGGER.info("Database initialized at %s", DB_PATH)

    @staticmethod
    def _to_float(value: Any) -> float:
        """Safely convert a value to float, returning 0.0 on failure."""

        try:
            return float(value) if value is not None else 0.0
        except (TypeError, ValueError):
            return 0.0

    def init_db(self) -> None:
        """Create required tables if they do not exist."""

        cursor = self.connection.cursor()
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS savings (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                category TEXT,
                current REAL,
                goal REAL,
                purpose TEXT
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS wishes (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                name TEXT,
                price REAL,
                url TEXT,
                category TEXT,
                is_purchased INTEGER,
                saved_amount REAL DEFAULT 0,
                purchased_at TEXT,
                deferred_until TEXT
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS purchases (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                wish_name TEXT,
                price REAL,
                category TEXT,
                purchased_at TEXT
            )
            """
        )
        self._add_column_if_missing(cursor, "wishes", "deferred_until", "TEXT")
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS household_payments (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                month TEXT,
                question_code TEXT,
                is_paid INTEGER DEFAULT 0,
                UNIQUE(user_id, month, question_code)
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS household_payment_items (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                code TEXT,
                text TEXT,
                amount INTEGER,
                position INTEGER DEFAULT 0,
                is_active INTEGER DEFAULT 1,
                paid_month TEXT,
                is_paid INTEGER DEFAULT 0,
                created_at TEXT,
                UNIQUE(user_id, code)
            )
            """
        )
        self._add_column_if_missing(
            cursor, "household_payment_items", "paid_month", "TEXT"
        )
        self._add_column_if_missing(
            cursor, "household_payment_items", "is_paid", "INTEGER DEFAULT 0"
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS income_categories (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                code TEXT NOT NULL,
                title TEXT NOT NULL,
                percent INTEGER NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS expense_categories (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                code TEXT NOT NULL,
                title TEXT NOT NULL,
                percent INTEGER NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, code)
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS wishlist_categories (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                title TEXT NOT NULL,
                position INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                purchased_mode TEXT DEFAULT 'days',
                purchased_days INTEGER DEFAULT 30
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS user_settings (
                user_id INTEGER PRIMARY KEY,
                purchased_keep_days INTEGER NOT NULL DEFAULT 30,
                byt_reminders_enabled INTEGER NOT NULL DEFAULT 1,
                byt_defer_enabled INTEGER NOT NULL DEFAULT 1,
                byt_defer_max_days INTEGER NOT NULL DEFAULT 365
            )
            """
        )
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS byt_timer_times (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                hour INTEGER NOT NULL,
                minute INTEGER NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1
            )
            """
        )
        self._add_column_if_missing(cursor, "wishes", "purchased_at", "TEXT")
        self._add_column_if_missing(cursor, "wishlist_categories", "purchased_mode", "TEXT DEFAULT 'days'")
        self._add_column_if_missing(cursor, "wishlist_categories", "purchased_days", "INTEGER DEFAULT 30")
        self.connection.commit()

    def ensure_household_items_seeded(self, user_id: int) -> None:
        """No-op: household items are managed by user and stored in DB."""
        LOGGER.debug("Household item seeding disabled (user_id=%s)", user_id)

    def list_active_household_items(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active household payment items for user ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT code, text, amount, position
                FROM household_payment_items
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list active household items for user %s: %s",
                user_id,
                error,
            )
            return []

    def get_household_item_by_code(
        self, user_id: int, code: str
    ) -> Optional[Dict[str, Any]]:
        """Return household payment item by code."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT code, text, amount, position
                FROM household_payment_items
                WHERE user_id = ? AND code = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, code),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch household item %s for user %s: %s",
                code,
                user_id,
                error,
            )
            return None

    def get_next_household_position(self, user_id: int) -> int:
        """Return next position value for household items."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT MAX(position) FROM household_payment_items WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            max_pos = row[0] if row and row[0] is not None else 0
            return int(max_pos) + 1
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get next household position for user %s: %s", user_id, error
            )
            return 1

    def add_household_payment_item(
        self, user_id: int, code: str, text: str, amount: int, position: int
    ) -> None:
        """Add new household payment item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT INTO household_payment_items (
                    user_id, code, text, amount, position, is_active, created_at
                )
                VALUES (?, ?, ?, ?, ?, 1, ?)
                """,
                (user_id, code, text, amount, position, now_tz().isoformat()),
            )
            self.connection.commit()
            LOGGER.info("Added household payment item %s for user %s", code, user_id)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to add household item %s for user %s: %s",
                code,
                user_id,
                error,
            )

    def deactivate_household_payment_item(self, user_id: int, code: str) -> None:
        """Deactivate household payment item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE household_payment_items
                SET is_active = 0
                WHERE user_id = ? AND code = ?
                """,
                (user_id, code),
            )
            self.connection.commit()
            LOGGER.info("Deactivated household payment item %s for user %s", code, user_id)
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate household item %s for user %s: %s",
                code,
                user_id,
                error,
            )

    def ensure_income_categories_seeded(self, user_id: int) -> None:
        """Seed default income categories if user has none."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM income_categories WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for item in DEFAULT_INCOME_CATEGORIES:
                cursor.execute(
                    """
                    INSERT INTO income_categories (
                        user_id, code, title, percent, position, is_active
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                    """,
                    (
                        user_id,
                        item["code"],
                        item["title"],
                        item["percent"],
                        item["position"],
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default income categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed income categories for user %s: %s", user_id, error)

    def list_active_income_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active income categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM income_categories
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list income categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def ensure_expense_categories_seeded(self, user_id: int) -> None:
        """Seed default expense categories if user has none."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM expense_categories WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for item in DEFAULT_EXPENSE_CATEGORIES:
                cursor.execute(
                    """
                    INSERT INTO expense_categories (
                        user_id, code, title, percent, position, is_active
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                    """,
                    (
                        user_id,
                        item["code"],
                        item["title"],
                        item["percent"],
                        item["position"],
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default expense categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed expense categories for user %s: %s", user_id, error)

    def ensure_wishlist_categories_seeded(self, user_id: int) -> None:
        """Seed default wishlist categories if user has none."""

        try:
            cursor = self.connection.cursor()
            self.ensure_user_settings(user_id)
            cursor.execute(
                "SELECT 1 FROM wishlist_categories WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                cursor.execute(
                    "SELECT purchased_keep_days FROM user_settings WHERE user_id = ?",
                    (user_id,),
                )
                row = cursor.fetchone()
                default_days = int(row[0]) if row and row[0] is not None else 30
                cursor.execute(
                    "UPDATE wishlist_categories SET purchased_mode = COALESCE(purchased_mode, 'days') WHERE user_id = ?",
                    (user_id,),
                )
                cursor.execute(
                    "UPDATE wishlist_categories SET purchased_days = COALESCE(purchased_days, ?) WHERE user_id = ?",
                    (default_days, user_id),
                )
                self.connection.commit()
                return

            self.ensure_user_settings(user_id)
            cursor.execute(
                "SELECT purchased_keep_days FROM user_settings WHERE user_id = ?",
                (user_id,),
            )
            row = cursor.fetchone()
            default_days = int(row[0]) if row and row[0] is not None else 30
            for item in DEFAULT_WISHLIST_CATEGORIES:
                cursor.execute(
                    """
                    INSERT INTO wishlist_categories (
                        user_id, title, position, is_active, purchased_mode, purchased_days
                    )
                    VALUES (?, ?, ?, 1, 'days', ?)
                    """,
                    (
                        user_id,
                        item["title"],
                        item["position"],
                        default_days,
                    ),
                )
            self.connection.commit()
            LOGGER.info("Seeded default wishlist categories for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed wishlist categories for user %s: %s", user_id, error)

    def ensure_user_settings(self, user_id: int) -> None:
        """Ensure user_settings row exists with defaults."""

        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT 1 FROM user_settings WHERE user_id = ?", (user_id,))
            if cursor.fetchone():
                return

            cursor.execute(
                """
                INSERT OR IGNORE INTO user_settings (
                    user_id, purchased_keep_days, byt_reminders_enabled, byt_defer_enabled, byt_defer_max_days
                )
                VALUES (?, 30, 1, 1, 365)
                """,
                (user_id,),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to ensure user_settings for user %s: %s", user_id, error)

    def ensure_byt_timer_defaults(self, user_id: int) -> None:
        """Seed default BYT timer times (12:00, 18:00)."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM byt_timer_times WHERE user_id = ? AND is_active = 1 LIMIT 1",
                (user_id,),
            )
            if cursor.fetchone():
                return

            for hour, minute in [(12, 0), (18, 0)]:
                cursor.execute(
                    """
                    INSERT INTO byt_timer_times (user_id, hour, minute, is_active)
                    VALUES (?, ?, ?, 1)
                    """,
                    (user_id, hour, minute),
                )
            self.connection.commit()
            LOGGER.info("Seeded default BYT timer times for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to seed BYT timer times for user %s: %s", user_id, error)

    def list_active_expense_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active expense categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM expense_categories
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list expense categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def list_active_wishlist_categories(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active wishlist categories ordered by position."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM wishlist_categories
                WHERE user_id = ? AND is_active = 1
                ORDER BY position, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to list wishlist categories for user %s: %s",
                user_id,
                error,
            )
            return []

    def create_income_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new income category with zero percent."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(MAX(position), 0) FROM income_categories WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            code = f"custom_{time.time_ns()}"
            cursor.execute(
                """
                INSERT INTO income_categories (user_id, code, title, percent, position)
                VALUES (?, ?, ?, 0, ?)
                """,
                (user_id, code, title, current_position + 1),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create income category for user %s: %s", user_id, error)
            return None

    def create_expense_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new expense category with zero percent."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(MAX(position), 0) FROM expense_categories WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            code = f"custom_{time.time_ns()}"
            cursor.execute(
                """
                INSERT INTO expense_categories (user_id, code, title, percent, position)
                VALUES (?, ?, ?, 0, ?)
                """,
                (user_id, code, title, current_position + 1),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create expense category for user %s: %s", user_id, error)
            return None

    def create_wishlist_category(self, user_id: int, title: str) -> Optional[int]:
        """Create a new wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(MAX(position), 0) FROM wishlist_categories WHERE user_id = ?",
                (user_id,),
            )
            current_position = cursor.fetchone()[0] or 0
            self.ensure_user_settings(user_id)
            cursor.execute(
                "SELECT purchased_keep_days FROM user_settings WHERE user_id = ?", (user_id,)
            )
            row = cursor.fetchone()
            default_days = int(row[0]) if row and row[0] is not None else 30
            cursor.execute(
                """
                INSERT INTO wishlist_categories (user_id, title, position, purchased_mode, purchased_days)
                VALUES (?, ?, ?, 'days', ?)
                """,
                (user_id, title, current_position + 1, default_days),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to create wishlist category for user %s: %s", user_id, error)
            return None

    def deactivate_income_category(self, user_id: int, category_id: int) -> None:
        """Deactivate income category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE income_categories
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate income category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    def deactivate_expense_category(self, user_id: int, category_id: int) -> None:
        """Deactivate expense category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE expense_categories
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate expense category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_income_category_percent(self, user_id: int, category_id: int, percent: int) -> None:
        """Update percent for income category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE income_categories
                SET percent = ?
                WHERE user_id = ? AND id = ?
                """,
                (percent, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update percent for income category %s of user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_expense_category_percent(
        self, user_id: int, category_id: int, percent: int
    ) -> None:
        """Update percent for expense category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE expense_categories
                SET percent = ?
                WHERE user_id = ? AND id = ?
                """,
                (percent, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update percent for expense category %s of user %s: %s",
                category_id,
                user_id,
                error,
            )

    def sum_income_category_percents(self, user_id: int) -> int:
        """Return sum of percents for active income categories."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(SUM(percent), 0) FROM income_categories WHERE user_id = ? AND is_active = 1",
                (user_id,),
            )
            result = cursor.fetchone()
            return int(result[0]) if result and result[0] is not None else 0
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to calculate percent sum for user %s: %s",
                user_id,
                error,
            )
            return 0

    def sum_expense_category_percents(self, user_id: int) -> int:
        """Return sum of percents for active expense categories."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT COALESCE(SUM(percent), 0) FROM expense_categories WHERE user_id = ? AND is_active = 1",
                (user_id,),
            )
            result = cursor.fetchone()
            return int(result[0]) if result and result[0] is not None else 0
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to calculate expense percent sum for user %s: %s",
                user_id,
                error,
            )
            return 0

    def get_income_category_by_id(self, user_id: int, category_id: int) -> Optional[Dict[str, Any]]:
        """Return income category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM income_categories
                WHERE user_id = ? AND id = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch income category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def get_expense_category_by_id(
        self, user_id: int, category_id: int
    ) -> Optional[Dict[str, Any]]:
        """Return expense category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, code, title, percent, position
                FROM expense_categories
                WHERE user_id = ? AND id = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch expense category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def get_user_settings(self, user_id: int) -> Dict[str, Any]:
        """Return user settings ensuring defaults exist."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT user_id, purchased_keep_days, byt_reminders_enabled, byt_defer_enabled, byt_defer_max_days
                FROM user_settings
                WHERE user_id = ?
                LIMIT 1
                """,
                (user_id,),
            )
            row = cursor.fetchone()
            return dict(row) if row else {}
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch user settings for %s: %s", user_id, error)
            return {}

    def update_purchased_keep_days(self, user_id: int, days: int) -> None:
        """Update purchased_keep_days value."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET purchased_keep_days = ? WHERE user_id = ?",
                (days, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased_keep_days for user %s: %s", user_id, error
            )

    def update_wishlist_category_purchased_mode(
        self, user_id: int, category_id: int, mode: str
    ) -> None:
        """Update purchased display mode for wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE wishlist_categories SET purchased_mode = ? WHERE user_id = ? AND id = ?",
                (mode, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased mode for category %s user %s: %s",
                category_id,
                user_id,
                error,
            )

    def update_wishlist_category_purchased_days(
        self, user_id: int, category_id: int, days: int
    ) -> None:
        """Update purchased days retention for wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE wishlist_categories SET purchased_days = ? WHERE user_id = ? AND id = ?",
                (days, user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update purchased days for category %s user %s: %s",
                category_id,
                user_id,
                error,
            )

    def set_byt_reminders_enabled(self, user_id: int, enabled: bool) -> None:
        """Toggle BYT reminders enabled flag."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET byt_reminders_enabled = ? WHERE user_id = ?",
                (1 if enabled else 0, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_reminders_enabled for user %s: %s", user_id, error
            )

    def set_byt_defer_enabled(self, user_id: int, enabled: bool) -> None:
        """Toggle BYT defer feature flag."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET byt_defer_enabled = ? WHERE user_id = ?",
                (1 if enabled else 0, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_defer_enabled for user %s: %s", user_id, error
            )

    def set_byt_defer_max_days(self, user_id: int, max_days: int) -> None:
        """Update max defer days setting."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE user_settings SET byt_defer_max_days = ? WHERE user_id = ?",
                (max_days, user_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update byt_defer_max_days for user %s: %s", user_id, error
            )

    def update_byt_defer_max_days(self, user_id: int, days: int) -> None:
        """Alias for set_byt_defer_max_days for compatibility."""

        self.set_byt_defer_max_days(user_id, days)

    def get_wishlist_category_by_id(
        self, user_id: int, category_id: int
    ) -> Optional[Dict[str, Any]]:
        """Return wishlist category by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, title, position, is_active, purchased_mode, purchased_days
                FROM wishlist_categories
                WHERE user_id = ? AND id = ?
                LIMIT 1
                """,
                (user_id, category_id),
            )
            row = cursor.fetchone()
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch wishlist category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )
            return None

    def deactivate_wishlist_category(self, user_id: int, category_id: int) -> None:
        """Soft delete wishlist category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE wishlist_categories
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, category_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate wishlist category %s for user %s: %s",
                category_id,
                user_id,
                error,
            )

    @staticmethod
    def _column_exists(cursor: sqlite3.Cursor, table: str, column: str) -> bool:
        """Return True if column exists in table."""

        cursor.execute(f"PRAGMA table_info({table})")
        return any(row[1] == column for row in cursor.fetchall())

    def _add_column_if_missing(
        self, cursor: sqlite3.Cursor, table: str, column: str, definition: str
    ) -> None:
        """Add column to table if it does not already exist."""

        if not self._column_exists(cursor, table, column):
            cursor.execute(f"ALTER TABLE {table} ADD COLUMN {column} {definition}")

    def get_user_savings(self, user_id: int) -> Dict[str, Dict[str, Any]]:
        """Get all savings for a user.

        Args:
            user_id (int): Telegram user id.

        Returns:
            dict: Mapping category to saving details.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT category, current, goal, purpose FROM savings WHERE user_id = ?",
                (user_id,),
            )
            rows = cursor.fetchall()
            savings = {}
            for row in rows:
                current = self._to_float(row["current"])
                goal = self._to_float(row["goal"])
                savings[row["category"]] = {
                    "current": current,
                    "goal": goal,
                    "purpose": row["purpose"],
                }
            LOGGER.info("Fetched savings for user %s", user_id)
            return savings
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch savings for user %s: %s", user_id, error)
            return {}

    def get_user_savings_map(self, user_id: int) -> Dict[str, float]:
        """Return a simple mapping of category to current savings.

        Args:
            user_id (int): Telegram user id.

        Returns:
            dict[str, float]: Mapping of category names to current amount.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT category, current FROM savings WHERE user_id = ?",
                (user_id,),
            )
            rows = cursor.fetchall()
            mapping = {}
            for row in rows:
                mapping[row["category"]] = self._to_float(row["current"])
            LOGGER.info("Fetched savings map for user %s", user_id)
            return mapping
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch savings map for user %s: %s", user_id, error)
            return {}

    def update_saving(self, user_id: int, category: str, amount_delta: float) -> None:
        """Update saving for category by amount delta.

        Args:
            user_id (int): Telegram user id.
            category (str): Category name.
            amount_delta (float): Amount to add or subtract.
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id, current FROM savings WHERE user_id = ? AND category = ?",
                (user_id, category),
            )
            row = cursor.fetchone()
            delta = self._to_float(amount_delta)
            if row:
                current = self._to_float(row["current"])
                new_value = current + delta
                cursor.execute(
                    "UPDATE savings SET current = ? WHERE id = ?",
                    (new_value, row["id"]),
                )
            else:
                cursor.execute(
                    "INSERT INTO savings (user_id, category, current, goal, purpose) VALUES (?, ?, ?, 0, '')",
                    (user_id, category, delta),
                )
            self.connection.commit()
            LOGGER.info(
                "Updated saving for user %s category %s by %s",
                user_id,
                category,
                amount_delta,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to update saving for user %s category %s: %s",
                user_id,
                category,
                error,
            )

    def _update_saving_in_transaction(
        self,
        cursor: sqlite3.Cursor,
        user_id: int,
        category: str,
        amount_delta: float,
    ) -> None:
        cursor.execute(
            "SELECT id, current FROM savings WHERE user_id = ? AND category = ?",
            (user_id, category),
        )
        row = cursor.fetchone()
        delta = self._to_float(amount_delta)
        if row:
            current = self._to_float(row["current"])
            new_value = current + delta
            cursor.execute(
                "UPDATE savings SET current = ? WHERE id = ?",
                (new_value, row["id"]),
            )
        else:
            cursor.execute(
                "INSERT INTO savings (user_id, category, current, goal, purpose) VALUES (?, ?, ?, 0, '')",
                (user_id, category, delta),
            )

    def decrease_savings(self, user_id: int, category: str, amount: float) -> None:
        """Decrease savings for category by amount."""

        self.update_saving(user_id, category, -abs(amount))

    def set_goal(self, user_id: int, category: str, goal: float, purpose: str) -> None:
        """Set goal and purpose for saving category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id FROM savings WHERE user_id = ? AND category = ?",
                (user_id, category),
            )
            row = cursor.fetchone()
            if row:
                cursor.execute(
                    "UPDATE savings SET goal = ?, purpose = ? WHERE id = ?",
                    (goal, purpose, row["id"]),
                )
            else:
                cursor.execute(
                    "INSERT INTO savings (user_id, category, current, goal, purpose) VALUES (?, ?, 0, ?, ?)",
                    (user_id, category, goal, goal, purpose),
                )
            self.connection.commit()
            LOGGER.info("Set goal for user %s category %s", user_id, category)
        except sqlite3.Error as error:
            LOGGER.error("Failed to set goal for user %s category %s: %s", user_id, category, error)

    def reset_goals(self, user_id: int) -> None:
        """Reset goals for user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute("UPDATE savings SET goal = 0, purpose = '' WHERE user_id = ?", (user_id,))
            self.connection.commit()
            LOGGER.info("Reset goals for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to reset goals for user %s: %s", user_id, error)

    def add_wish(self, user_id: int, name: str, price: float, url: Optional[str], category: str) -> int:
        """Add a wish to the wishlist."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "INSERT INTO wishes (user_id, name, price, url, category, is_purchased, saved_amount, purchased_at) VALUES (?, ?, ?, ?, ?, 0, 0, NULL)",
                (user_id, name, price, url, category),
            )
            self.connection.commit()
            wish_id = cursor.lastrowid
            LOGGER.info("Added wish %s for user %s", wish_id, user_id)
            return wish_id
        except sqlite3.Error as error:
            LOGGER.error("Failed to add wish for user %s: %s", user_id, error)
            return 0

    def get_wishes_by_user(self, user_id: int) -> List[Dict[str, Any]]:
        """Get all wishes for a user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE user_id = ?
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched wishes for user %s", user_id)
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch wishes for user %s: %s", user_id, error)
            return []

    def get_wish(self, wish_id: int) -> Optional[Dict[str, Any]]:
        """Get wish by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE id = ?
                """,
                (wish_id,),
            )
            row = cursor.fetchone()
            LOGGER.info("Fetched wish %s", wish_id)
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch wish %s: %s", wish_id, error)
            return None

    def get_active_byt_wishes(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active BYT wishes for user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE user_id = ? AND category IN ('byt', 'БЫТ') AND (is_purchased = 0 OR is_purchased IS NULL)
                ORDER BY id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched active BYT wishes for user %s", user_id)
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch BYT wishes for user %s: %s", user_id, error)
            return []

    def list_active_byt_items_for_reminder(
        self, user_id: int, now_dt: datetime
    ) -> List[Dict[str, Any]]:
        """Return BYT wishlist items available for reminders at given time."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM wishes
                WHERE user_id = ?
                  AND category IN ('byt', 'БЫТ')
                  AND (is_purchased = 0 OR is_purchased IS NULL)
                  AND (deferred_until IS NULL OR deferred_until <= ?)
                ORDER BY id
                """,
                (user_id, now_dt.isoformat()),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT reminder wishes for user %s: %s", user_id, error
            )
            return []

    def set_wishlist_item_deferred_until(
        self, user_id: int, item_id: int, deferred_until_iso: Optional[str]
    ) -> None:
        """Set deferred_until for wishlist item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE wishes
                SET deferred_until = ?
                WHERE id = ? AND user_id = ?
                """,
                (deferred_until_iso, item_id, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Set deferred_until for wish %s user %s to %s",
                item_id,
                user_id,
                deferred_until_iso,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to set deferred_until for wish %s user %s: %s",
                item_id,
                user_id,
                error,
            )

    def mark_wish_purchased(self, wish_id: int, purchased_at: Optional[datetime] = None) -> None:
        """Mark wish as purchased with timestamp."""

        try:
            cursor = self.connection.cursor()
            purchased_value = (purchased_at or now_tz()).isoformat()
            cursor.execute(
                """
                UPDATE wishes
                SET is_purchased = 1, purchased_at = ?, deferred_until = NULL
                WHERE id = ?
                """,
                (purchased_value, wish_id),
            )
            self.connection.commit()
            LOGGER.info("Marked wish %s as purchased", wish_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to mark wish %s as purchased: %s", wish_id, error)

    def add_purchase(
        self,
        user_id: int,
        wish_name: str,
        price: float,
        category: str,
        purchased_at: Optional[datetime] = None,
    ) -> None:
        """Add purchase record."""

        try:
            cursor = self.connection.cursor()
            purchased_value = (purchased_at or now_tz()).isoformat()
            cursor.execute(
                "INSERT INTO purchases (user_id, wish_name, price, category, purchased_at) VALUES (?, ?, ?, ?, ?)",
                (user_id, wish_name, price, category, purchased_value),
            )
            self.connection.commit()
            LOGGER.info("Added purchase for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to add purchase for user %s: %s", user_id, error)

    async def household_status_exists(self, user_id: int, month: str) -> bool:
        """Check if household payment statuses exist for month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT 1 FROM household_payments WHERE user_id = ? AND month = ? LIMIT 1",
                (user_id, month),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to check household status for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def init_household_questions_for_month(self, user_id: int, month: str) -> None:
        """Initialize household payment questions for month."""

        try:
            if BOT_USER_ID is not None and user_id == BOT_USER_ID:
                LOGGER.warning(
                    "Skipping household questions init for bot user %s", user_id
                )
                return
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT OR IGNORE INTO household_payments (user_id, month, question_code, is_paid)
                SELECT ?, ?, code, 0
                FROM household_payment_items
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id, month, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Initialized household questions for user %s month %s", user_id, month
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to init household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )

    async def mark_household_question_paid(
        self, user_id: int, month: str, question_code: str
    ) -> None:
        """Mark household question as paid."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT INTO household_payments (user_id, month, question_code, is_paid)
                VALUES (?, ?, ?, 1)
                ON CONFLICT(user_id, month, question_code)
                DO UPDATE SET is_paid = excluded.is_paid
                """,
                (user_id, month, question_code),
            )
            self.connection.commit()
            LOGGER.info(
                "Marked household question %s as paid for user %s month %s",
                question_code,
                user_id,
                month,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to mark household question %s paid for user %s month %s: %s",
                question_code,
                user_id,
                month,
                error,
            )

    async def mark_household_question_unpaid(
        self, user_id: int, month: str, question_code: str
    ) -> None:
        """Mark household question as unpaid."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                INSERT INTO household_payments (user_id, month, question_code, is_paid)
                VALUES (?, ?, ?, 0)
                ON CONFLICT(user_id, month, question_code)
                DO UPDATE SET is_paid = excluded.is_paid
                """,
                (user_id, month, question_code),
            )
            self.connection.commit()
            LOGGER.info(
                "Marked household question %s as unpaid for user %s month %s",
                question_code,
                user_id,
                month,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to mark household question %s unpaid for user %s month %s: %s",
                question_code,
                user_id,
                month,
                error,
            )

    def apply_household_payment_answer(
        self,
        user_id: int,
        month: str,
        question_code: str,
        amount: float | None,
        answer: str,
    ) -> bool:
        """Apply household answer and savings update atomically.

        Returns True if state changed, False if it was already applied.
        """

        try:
            cursor = self.connection.cursor()
            self.connection.execute("BEGIN")
            cursor.execute(
                """
                SELECT is_paid
                FROM household_payments
                WHERE user_id = ? AND month = ? AND question_code = ?
                """,
                (user_id, month, question_code),
            )
            row = cursor.fetchone()
            if row is None:
                cursor.execute(
                    """
                    INSERT INTO household_payments (user_id, month, question_code, is_paid)
                    VALUES (?, ?, ?, 0)
                    """,
                    (user_id, month, question_code),
                )
                current_paid = 0
            else:
                current_paid = int(row["is_paid"])

            target_paid = 1 if answer == "yes" else 0
            if current_paid == target_paid:
                self.connection.commit()
                return False

            cursor.execute(
                """
                UPDATE household_payments
                SET is_paid = ?
                WHERE user_id = ? AND month = ? AND question_code = ?
                """,
                (target_paid, user_id, month, question_code),
            )
            if amount is not None:
                delta = -abs(amount) if answer == "yes" else abs(amount)
                self._update_saving_in_transaction(cursor, user_id, "быт", delta)
            self.connection.commit()
            return True
        except sqlite3.Error as error:
            self.connection.rollback()
            LOGGER.error(
                "Failed to apply household answer for user %s month %s code %s: %s",
                user_id,
                month,
                question_code,
                error,
            )
            return False

    async def get_unpaid_household_questions(self, user_id: int, month: str) -> List[str]:
        """Get unpaid household question codes for user and month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT items.code
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                ORDER BY items.position, items.id
                """,
                (month, user_id),
            )
            rows = cursor.fetchall()
            return [row["code"] for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get unpaid household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return []

    async def get_household_payment_status_map(
        self, user_id: int, month: str
    ) -> Dict[str, int]:
        """Return mapping: question_code -> is_paid (0/1) for the given month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT items.code, COALESCE(payments.is_paid, 0) AS is_paid
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ? AND items.is_active = 1
                """,
                (month, user_id),
            )
            rows = cursor.fetchall()
            return {row["code"]: int(row["is_paid"]) for row in rows}
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get household payment status for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return {}

    async def has_unpaid_household_questions(self, user_id: int, month: str) -> bool:
        """Return True if unpaid household questions exist for month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT 1
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                LIMIT 1
                """,
                (month, user_id),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to check unpaid household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def should_show_household_payments_button(
        self, user_id: int, month: str
    ) -> bool:
        """Return True if any active household payment is unpaid for the month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT 1
                FROM household_payment_items AS items
                LEFT JOIN household_payments AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                LIMIT 1
                """,
                (month, user_id),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to decide household payments button for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def reset_household_questions_for_month(self, user_id: int, month: str) -> None:
        """Reset household payment progress for a specific month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE household_payments
                SET is_paid = 0
                WHERE user_id = ? AND month = ?
                """,
                (user_id, month),
            )
            cursor.execute(
                """
                INSERT OR IGNORE INTO household_payments (user_id, month, question_code, is_paid)
                SELECT ?, ?, code, 0
                FROM household_payment_items
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id, month, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Reset household questions for user %s month %s", user_id, month
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to reset household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )

    def get_purchases_by_user(self, user_id: int) -> List[Dict[str, Any]]:
        """Get purchases for user honoring retention settings."""

        self.ensure_user_settings(user_id)
        self.ensure_wishlist_categories_seeded(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id, wish_name, price, category, purchased_at FROM purchases WHERE user_id = ? ORDER BY purchased_at DESC",
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched purchases for user %s", user_id)
            purchases = [dict(row) for row in rows]
            filtered: list[Dict[str, Any]] = []
            current_time = now_tz()
            settings_row = self.get_user_settings(user_id)
            default_days = int(settings_row.get("purchased_keep_days", 30) or 30)
            categories = self.list_active_wishlist_categories(user_id)
            category_map = {
                cat.get("title", ""): {
                    "mode": (cat.get("purchased_mode") or "days"),
                    "days": int(cat.get("purchased_days") or default_days),
                }
                for cat in categories
            }
            for purchase in purchases:
                cat_settings = category_map.get(
                    str(purchase.get("category", "")),
                    {"mode": "days", "days": default_days},
                )
                if cat_settings.get("mode") == "always":
                    filtered.append(purchase)
                    continue
                keep_delta = timedelta(days=int(cat_settings.get("days", default_days)))
                timestamp = purchase.get("purchased_at")
                if timestamp:
                    try:
                        purchase_dt = datetime.fromisoformat(str(timestamp))
                        if purchase_dt.tzinfo is None:
                            purchase_dt = purchase_dt.replace(tzinfo=settings.TIMEZONE)
                    except ValueError:
                        continue
                    if purchase_dt + keep_delta <= current_time:
                        continue
                filtered.append(purchase)
            return filtered
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch purchases for user %s: %s", user_id, error)
            return []

    def list_active_byt_timer_times(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active BYT timer times for user."""

        self.ensure_byt_timer_defaults(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id, hour, minute
                FROM byt_timer_times
                WHERE user_id = ? AND is_active = 1
                ORDER BY hour, minute, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT timer times for user %s: %s", user_id, error
            )
            return []

    def add_byt_timer_time(self, user_id: int, hour: int, minute: int) -> Optional[int]:
        """Add a new BYT timer time if not duplicate."""

        self.ensure_byt_timer_defaults(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT id FROM byt_timer_times
                WHERE user_id = ? AND hour = ? AND minute = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, hour, minute),
            )
            existing = cursor.fetchone()
            if existing:
                return int(existing["id"])

            cursor.execute(
                """
                INSERT INTO byt_timer_times (user_id, hour, minute, is_active)
                VALUES (?, ?, ?, 1)
                """,
                (user_id, hour, minute),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to add BYT timer time for user %s: %s", user_id, error)
            return None

    def deactivate_byt_timer_time(self, user_id: int, timer_id: int) -> None:
        """Deactivate specific BYT timer time."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE byt_timer_times
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, timer_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate BYT timer time %s for user %s: %s",
                timer_id,
                user_id,
                error,
            )

    def reset_byt_timer_times(self, user_id: int) -> None:
        """Reset BYT timer times to defaults."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE byt_timer_times SET is_active = 0 WHERE user_id = ?",
                (user_id,),
            )
            for hour, minute in [(12, 0), (18, 0)]:
                cursor.execute(
                    """
                    INSERT INTO byt_timer_times (user_id, hour, minute, is_active)
                    VALUES (?, ?, ?, 1)
                    """,
                    (user_id, hour, minute),
                )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to reset BYT timer times for user %s: %s", user_id, error)

    def get_users_with_byt_timer_times(self) -> List[int]:
        """Return users that have BYT timer times configured."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT DISTINCT user_id
                FROM byt_timer_times
                WHERE is_active = 1
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with BYT timer times: %s", error)
            return []

    def get_users_with_active_byt_wishes(self) -> List[int]:
        """Return user ids that have active BYT wishes."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT DISTINCT user_id
                FROM wishes
                WHERE category IN ('byt', 'БЫТ') AND (is_purchased = 0 OR is_purchased IS NULL)
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with active BYT wishes: %s", error)
            return []

    def cleanup_old_byt_purchases(self, now: Optional[datetime] = None) -> None:
        """Remove BYT purchases older than one month from purchases and wishes."""

        current_time = now or now_tz()
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id, purchased_at FROM purchases WHERE category IN ('byt', 'БЫТ')"
            )
            purchases = cursor.fetchall()
            ids_to_delete: list[int] = []
            for purchase in purchases:
                timestamp = purchase["purchased_at"]
                if not timestamp:
                    continue
                try:
                    purchase_dt = datetime.fromisoformat(timestamp)
                    if purchase_dt.tzinfo is None:
                        purchase_dt = purchase_dt.replace(tzinfo=settings.TIMEZONE)
                except ValueError:
                    continue
                if add_one_month(purchase_dt) <= current_time:
                    ids_to_delete.append(int(purchase["id"]))

            if ids_to_delete:
                cursor.execute(
                    "DELETE FROM purchases WHERE id IN ({})".format(
                        ",".join("?" * len(ids_to_delete))
                    ),
                    ids_to_delete,
                )

            cursor.execute(
                "SELECT id, purchased_at FROM wishes WHERE category IN ('byt', 'БЫТ') AND is_purchased = 1"
            )
            wish_rows = cursor.fetchall()
            wish_ids: list[int] = []
            for wish in wish_rows:
                purchased_at = wish["purchased_at"]
                if not purchased_at:
                    continue
                try:
                    wish_dt = datetime.fromisoformat(purchased_at)
                    if wish_dt.tzinfo is None:
                        wish_dt = wish_dt.replace(tzinfo=settings.TIMEZONE)
                except ValueError:
                    continue
                if add_one_month(wish_dt) <= current_time:
                    wish_ids.append(int(wish["id"]))

            if wish_ids:
                cursor.execute(
                    "DELETE FROM wishes WHERE id IN ({})".format(",".join("?" * len(wish_ids))),
                    wish_ids,
                )
            if ids_to_delete or wish_ids:
                self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to cleanup old BYT purchases: %s", error)

    def close(self) -> None:
        """Close database connection."""

        try:
            self.connection.close()
            LOGGER.info("Database connection closed")
        except sqlite3.Error as error:
            LOGGER.error("Failed to close database connection: %s", error)

===== Bot/database/models.py =====
"""Database model helpers."""
from dataclasses import dataclass
from typing import Optional


@dataclass
class Saving:
    """Saving record representation."""

    id: int
    user_id: int
    category: str
    current: float
    goal: float
    purpose: str


@dataclass
class Wish:
    """Wish record representation."""

    id: int
    user_id: int
    name: str
    price: float
    url: Optional[str]
    category: str
    is_purchased: bool
    saved_amount: float
    purchased_at: Optional[str]
    deferred_until: Optional[str]


@dataclass
class Purchase:
    """Purchase record representation."""

    id: int
    user_id: int
    wish_name: str
    price: float
    category: str
    purchased_at: str

===== Bot/handlers/__init__.py =====


===== Bot/handlers/callbacks.py =====
"""Callback query handlers."""
import logging
from typing import Dict
from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup

from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.finances import (
    _format_savings_summary,
    show_affordable_wishes,
)
from Bot.keyboards.main import back_only_keyboard, wishlist_categories_keyboard
from Bot.states.wishlist_states import WishlistState
from Bot.handlers.wishlist import (
    WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY,
    _get_user_wishlist_categories,
    humanize_wishlist_category,
)
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()

@router.callback_query(F.data.startswith("wlcat:"))
async def handle_category_selection(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle category selection for viewing or adding wishes."""

    try:
        category_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("Некорректная категория", show_alert=True)
        return

    db = FinanceDatabase()
    category_row = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category_row:
        await callback.answer("Категория не найдена", show_alert=True)
        return

    category_code = category_row.get("title", "")
    category = humanize_wishlist_category(category_code)
    category_code_norm = "byt" if category == "БЫТ" else category_code
    data = await state.get_data()
    current_state = await state.get_state()

    if current_state == WishlistState.waiting_for_category.state:
        await _finalize_wish(callback, state, category_code_norm, category)
        return

    await _send_wishes_list(callback, category)


@router.callback_query(F.data == "wishlist_skip_url")
async def skip_wishlist_url(callback: CallbackQuery, state: FSMContext) -> None:
    """Skip wishlist URL step via inline button."""

    await callback.answer()
    current_state = await state.get_state()
    if current_state != WishlistState.waiting_for_url.state:
        return

    await state.update_data(url=None)
    await state.set_state(WishlistState.waiting_for_category)
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != "category":
        stack.append("category")
    await state.update_data(wl_add_step_stack=stack)
    try:
        await callback.message.delete()
    except Exception:
        pass
    await callback.message.answer(
        "Выбери категорию желания.",
        reply_markup=wishlist_categories_keyboard(
            _get_user_wishlist_categories(FinanceDatabase(), callback.from_user.id)
        ),
    )
    await callback.message.answer(
        "Если нужно, нажми ⬅️ Назад.", reply_markup=back_only_keyboard()
    )


async def _finalize_wish(
    callback: CallbackQuery,
    state: FSMContext,
    category_code: str,
    humanized_category: str,
) -> None:
    """Finalize wish creation after category selection."""

    db = FinanceDatabase()
    data = await state.get_data()
    wish_id = db.add_wish(
        user_id=callback.from_user.id,
        name=data.get("name", ""),
        price=float(data.get("price", 0)),
        url=data.get("url"),
        category=category_code,
    )
    lines = [
        f"Категория: {humanized_category}",
        f"Название: {data.get('name')}",
        f"Цена: {data.get('price')}",
        f"ID: {wish_id}",
    ]
    url = data.get("url")
    if url:
        lines.insert(3, f"Ссылка: {url}")
    info = await callback.message.answer("\n".join(lines))
    await ui_register_message(state, info.chat.id, info.message_id)
    sent = await callback.message.answer(
        "✅ Желание добавлено",
        reply_markup=await build_main_menu_for_user(callback.from_user.id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)
    await state.clear()
    LOGGER.info("User %s added wish %s", callback.from_user.id, wish_id)


async def _send_wishes_list(callback: CallbackQuery, category: str) -> None:
    """Send wishlist items for selected category."""

    db = FinanceDatabase()
    wishes = db.get_wishes_by_user(callback.from_user.id)
    savings_map = db.get_user_savings_map(callback.from_user.id)
    filtered = [
        wish
        for wish in wishes
        if (
            humanize_wishlist_category(wish.get("category", ""))
            == humanize_wishlist_category(category)
        )
        and not wish.get("is_purchased")
    ]

    if not filtered:
        await callback.message.edit_text(
            "Желаний в этой категории пока нет.",
            reply_markup=wishlist_categories_keyboard(
                _get_user_wishlist_categories(db, callback.from_user.id)
            ),
        )
        return

    for wish in filtered:
        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        savings_category = WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY.get(wishlist_category, "")
        saved_amount = float(savings_map.get(savings_category, 0.0) or 0.0)
        price = float(wish.get("price", 0) or 0.0)

        if price > 0:
            progress = min(saved_amount / price, 1.0)
        else:
            progress = 0.0
        total_blocks = 10
        filled_blocks = int(progress * total_blocks)
        bar = "■" * filled_blocks + "□" * (total_blocks - filled_blocks)
        remaining = max(price - saved_amount, 0.0)
        progress_percent = round(progress * 100)

        lines = [
            f"{wish['name']} — {price:.2f} ({wishlist_category})",
            f"Прогресс: {bar} {progress_percent}%",
            f"Накоплено: {saved_amount:.2f}, осталось: {remaining:.2f}",
        ]
        if wish.get("url"):
            lines.append(f"Ссылка: {wish['url']}")
        text = "\n".join(lines)
        inline_kb = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="Купил", callback_data=f"wish_buy_{wish['id']}")]]
        )
        await callback.message.answer(text, reply_markup=inline_kb)


@router.callback_query(F.data.startswith("wish_buy_"))
async def handle_wish_purchase(callback: CallbackQuery) -> None:
    """Handle purchase of a wish."""

    wish_id = int(callback.data.split("wish_buy_")[-1])
    db = FinanceDatabase()
    wish = db.get_wish(wish_id)

    if not wish:
        await callback.answer("Желание не найдено.", show_alert=True)
        return

    wishlist_category = humanize_wishlist_category(wish.get("category"))
    savings_category = WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY.get(wishlist_category)

    if not savings_category:
        LOGGER.error(
            "No savings mapping for wishlist category %s (wish_id=%s, user_id=%s)",
            wishlist_category,
            wish_id,
            callback.from_user.id,
        )
        await callback.answer(
            "Эта категория не привязана к накоплениям, настрой её позже.",
            show_alert=True,
        )
        return

    savings_map = db.get_user_savings_map(callback.from_user.id)
    category_savings = savings_map.get(savings_category, 0.0)
    price = float(wish.get("price", 0) or 0.0)

    if category_savings < price:
        await callback.answer(
            (
                "Недостаточно средств в накоплениях для этой категории.\n"
                f"Нужно: {price:.2f}, доступно: {category_savings:.2f}."
            ),
            show_alert=True,
        )
        return

    db.update_saving(callback.from_user.id, savings_category, -price)
    db.mark_wish_purchased(wish_id)
    db.add_purchase(callback.from_user.id, wish["name"], price, wishlist_category)

    await callback.message.edit_text(f"🎉 Поздравляю, ты купил {wish['name']} за {price:.2f}!")
    savings = db.get_user_savings(callback.from_user.id)
    summary = _format_savings_summary(savings)
    await callback.message.answer(f"Обновлённые накопления:\n{summary}")
    await show_affordable_wishes(message=callback.message, user_id=callback.from_user.id, db=db)
    await callback.answer()
    LOGGER.info(
        "User %s purchased wish %s (wishlist_category=%s, savings_category=%s, price=%.2f, savings_before=%.2f)",
        callback.from_user.id,
        wish_id,
        wishlist_category,
        savings_category,
        price,
        category_savings,
    )


@router.callback_query(F.data == "affordable_wishes_later")
async def handle_affordable_wishes_later(callback: CallbackQuery, state: FSMContext) -> None:
    """Close affordable wish suggestions and return to main menu."""

    await state.clear()
    if callback.message:
        try:
            await callback.message.edit_reply_markup(reply_markup=None)
        except Exception:
            LOGGER.debug("Failed to clear inline keyboard for affordable wishes", exc_info=True)
        sent = await callback.message.answer(
            "Хорошо, вернёмся к покупкам позже. Главное меню.",
            reply_markup=await build_main_menu_for_user(callback.from_user.id),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
    await callback.answer()

===== Bot/handlers/common.py =====
"""Common handlers and fallbacks."""
import logging

from aiogram import Router
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ReplyKeyboardMarkup

from Bot.config import settings
from Bot.database.crud import FinanceDatabase
from Bot.keyboards.main import main_menu_keyboard
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def build_main_menu_for_user(user_id: int) -> ReplyKeyboardMarkup:
    """Construct main menu keyboard with optional household button."""

    db = FinanceDatabase()
    from Bot.handlers.household_payments import reset_household_cycle_if_needed

    await reset_household_cycle_if_needed(user_id, db)
    month = current_month_str()
    show_household = await db.should_show_household_payments_button(user_id, month)
    show_test_button = user_id == settings.ADMIN_ID
    return main_menu_keyboard(
        show_household=show_household,
        show_test_button=show_test_button,
        show_settings=True,
    )


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Compatibility no-op; welcome messages are kept."""

    return None


@router.message()
async def fallback_handler(message: Message, state: FSMContext) -> None:
    """Handle unmatched messages."""

    await delete_welcome_message_if_exists(message, state)
    current_state = await state.get_state()
    LOGGER.debug("Fallback triggered. User: %s State: %s Text: %s", message.from_user.id, current_state, message.text)
    sent = await message.answer(
        "Не понял сообщение. Пожалуйста, пользуйся кнопками или командами.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

===== Bot/handlers/finances.py =====
"""Handlers for income calculation and savings."""
import logging
from typing import Any, Dict, List, Optional

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, Message

from Bot.database.crud import FinanceDatabase
from Bot.keyboards.main import (
    back_to_main_keyboard,
    purchase_confirmation_keyboard,
    yes_no_inline_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.handlers.common import build_main_menu_for_user
from Bot.states.money_states import MoneyState
from Bot.handlers.wishlist import WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY, humanize_wishlist_category
from Bot.utils.savings import find_reached_goal, format_savings_summary
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


def _message_user_id(message: Message) -> int:
    """Extract user id from message."""

    return message.from_user.id if message.from_user else message.chat.id


def _callback_user_id(callback: CallbackQuery) -> int:
    """Extract user id from callback."""

    if callback.from_user:
        return callback.from_user.id
    return callback.message.chat.id


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

INCOME_DIGITS = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}
INCOME_INPUT_BUTTONS = INCOME_DIGITS | {"Очистить"}


def _build_allocations(categories: List[Dict[str, Any]], amount: float) -> List[Dict[str, Any]]:
    """Build allocation list from income categories."""

    allocations: List[Dict[str, Any]] = []
    for category in categories:
        percent = float(category.get("percent", 0))
        allocated = amount * percent / 100
        allocations.append(
            {
                "label": category.get("title", ""),
                "category": category.get("code", ""),
                "amount": allocated,
            }
        )
    return allocations


def _build_income_prompt(income_sum: str) -> str:
    """Build income input prompt."""

    # Отображаем сумму в формате ": <число>"
    return f": {income_sum}"


async def _refresh_income_message(
    message: Message, income_message_id: Optional[int], income_sum: str
) -> int:
    """Update or create income prompt message with current sum.

    Редактируем уже существующее сообщение с подсказкой по сумме.
    Если id нет (например, первый запуск) — создаём новое.
    При ошибке редактирования пытаемся удалить старое сообщение и создаём новое,
    чтобы пользователь видел актуальную сумму.
    """

    text = _build_income_prompt(income_sum)

    # Если сообщения ещё не было — создаём его
    if income_message_id is None:
        new_message = await message.answer(text)
        return new_message.message_id

    # Пытаемся отредактировать существующее сообщение
    try:
        await message.bot.edit_message_text(
            chat_id=message.chat.id,
            message_id=income_message_id,
            text=text,
        )
        return income_message_id
    except Exception:  # noqa: BLE001
        LOGGER.warning(
            "Failed to edit income message %s",
            income_message_id,
            exc_info=True,
        )

    try:
        await message.bot.delete_message(
            chat_id=message.chat.id,
            message_id=income_message_id,
        )
    except Exception:
        pass

    new_message = await message.answer(text)
    return new_message.message_id


def _to_float(value: Any) -> float:
    """Safely convert value to float."""

    try:
        return float(value) if value is not None else 0.0
    except (TypeError, ValueError):
        return 0.0


def _format_savings_summary(savings: Dict[str, Dict[str, Any]]) -> str:
    """Format savings summary for user message."""

    return format_savings_summary(savings)


def _find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> tuple[str, Dict[str, Any]] | tuple[None, None]:
    """Find category where goal is reached."""

    return find_reached_goal(savings)


async def _ask_allocation_confirmation(
    message: Message, state: FSMContext, allocation: Dict[str, Any]
) -> None:
    """Ask user to confirm allocation for a specific category.

    Args:
        message: Aiogram message object used for sending prompts.
        allocation: Allocation details with label and amount.
    """

    text = (
        f"На категорию {allocation['label']} можно направить "
        f"{allocation['amount']:.2f}. Перевести?"
    )
    data = await state.get_data()
    existing_id: Optional[int] = data.get("allocation_question_message_id")
    if existing_id:
        try:
            await message.bot.edit_message_text(
                chat_id=message.chat.id,
                message_id=existing_id,
                text=text,
                reply_markup=yes_no_inline_keyboard(),
            )
            return
        except Exception:
            pass

    sent = await message.answer(text, reply_markup=yes_no_inline_keyboard())
    await state.update_data(allocation_question_message_id=sent.message_id)


@router.message(F.text == "Рассчитать доход")
async def start_income_flow(message: Message, state: FSMContext) -> None:
    """Start income calculation workflow with calculator keyboard."""

    await delete_welcome_message_if_exists(message, state)
    await state.clear()
    FinanceDatabase().ensure_income_categories_seeded(message.from_user.id)
    await state.set_state(MoneyState.waiting_for_amount)

    income_sum = "0"
    question = await message.answer(
        "Введи сумму дохода (используй кнопки ниже).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = _build_income_prompt(income_sum)
    income_message = await message.answer(prompt)

    # Сохраняем служебные message_id и текущую сумму
    await state.update_data(
        income_sum=income_sum,
        income_question_message_id=question.message_id,
        income_message_id=income_message.message_id,
    )

    # Удаляем сообщение пользователя "Рассчитать доход"
    try:
        await message.delete()
    except Exception:  # noqa: BLE001
        LOGGER.warning("Failed to delete user command message", exc_info=True)

    LOGGER.info(
        "User %s started income calculation",
        message.from_user.id if message.from_user else "unknown",
    )


async def _process_income_amount_value(
    message: Message,
    state: FSMContext,
    amount: float,
) -> None:
    """Validate amount and start category confirmation workflow."""

    # Базовая валидация суммы
    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "Сумма должна быть положительной и не больше 10 000 000. Попробуй снова."
        )
        return

    # Удаляем служебное сообщение с суммой и вопрос с клавиатурой
    data = await state.get_data()
    income_question_message_id: Optional[int] = data.get("income_question_message_id")
    income_message_id: Optional[int] = data.get("income_message_id")

    if income_question_message_id:
        try:
            await message.bot.delete_message(
                chat_id=message.chat.id,
                message_id=income_question_message_id,
            )
        except Exception:  # noqa: BLE001
            LOGGER.warning(
                "Failed to delete income helper message %s",
                income_question_message_id,
                exc_info=True,
            )

    if income_message_id:
        try:
            await message.bot.delete_message(
                chat_id=message.chat.id,
                message_id=income_message_id,
            )
        except Exception:  # noqa: BLE001
            LOGGER.warning(
                "Failed to delete income helper message %s",
                income_message_id,
                exc_info=True,
            )

    db = FinanceDatabase()
    db.ensure_income_categories_seeded(message.from_user.id)
    categories = db.list_active_income_categories(message.from_user.id)
    total_percent = db.sum_income_category_percents(message.from_user.id)
    if total_percent != 100:
        sent = await message.answer(
            f"Сумма процентов должна быть 100%. Сейчас: {total_percent}%. Исправь настройки через ⚙️ → 📊 Доход.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    allocations: List[Dict[str, Any]] = _build_allocations(categories, amount)

    if not allocations:
        sent = await message.answer(
            "Нет категорий для распределения.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    # Сохраняем данные в FSM
    await state.update_data(
        income_amount=amount,
        allocations=allocations,
        index=0,
        life_message_id=None,
    )

    # Переходим в состояние подтверждения категорий
    await state.set_state(MoneyState.confirm_category)

    # Задаём вопрос ТОЛЬКО по первой категории
    current = allocations[0]
    await _ask_allocation_confirmation(
        message=message,
        state=state,
        allocation=current,
    )

    try:
        await message.delete()
    except Exception:
        pass


@router.message(
    MoneyState.waiting_for_amount,
    F.text.in_(INCOME_INPUT_BUTTONS),
)
async def handle_income_digit(message: Message, state: FSMContext) -> None:
    """Handle digit and clear input for income calculator."""

    data = await state.get_data()
    current_sum = str(data.get("income_sum", "0"))
    sum_message_id = data.get("income_message_id")

    if message.text == "Очистить":
        new_sum = "0"
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    income_message_id = await _refresh_income_message(
        message=message,
        income_message_id=sum_message_id,
        income_sum=new_sum,
    )

    await state.update_data(income_sum=new_sum, income_message_id=income_message_id)

    try:
        await message.delete()
    except Exception:
        pass


@router.message(MoneyState.waiting_for_amount, F.text == "✅ Газ")
async def handle_income_confirm(message: Message, state: FSMContext) -> None:
    """Handle confirmation of income input via calculator button."""

    data = await state.get_data()
    amount_str = str(data.get("income_sum", "0")).strip()

    if not amount_str:
        await message.answer("Сначала набери сумму с помощью кнопок.")
        try:
            await message.delete()
        except Exception:
            pass
        return

    normalized = amount_str.replace(",", ".")
    try:
        amount = float(normalized)
    except ValueError:
        await message.answer("Некорректная сумма. Попробуй ещё раз.")
        try:
            await message.delete()
        except Exception:
            pass
        return

    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "Сумма должна быть положительной и не больше 10 000 000. Попробуй снова."
        )
        try:
            await message.delete()
        except Exception:
            pass
        return

    await _process_income_amount_value(
        message=message,
        state=state,
        amount=amount,
    )

    try:
        await message.delete()
    except Exception:
        pass


@router.callback_query(MoneyState.confirm_category, F.data.in_({"confirm_yes", "confirm_no"}))
async def handle_category_confirmation(query: CallbackQuery, state: FSMContext) -> None:
    """Handle user confirmation for category allocation via inline buttons."""

    await query.answer()

    data = await state.get_data()
    allocations: List[Dict[str, Any]] = data.get("allocations", [])
    index: int = int(data.get("index", 0))
    # Если категорий нет или индекс вышел за пределы — выходим в главное меню
    if not allocations or index >= len(allocations):
        sent = await query.message.answer(
            "Нет категорий для обработки.",
            reply_markup=await build_main_menu_for_user(_callback_user_id(query)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    current = allocations[index]

    # --- Пользователь нажал "Да" ---
    if query.data == "confirm_yes":
        # Обновляем накопления
        FinanceDatabase().update_saving(
            user_id=query.from_user.id if query.from_user else None,
            category=current["category"],
            amount_delta=current["amount"],
        )

        # Переходим к следующей категории
        index += 1

    # --- Пользователь нажал "Нет" ---
    else:
        await query.answer("Ты что про жизнь забыл?", show_alert=True)

    # Если ещё есть категории — задаём следующий вопрос
    if index < len(allocations):
        await state.update_data(
            index=index,
        )
        next_allocation = allocations[index]
        await _ask_allocation_confirmation(
            message=query.message,
            state=state,
            allocation=next_allocation,
        )
    else:
        try:
            await query.message.edit_reply_markup(reply_markup=None)
        except Exception:
            pass
        await _send_summary_and_goal_prompt(
            message=query.message,
            state=state,
            user_id=query.from_user.id if query.from_user else None,
        )


async def _send_summary_and_goal_prompt(
    message: Message,
    state: FSMContext,
    user_id: Optional[int],
) -> None:
    """Send savings summary and suggest purchase if goal reached."""

    # Достаём сумму, которую пользователь ввёл как доход
    data = await state.get_data()
    income_amount = data.get("income_amount", 0)

    # Восстанавливаем user_id, если не передали явно
    if user_id is None:
        user_id = message.from_user.id if message.from_user else message.chat.id

    await state.clear()
    db = FinanceDatabase()

    # Читаем накопления по реальному user_id пользователя
    savings = db.get_user_savings(user_id)
    summary = _format_savings_summary(savings)

    # Формируем текст: сначала "Получено бабок", затем текущие накопления
    lines: List[str] = []
    if income_amount:
        lines.append(f"Получено бабок: {income_amount:.2f}")
        lines.append("")  # пустая строка для читаемости

    lines.append("Текущие накопления:")
    lines.append(summary)

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(user_id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

    category, goal_data = _find_reached_goal(savings)
    if category:
        goal = goal_data.get("goal", 0)
        purpose = goal_data.get("purpose", "цель")
        current = goal_data.get("current", 0)
        await message.answer(
            f"🎯 Цель достигнута по категории {category}. "
            f"На цели {purpose} накоплено {current:.2f} из {goal:.2f}.",
            reply_markup=purchase_confirmation_keyboard(),
        )
        await state.update_data(category=category, goal=goal)
        await state.set_state(MoneyState.waiting_for_purchase_confirmation)
        return

    # Подбор желаний из вишлиста по тем же savings и user_id
    await show_affordable_wishes(
        message=message,
        user_id=user_id,
        db=db,
    )


def _build_affordable_wishes_keyboard(wishes: List[Dict[str, Any]]) -> InlineKeyboardMarkup:
    """Build inline keyboard with purchase buttons for affordable wishes."""

    buttons = [
        [InlineKeyboardButton(text=f"{wish['name']}", callback_data=f"wish_buy_{wish['id']}")]
        for wish in wishes
    ]
    buttons.append([InlineKeyboardButton(text="Потом", callback_data="affordable_wishes_later")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


async def show_affordable_wishes(
    message: Message,
    user_id: int | None = None,
    db: FinanceDatabase | None = None,
) -> None:
    """Show all wishes that are affordable with current savings."""

    if message is None:
        return

    if user_id is None:
        user_id = message.from_user.id if message.from_user else None

    if user_id is None:
        return

    db = db or FinanceDatabase()
    savings_map = db.get_user_savings_map(user_id)
    wishes = db.get_wishes_by_user(user_id)

    affordable: List[Dict[str, Any]] = []
    for wish in wishes:
        if wish.get("is_purchased"):
            continue

        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        savings_category = WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY.get(wishlist_category)
        if not savings_category:
            continue

        price = _to_float(wish.get("price"))
        available = _to_float(savings_map.get(savings_category))
        if price <= 0 or available < price:
            continue

        wish_copy: Dict[str, Any] = dict(wish)
        wish_copy["price"] = price
        wish_copy["wishlist_category"] = wishlist_category
        affordable.append(wish_copy)

    if not affordable:
        return

    lines = ["Ты уже можешь купить:"]
    for wish in affordable:
        lines.append(
            f"• {wish['name']} — {wish['price']:.2f} ₽ (категория: {wish['wishlist_category']})"
        )
    lines.append("Нажми на кнопку под нужным товаром, если купил.")

    keyboard = _build_affordable_wishes_keyboard(affordable)
    await message.answer("\n".join(lines), reply_markup=keyboard)


async def suggest_available_wish(message: Message) -> None:
    """Backward-compatible wrapper to show affordable wishes."""

    await show_affordable_wishes(message=message, user_id=message.from_user.id if message.from_user else None)


@router.message(MoneyState.waiting_for_purchase_confirmation, F.text.in_({"✅ Купил", "🔄 Продолжить копить"}))
async def handle_goal_purchase(message: Message, state: FSMContext) -> None:
    """Handle decision after reaching savings goal."""

    data = await state.get_data()
    category = data.get("category")
    goal_amount = data.get("goal", 0)
    db = FinanceDatabase()

    if message.text == "✅ Купил" and category:
        db.update_saving(message.from_user.id, category, -goal_amount)
        db.set_goal(message.from_user.id, category, 0, "")
        sent = await message.answer(
            f"Поздравляю с покупкой по категории {category}! Сумма {goal_amount:.2f} списана.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        savings = db.get_user_savings(message.from_user.id)
        summary = _format_savings_summary(savings)
        await message.answer(f"Обновлённые накопления:\n{summary}")
    else:
        sent = await message.answer(
            "Продолжаем копить!",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)

    await state.clear()
    LOGGER.info("User %s handled goal decision for category %s", message.from_user.id, category)


@router.message(MoneyState.confirm_category)
async def unexpected_confirmation_input(message: Message) -> None:
    """Handle unexpected text in confirmation state."""

    await message.answer("Используй кнопки Да/Нет для выбора.")


@router.message(MoneyState.waiting_for_purchase_confirmation)
async def unexpected_purchase_input(message: Message) -> None:
    """Handle unexpected text in purchase confirmation state."""

    await message.answer("Выбери вариант на клавиатуре: Купил или Продолжить копить.")

===== Bot/handlers/household_payments.py =====
"""Handlers for household payments scenario."""
from datetime import datetime, time as dt_time
import logging
import time
from typing import Dict, List

from aiogram import F, Router
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, ReplyKeyboardRemove

from Bot.config import settings
from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.keyboards.settings import (
    household_remove_keyboard,
    household_settings_inline_keyboard,
    settings_menu_keyboard,
)
from Bot.renderers.household import (
    build_household_question_keyboard,
    format_household_items,
    render_household_questions_text,
)
from Bot.services.household import (
    build_answers_from_status,
    build_household_questions,
    filter_unpaid_questions,
    get_current_question,
    get_next_index,
    get_previous_index,
    should_ignore_answer,
    update_flow_state,
)
from Bot.states.money_states import HouseholdPaymentsState, HouseholdSettingsState
from Bot.utils.datetime_utils import current_month_str, now_tz
from Bot.utils.savings import format_savings_summary
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_register_message,
    ui_register_user_message,
    ui_render_screen,
)

LOGGER = logging.getLogger(__name__)

router = Router(name="household_payments")


def _format_meta(meta: dict) -> str:
    if not meta:
        return "-"
    return " ".join(f"{key}={value}" for key, value in meta.items())


async def _log_state_transition(
    state: FSMContext, user_id: int, to_state: str | None
) -> None:
    from_state = await state.get_state()
    LOGGER.info(
        "USER=%s ACTION=STATE_TRANSITION STATE=%s->%s META=-",
        user_id,
        from_state,
        to_state,
    )


def _log_event(user_id: int, action: str, state: str | None, **meta: str) -> None:
    LOGGER.info(
        "USER=%s ACTION=%s STATE=%s META=%s",
        user_id,
        action,
        state,
        _format_meta(meta),
    )


async def _send_main_menu_summary(
    bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    db = FinanceDatabase()
    savings = db.get_user_savings(user_id)
    summary = format_savings_summary(savings)
    menu = await build_main_menu_for_user(user_id)
    await ui_render_screen(
        bot,
        state,
        chat_id,
        f"Текущие накопления:\n{summary}",
        reply_markup=menu,
    )


async def reset_household_cycle_if_needed(
    user_id: int, db: FinanceDatabase, now: datetime | None = None
) -> None:
    """Lazily reset household payments cycle after 6th of month at noon."""

    current = now or datetime.now(tz=settings.TIMEZONE)
    month = current_month_str(current)

    threshold = datetime(current.year, current.month, 6, 12, 0, tzinfo=settings.TIMEZONE)
    if current >= threshold:
        await db.init_household_questions_for_month(user_id, month)


def _format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    return format_household_items(items, unpaid_set)


async def _send_household_settings_overview(
    message: Message, db: FinanceDatabase, user_id: int
) -> None:
    items = db.list_active_household_items(user_id)
    month = current_month_str()
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    unpaid_set: set[str] = set(unpaid_codes)
    _log_event(
        user_id,
        "HOUSEHOLD_SETTINGS_OVERVIEW",
        None,
        month=month,
        items_count=str(len(items)),
        unpaid_count=str(len(unpaid_set)),
    )
    if not items:
        _log_event(
            user_id,
            "HOUSEHOLD_SETTINGS_EMPTY",
            None,
            source="list_active_household_items",
        )
    await message.answer(
        _format_household_items(items, unpaid_set),
        reply_markup=household_settings_inline_keyboard(),
    )


@router.message(F.text == "⚙️ Бытовые платежи ⚙️")
async def open_household_settings(message: Message, state: FSMContext) -> None:
    """Open household payments settings menu."""

    await ui_register_user_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
    except Exception:
        LOGGER.warning("Failed to delete user menu message (⚙️ Бытовые платежи ⚙️)", exc_info=True)
    if message.from_user.id != settings.ADMIN_ID:
        sent = await message.answer(
            "Что-то пошло не так. Вернёмся в главное меню.",
            reply_markup=await build_main_menu_for_user(message.from_user.id),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    await state.clear()
    db = FinanceDatabase()
    sent = await message.answer(
        "⚙️ Бытовые платежи ⚙️", reply_markup=settings_menu_keyboard()
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)
    await _send_household_settings_overview(message, db, message.from_user.id)


@router.callback_query(F.data == "hh_set:add")
async def household_add_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Prompt for new household payment title."""

    await callback.answer()
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    await state.set_state(HouseholdSettingsState.waiting_for_title)
    await callback.message.answer("Введи название платежа")


@router.message(HouseholdSettingsState.waiting_for_title)
async def household_add_set_title(message: Message, state: FSMContext) -> None:
    """Handle title input for new household payment."""

    title = (message.text or "").strip()
    if not title:
        await message.answer("Нужно ввести название платежа.")
        return

    await state.update_data(title=title)
    await state.set_state(HouseholdSettingsState.waiting_for_amount)

    question = await message.answer(
        "Введи сумму (используй кнопки ниже).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = await message.answer(": 0")

    await state.update_data(
        amount_sum="0",
        amount_message_id=prompt.message_id,
        amount_question_message_id=question.message_id,
    )


@router.message(
    HouseholdSettingsState.waiting_for_amount,
    F.text.in_({"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Очистить", "✅ Газ"}),
)
async def household_add_amount_calc(message: Message, state: FSMContext) -> None:
    """Handle calculator input for new household payment amount."""

    data = await state.get_data()
    current_sum = str(data.get("amount_sum", "0"))
    amount_message_id = data.get("amount_message_id")

    if message.text == "Очистить":
        new_sum = "0"
    elif message.text == "✅ Газ":
        amount_str = current_sum.strip()
        if not amount_str:
            await message.answer("Нужно ввести число. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                LOGGER.warning("Failed to delete amount prompt message", exc_info=True)
            return

        try:
            amount = int(amount_str)
        except (TypeError, ValueError):
            await message.answer("Нужно ввести число. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                LOGGER.warning("Failed to delete amount prompt message", exc_info=True)
            return

        if amount <= 0:
            await message.answer("Сумма должна быть больше нуля. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                LOGGER.warning("Failed to delete amount prompt message", exc_info=True)
            return

        user_id = message.from_user.id
        db = FinanceDatabase()
        position = db.get_next_household_position(user_id)
        title = str(data.get("title", "")).strip() or "Платёж"
        code = f"custom_{time.time_ns()}"
        text = f"{title} {amount}р?"
        db.add_household_payment_item(user_id, code, text, amount, position)
        await reset_household_cycle_if_needed(user_id, db)
        await state.clear()
        await message.answer(
            "Платёж добавлен.", reply_markup=ReplyKeyboardRemove()
        )
        await message.answer(
            "⚙️ Бытовые платежи ⚙️", reply_markup=settings_menu_keyboard()
        )
        await _send_household_settings_overview(message, db, user_id)
        try:
            await message.delete()
        except Exception:
            LOGGER.warning("Failed to delete amount confirmation message", exc_info=True)
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if amount_message_id:
        try:
            await message.bot.edit_message_text(
                chat_id=message.chat.id,
                message_id=amount_message_id,
                text=f": {new_sum}",
            )
        except Exception:
            LOGGER.warning("Failed to edit amount message", exc_info=True)

    await state.update_data(amount_sum=new_sum, amount_message_id=amount_message_id)

    try:
        await message.delete()
    except Exception:
        LOGGER.warning("Failed to delete calculator message", exc_info=True)


@router.callback_query(F.data == "hh_set:del")
async def household_remove_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Show list of household payments for removal."""

    await callback.answer()
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    db = FinanceDatabase()
    db.ensure_household_items_seeded(callback.from_user.id)
    items = db.list_active_household_items(callback.from_user.id)
    if not items:
        await callback.message.answer("Список платежей пуст.")
        return

    await callback.message.answer(
        "Выбери платеж для удаления:",
        reply_markup=household_remove_keyboard(items),
    )


@router.callback_query(F.data.startswith("hh_set:remove:"))
async def household_remove_item(callback: CallbackQuery, state: FSMContext) -> None:
    """Deactivate selected household payment item."""

    await callback.answer()
    if callback.from_user.id != settings.ADMIN_ID:
        return

    parts = callback.data.split(":") if callback.data else []
    if len(parts) != 3:
        return
    code = parts[2]
    db = FinanceDatabase()
    db.deactivate_household_payment_item(callback.from_user.id, code)
    await reset_household_cycle_if_needed(callback.from_user.id, db)
    await _send_household_settings_overview(callback.message, db, callback.from_user.id)


@router.message(F.text == "Бытовые платежи")
async def start_household_payments(message: Message, state: FSMContext) -> None:
    """Start household payments flow."""

    await ui_register_user_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
    except Exception:  # noqa: BLE001
        LOGGER.warning(
            "Failed to delete user menu message (Бытовые платежи)", exc_info=True
        )

    user_id = message.from_user.id
    db = FinanceDatabase()

    await reset_household_cycle_if_needed(user_id, db)
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)
    if not items:
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await ui_render_screen(
            message.bot,
            state,
            message.chat.id,
            "Список бытовых платежей не настроен.",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        return

    month = current_month_str()
    await db.init_household_questions_for_month(user_id, month)
    status_map = await db.get_household_payment_status_map(user_id, month)
    questions = build_household_questions(items)
    answers = build_answers_from_status(status_map)
    all_paid = all(status_map.get(str(question.get("code", "")), 0) == 1 for question in questions)
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    hh_questions = filter_unpaid_questions(questions, unpaid_codes)

    if all_paid or not hh_questions:
        text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        lines = text.splitlines()
        if lines:
            lines[0] = f"✅ Все бытовые платежи оплачены за {month}"
        text = "\n".join(lines)
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await ui_render_screen(
            message.bot,
            state,
            message.chat.id,
            text,
            reply_markup=await build_main_menu_for_user(user_id),
            parse_mode="HTML",
        )
        _log_event(
            user_id,
            "HOUSEHOLD_ALL_PAID",
            None,
            month=month,
        )
        return

    await _log_state_transition(state, user_id, HouseholdPaymentsState.waiting_for_answer.state)
    await state.set_state(HouseholdPaymentsState.waiting_for_answer)
    flow_state = update_flow_state(
        month=month,
        questions=hh_questions,
        current_step_index=0,
        answers=answers,
        processed_steps=[],
    )
    await state.update_data(
        hh_month=month,
        hh_questions=hh_questions,
        hh_index=0,
        hh_answers=answers,
        hh_ui_message_id=0,
        current_step_index=flow_state.current_step_index,
        current_question_code=flow_state.current_question_code,
        processed_steps=[],
    )
    text = render_household_questions_text(
        month, hh_questions, answers, current_index=0
    )
    sent = await message.answer(
        text,
        reply_markup=build_household_question_keyboard(
            flow_state.current_question_code, show_back=False
        ),
        parse_mode="HTML",
    )
    await state.update_data(hh_ui_message_id=sent.message_id)
    await ui_register_message(state, message.chat.id, sent.message_id)
    _log_event(
        user_id,
        "HOUSEHOLD_START",
        await state.get_state(),
        month=month,
    )


@router.message(F.text == "Проверить быт")
async def trigger_household_notifications(message: Message, state: FSMContext) -> None:
    """Trigger BYT purchases check (household wishlist) as if timer fired."""

    user_id = message.from_user.id
    db = FinanceDatabase()
    _log_event(user_id, "BYT_MANUAL_CHECK", None)

    db.ensure_byt_timer_defaults(user_id)
    data = await state.get_data()
    last_ts = data.get("byt_manual_check_ts")
    current_ts = time.time()
    if last_ts is not None and current_ts - float(last_ts) < 2:
        sent = await message.answer(
            "Уже проверил. Попробуй ещё раз через пару секунд.",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        return
    await state.update_data(byt_manual_check_ts=current_ts)
    try:
        await message.delete()
    except TelegramBadRequest:
        LOGGER.warning("Failed to delete BYT manual check message", exc_info=True)

    times = db.list_active_byt_timer_times(user_id)
    simulated_time = None
    if times:
        first_time = times[0]
        try:
            simulated_time = dt_time(
                hour=int(first_time.get("hour", 0)),
                minute=int(first_time.get("minute", 0)),
            )
        except Exception:
            simulated_time = None

    now_dt = now_tz()
    total_items = db.get_active_byt_wishes(user_id)
    due_items = db.list_active_byt_items_for_reminder(user_id, now_dt)
    due_ids = {int(item.get("id")) for item in due_items if item.get("id") is not None}
    deferred_items = [
        item
        for item in total_items
        if item.get("id") is not None and int(item.get("id")) not in due_ids
    ]
    nearest_deferred = None
    for item in deferred_items:
        deferred_until = item.get("deferred_until")
        if not deferred_until:
            continue
        try:
            deferred_dt = datetime.fromisoformat(str(deferred_until))
        except ValueError:
            continue
        if nearest_deferred is None or deferred_dt < nearest_deferred:
            nearest_deferred = deferred_dt
    _log_event(
        user_id,
        "BYT_MANUAL_CHECK_SUMMARY",
        None,
        total_items=str(len(total_items)),
        due_items=str(len(due_items)),
        deferred_items=str(len(deferred_items)),
        nearest_deferred=nearest_deferred.isoformat() if nearest_deferred else "None",
    )
    if not due_items:
        text = "✅ Сейчас покупать ничего не нужно. Список пуст или всё отложено."
        if deferred_items:
            if nearest_deferred:
                nearest_label = nearest_deferred.strftime("%d.%m.%Y %H:%M")
                text = (
                    f"{text}\nЕсть отложенные покупки: {len(deferred_items)} шт. "
                    f"(ближайшая — {nearest_label})"
                )
            else:
                text = (
                    f"{text}\nЕсть отложенные покупки: {len(deferred_items)} шт."
                )
        sent = await message.answer(
            text, reply_markup=await build_main_menu_for_user(user_id)
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    await run_byt_timer_check(
        message.bot, db, user_id=user_id, simulated_time=simulated_time
    )


@router.callback_query(
    HouseholdPaymentsState.waiting_for_answer,
    F.data.startswith("hh_pay:"),
)
async def handle_household_answer(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle Yes/No/Back answers for household questions."""

    data = await state.get_data()
    month = data.get("hh_month")
    questions = list(data.get("hh_questions") or [])
    index = int(data.get("current_step_index") or data.get("hh_index") or 0)
    answers = dict(data.get("hh_answers") or {})
    ui_message_id = data.get("hh_ui_message_id")
    processed_steps = set(data.get("processed_steps") or [])
    user_id = callback.from_user.id

    if callback.message is None or callback.message.message_id != ui_message_id:
        await callback.answer("Сообщение устарело", show_alert=False)
        return

    callback_parts = callback.data.split(":") if callback.data else []
    if len(callback_parts) < 2:
        await callback.answer("Сообщение устарело", show_alert=False)
        return
    action = callback_parts[1]
    callback_code = callback_parts[2] if len(callback_parts) > 2 else None

    if action == "back" and index == 0:
        await callback.answer("Назад нельзя — это первый вопрос", show_alert=True)
        return

    await callback.answer()

    if not month or not questions:
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    current_question = get_current_question(questions, index)
    current_code = str(current_question.get("code")) if current_question else None
    target_code = callback_code or current_code

    if action == "back":
        index = get_previous_index(index)
        current_question = get_current_question(questions, index)
        current_code = str(current_question.get("code")) if current_question else None
        await state.update_data(
            hh_index=index,
            current_step_index=index,
            current_question_code=current_code,
        )
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        await callback.message.edit_text(
            text,
            reply_markup=build_household_question_keyboard(
                current_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        _log_event(
            user_id,
            "HOUSEHOLD_BACK",
            await state.get_state(),
            month=str(month),
            index=str(index),
            question_code=str(current_code),
        )
        return

    if index >= len(questions):
        final_text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        await callback.message.edit_text(
            final_text,
            reply_markup=None,
            parse_mode="HTML",
        )
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    if target_code and target_code != current_code:
        if target_code in processed_steps:
            await callback.answer("Уже учтено", show_alert=False)
            return
        await callback.answer("Сообщение устарело", show_alert=False)
        return

    question = current_question
    if not question:
        await callback.answer("Сообщение устарело", show_alert=False)
        return

    code = str(question.get("code", ""))
    amount = question.get("amount")
    amount_value = float(amount) if amount is not None else 0.0
    db = FinanceDatabase()

    if action not in {"yes", "no"}:
        await callback.answer("Сообщение устарело", show_alert=False)
        return

    if should_ignore_answer(answers, processed_steps, code, action):
        await callback.answer("Уже учтено", show_alert=False)
        return

    db.apply_household_payment_answer(
        user_id=user_id,
        month=str(month),
        question_code=code,
        amount=amount_value if amount is not None else None,
        answer=action,
    )
    answers[code] = "yes" if action == "yes" else "no"
    processed_steps.add(code)

    _log_event(
        user_id,
        "HOUSEHOLD_ANSWER",
        await state.get_state(),
        month=str(month),
        question_code=code,
        answer=action,
    )

    index = get_next_index(index, questions)
    next_question = get_current_question(questions, index)
    next_code = str(next_question.get("code")) if next_question else None
    await state.update_data(
        hh_answers=answers,
        hh_index=index,
        current_step_index=index,
        current_question_code=next_code,
        processed_steps=list(processed_steps),
    )
    if index < len(questions):
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        await callback.message.edit_text(
            text,
            reply_markup=build_household_question_keyboard(
                next_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        return

    final_text = render_household_questions_text(
        month, questions, answers, current_index=None
    )
    await callback.message.edit_text(
        final_text,
        reply_markup=None,
        parse_mode="HTML",
    )
    await ui_cleanup_messages(callback.bot, state)
    await _log_state_transition(state, user_id, None)
    await state.clear()
    await _send_main_menu_summary(callback.bot, state, callback.message.chat.id, user_id)

===== Bot/handlers/settings.py =====
"""Inline settings handlers for a single-page experience."""
import logging
import time

from aiogram import F, Router
from aiogram.filters import BaseFilter
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, ReplyKeyboardMarkup, ReplyKeyboardRemove

from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import back_only_keyboard
from Bot.keyboards.settings import (
    byt_rules_reply_keyboard,
    byt_timer_reply_keyboard,
    byt_timer_times_select_reply_keyboard,
    household_payments_remove_reply_keyboard,
    household_settings_reply_keyboard,
    income_categories_select_reply_keyboard,
    income_settings_reply_keyboard,
    settings_back_reply_keyboard,
    settings_home_reply_keyboard,
    wishlist_categories_select_reply_keyboard,
    wishlist_purchased_mode_reply_keyboard,
    wishlist_settings_reply_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.states.money_states import HouseholdSettingsState, IncomeSettingsState
from Bot.states.wishlist_states import (
    BytSettingsState,
    BytTimerState,
    WishlistSettingsState,
)
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.savings import format_savings_summary
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_cleanup_to_context,
    ui_register_message,
    ui_render_screen,
    ui_set_screen_message,
    ui_track_message,
)

router = Router()
LOGGER = logging.getLogger(__name__)
PERCENT_DIGITS = {str(i) for i in range(10)}
PERCENT_INPUT_BUTTONS = PERCENT_DIGITS | {"Очистить", "✅ Газ"}


class InSettingsFilter(BaseFilter):
    async def __call__(self, message: Message, state: FSMContext) -> bool:
        data = await state.get_data()
        return bool(data.get("in_settings"))


async def _register_user_message(state: FSMContext, message: Message) -> None:
    await ui_track_message(state, message.chat.id, message.message_id)


async def _delete_message_safely(bot, chat_id: int | None, message_id: int | None) -> None:
    if chat_id is None or message_id is None:
        return
    try:
        await bot.delete_message(chat_id=chat_id, message_id=int(message_id))
    except Exception:
        pass


async def _delete_user_message(message: Message) -> None:
    try:
        await message.delete()
    except Exception:
        pass


async def _remove_calculator_keyboard(message: Message) -> None:
    try:
        temp = await message.answer(" ", reply_markup=ReplyKeyboardRemove())
        try:
            await temp.delete()
        except Exception:
            pass
    except Exception:
        pass


async def _apply_reply_keyboard(message: Message, reply_markup: ReplyKeyboardMarkup) -> None:
    try:
        temp = await message.answer(" ", reply_markup=reply_markup)
        try:
            await temp.delete()
        except Exception:
            pass
    except Exception:
        pass


def _parse_time_text(raw: str) -> tuple[int, int] | None:
    value = raw.strip()
    if ":" not in value:
        return None
    parts = value.split(":")
    if len(parts) != 2:
        return None
    try:
        hour = int(parts[0])
        minute = int(parts[1])
    except ValueError:
        return None
    if hour < 0 or hour > 23 or minute < 0 or minute > 59:
        return None
    return hour, minute


async def _cleanup_input_ui(
    bot,
    data: dict,
    *,
    display_chat_key: str | None = None,
    display_message_key: str | None = None,
    prompt_chat_key: str | None = None,
    prompt_message_key: str | None = None,
) -> None:
    if display_chat_key and display_message_key:
        await _delete_message_safely(
            bot, data.get(display_chat_key), data.get(display_message_key)
        )
    if prompt_chat_key and prompt_message_key:
        await _delete_message_safely(
            bot, data.get(prompt_chat_key), data.get(prompt_message_key)
        )


async def _store_settings_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    await state.update_data(
        settings_chat_id=chat_id, settings_message_id=message_id, in_settings=True
    )


async def _set_current_screen(state: FSMContext, screen_id: str) -> None:
    await state.update_data(settings_current_screen=screen_id, in_settings=True)


async def _reset_navigation(state: FSMContext, current_screen: str = "st:home") -> None:
    await state.update_data(settings_nav_stack=[], settings_current_screen=current_screen)


async def _push_current_screen(state: FSMContext, next_screen: str) -> None:
    data = await state.get_data()
    current_screen = data.get("settings_current_screen")
    stack = list(data.get("settings_nav_stack") or [])
    if current_screen and current_screen != next_screen:
        if not stack or stack[-1] != current_screen:
            stack.append(current_screen)
    await state.update_data(settings_nav_stack=stack, settings_current_screen=next_screen)


async def _pop_previous_screen(state: FSMContext) -> str | None:
    data = await state.get_data()
    stack = list(data.get("settings_nav_stack") or [])
    if not stack:
        return None
    previous = stack.pop()
    await state.update_data(settings_nav_stack=stack, settings_current_screen=previous)
    return previous


async def _send_and_register(
    *, message: Message, state: FSMContext, text: str, reply_markup=None
) -> Message:
    sent = await message.answer(text, reply_markup=reply_markup)
    await ui_register_message(state, sent.chat.id, sent.message_id)
    return sent


async def _send_main_menu_summary(
    *, bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    db = FinanceDatabase()
    savings = db.get_user_savings(user_id)
    summary = format_savings_summary(savings)
    text = f"Текущие накопления:\n{summary}"
    menu = await build_main_menu_for_user(user_id)
    sent = await bot.send_message(chat_id=chat_id, text=text, reply_markup=menu)
    await ui_register_message(state, sent.chat.id, sent.message_id)


async def _exit_settings_to_main(
    *, bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    await ui_cleanup_messages(bot, state, chat_id=chat_id)
    await state.clear()
    await ui_render_screen(
        bot,
        state,
        chat_id,
        "Главное меню",
        reply_markup=await build_main_menu_for_user(user_id),
    )


async def _get_settings_message_ids(
    state: FSMContext, fallback_message: Message
) -> tuple[int, int]:
    data = await state.get_data()
    chat_id = data.get("settings_chat_id") or fallback_message.chat.id
    message_id = data.get("settings_message_id") or fallback_message.message_id
    return int(chat_id), int(message_id)


async def _edit_settings_page(
    *,
    bot,
    state: FSMContext,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup,
) -> int:
    try:
        data = await state.get_data()
        if data.get("settings_current_screen") in {"st:income", "st:wishlist", "st:byt_rules"}:
            raise TelegramBadRequest(method="editMessageText", message="reply-only")
        await bot.edit_message_text(
            chat_id=chat_id, message_id=message_id, text=text, reply_markup=reply_markup
        )
        new_message_id = message_id
    except TelegramBadRequest:
        new_message = await bot.send_message(
            chat_id=chat_id, text=text, reply_markup=reply_markup
        )
        new_message_id = new_message.message_id
        await ui_register_message(state, chat_id, new_message_id)
    await ui_set_screen_message(state, chat_id, new_message_id)
    await _store_settings_message(state, chat_id, new_message_id)
    return new_message_id


async def _render_reply_settings_page(
    *,
    message: Message,
    state: FSMContext,
    text: str,
    reply_markup: ReplyKeyboardMarkup,
    screen_id: str,
    force_new: bool = False,
) -> None:
    data = await state.get_data()
    chat_id = data.get("settings_chat_id")
    message_id = data.get("settings_message_id")
    current_screen = data.get("settings_current_screen")

    deleted_count = 0
    if force_new or not chat_id or not message_id or current_screen != screen_id:
        await _delete_message_safely(message.bot, chat_id, message_id)
        if message_id:
            deleted_count = 1
    sent = await message.bot.send_message(
        chat_id=message.chat.id, text=text, reply_markup=reply_markup
    )
    new_message_id = sent.message_id
    await ui_register_message(state, sent.chat.id, sent.message_id)
    await ui_set_screen_message(state, sent.chat.id, sent.message_id)
    await _store_settings_message(state, sent.chat.id, sent.message_id)
    await _set_current_screen(state, screen_id)
    if deleted_count:
        LOGGER.info(
            "Settings reply screen cleanup: deleted %s messages (screen_id=%s)",
            deleted_count,
            screen_id,
        )


async def _render_settings_home(message: Message, state: FSMContext) -> None:
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="⚙️ НАСТРОЙКИ",
        reply_markup=settings_home_reply_keyboard(),
        screen_id="st:home",
        force_new=True,
    )


def _format_household_payments_text(
    items: list[dict], *, unpaid_set: set[str], error_message: str | None = None
) -> str:
    lines: list[str] = ["РЕЖИМ НАСТРОЕК", "", "Бытовые платежи", ""]
    if not items:
        lines.append("Платежей пока нет. Нажми ➕ Добавить")
    else:
        for item in items:
            title = str(item.get("text", "")).rstrip("?")
            amount = item.get("amount")
            prefix = "❌" if item.get("code") in unpaid_set else "✅"
            if amount not in (None, 0):
                lines.append(f"{prefix} {title} — {amount}")
            else:
                lines.append(f"{prefix} {title}")
    if error_message:
        lines.extend(["", error_message])
    return "\n".join(lines)


async def _render_household_payments_settings(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    error_message: str | None = None,
    force_new_keyboard: bool = False,
) -> None:
    items = db.list_active_household_items(user_id)
    month = current_month_str()
    await db.init_household_questions_for_month(user_id, month)
    unpaid = await db.get_unpaid_household_questions(user_id, month)
    unpaid_set: set[str] = set(unpaid)
    LOGGER.info(
        "Open household payments settings (user_id=%s, month=%s, items_count=%s, unpaid_count=%s)",
        user_id,
        month,
        len(items),
        len(unpaid_set),
    )
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_household_payments_text(
            items, unpaid_set=unpaid_set, error_message=error_message
        ),
        reply_markup=household_settings_reply_keyboard(),
        screen_id="st:household_payments",
        force_new=True,
    )


async def _render_household_delete_menu(
    *, state: FSMContext, message: Message, db: FinanceDatabase, user_id: int
) -> None:
    items = db.list_active_household_items(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="Что удалить?" if items else "Активных платежей нет.",
        reply_markup=household_payments_remove_reply_keyboard(items)
        if items
        else household_settings_reply_keyboard(),
        screen_id="hp:del_payment_menu",
        force_new=True,
    )
    await state.update_data(
        hp_delete_map={
            (f"{str(item.get('text', ''))}".rstrip("?")
             + (f" — {item.get('amount')}" if item.get("amount") is not None else "")
            ): item.get("code")
            for item in items
        }
    )
    if items:
        await state.set_state(HouseholdSettingsState.waiting_for_removal)


def _format_category_text(
    title: str, categories: list[dict], error_message: str | None = None
) -> str:
    lines: list[str] = [title, ""]
    for category in categories:
        lines.append(f"{category['title']} — {category['percent']}%")
    total = sum(category.get("percent", 0) for category in categories)
    lines.append("")
    lines.append(f"Сумма: {total}%")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


def _format_wishlist_text(
    categories: list[dict], error_message: str | None = None
) -> str:
    lines: list[str] = ["🧾 ВИШЛИСТ — настройки", "", "Категории:", ""]
    if categories:
        for category in categories:
            mode = str(category.get("purchased_mode") or "days")
            days = int(category.get("purchased_days") or 30)
            if mode == "always":
                display = "Всегда"
            else:
                display = f"{days} дней"
            lines.append(f"{category.get('title', '')} — Купленное: {display}")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


def _format_byt_rules_text(
    settings: dict, times: list[dict], error_message: str | None = None
) -> str:
    on_off = {True: "ДА", False: "НЕТ", 1: "ДА", 0: "НЕТ"}
    lines = [
        "🧺 БЫТ — условия напоминаний",
        "",
        f"Напоминания включены: {on_off.get(settings.get('byt_reminders_enabled', 1), 'НЕТ')}",
        "Слать если список пуст: НЕТ",
        'Формат: "Что ты купил?" (кнопки-товары)',
        f"ОТЛОЖИТЬ: {on_off.get(settings.get('byt_defer_enabled', 1), 'НЕТ')}",
        f"Макс. дней отложить: {settings.get('byt_defer_max_days', 365)}",
        "",
        "Таймер:",
        "",
    ]
    if times:
        for timer in times:
            lines.append(
                f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
            )
    else:
        lines.append("(пусто)")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


def _format_byt_timer_text(times: list[dict], error_message: str | None = None) -> str:
    lines = ["⏰ БЫТ — таймер напоминаний", "Текущие времена:", ""]
    if times:
        for timer in times:
            lines.append(f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}")
    else:
        lines.append("(пусто)")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


async def _render_income_settings(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    error_message: str | None = None,
) -> list[dict]:
    db.ensure_income_categories_seeded(user_id)
    categories = db.list_active_income_categories(user_id)
    LOGGER.info("Open income settings (reply mode) user_id=%s", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_category_text(
            "📊 ДОХОД — категории и проценты", categories, error_message
        ),
        reply_markup=income_settings_reply_keyboard(),
        screen_id="st:income",
    )
    return categories


async def _render_wishlist_settings(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    error_message: str | None = None,
) -> list[dict]:
    db.ensure_wishlist_categories_seeded(user_id)
    categories = db.list_active_wishlist_categories(user_id)
    LOGGER.info("Open wishlist settings (reply mode) user_id=%s", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_wishlist_text(categories, error_message),
        reply_markup=wishlist_settings_reply_keyboard(),
        screen_id="st:wishlist",
    )
    return categories


async def _render_byt_rules_settings(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    error_message: str | None = None,
) -> dict:
    db.ensure_user_settings(user_id)
    settings_row = db.get_user_settings(user_id)
    db.ensure_byt_timer_defaults(user_id)
    times = db.list_active_byt_timer_times(user_id)
    LOGGER.info("Open byt conditions settings (reply mode) user_id=%s", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_byt_rules_text(settings_row, times, error_message),
        reply_markup=byt_rules_reply_keyboard(),
        screen_id="st:byt_rules",
    )
    return settings_row


async def _render_byt_timer_settings(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    error_message: str | None = None,
) -> list[dict]:
    db.ensure_byt_timer_defaults(user_id)
    times = db.list_active_byt_timer_times(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_byt_timer_text(times, error_message),
        reply_markup=byt_timer_reply_keyboard(),
        screen_id="byt:timer_menu",
    )
    return times


async def _render_income_delete_menu(
    *, state: FSMContext, message: Message, db: FinanceDatabase, user_id: int
) -> None:
    categories = db.list_active_income_categories(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="Что удалить?" if categories else "Категорий пока нет.",
        reply_markup=income_categories_select_reply_keyboard(categories)
        if categories
        else income_settings_reply_keyboard(),
        screen_id="inc:del_menu",
        force_new=True,
    )
    await state.update_data(
        inc_delete_map={
            f"{category.get('title', '')} — {category.get('percent', 0)}%": category.get(
                "id"
            )
            for category in categories
        }
    )
    if categories:
        await state.set_state(IncomeSettingsState.waiting_for_removal)


async def _render_income_percent_menu(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    error_message: str | None = None,
) -> None:
    categories = db.list_active_income_categories(user_id)
    if categories:
        text = "Какой категории меняем процент?"
        if error_message:
            text = f"{error_message}\n\n{text}"
    else:
        text = "Категорий пока нет."
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=text,
        reply_markup=income_categories_select_reply_keyboard(categories)
        if categories
        else income_settings_reply_keyboard(),
        screen_id="inc:pct_menu",
        force_new=True,
    )
    await state.update_data(
        inc_percent_map={
            f"{category.get('title', '')} — {category.get('percent', 0)}%": category.get(
                "id"
            )
            for category in categories
        }
    )
    if categories:
        await state.set_state(IncomeSettingsState.waiting_for_percent_category)


async def _render_wishlist_delete_menu(
    *, state: FSMContext, message: Message, db: FinanceDatabase, user_id: int
) -> None:
    categories = db.list_active_wishlist_categories(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="Что удалить?" if categories else "Категорий пока нет.",
        reply_markup=wishlist_categories_select_reply_keyboard(categories)
        if categories
        else wishlist_settings_reply_keyboard(),
        screen_id="wl:del_cat_menu",
        force_new=True,
    )
    await state.update_data(
        wl_delete_map={category.get("title", ""): category.get("id") for category in categories}
    )
    if categories:
        await state.set_state(WishlistSettingsState.waiting_for_removal)


async def _render_wishlist_purchased_select_menu(
    *, state: FSMContext, message: Message, db: FinanceDatabase, user_id: int
) -> None:
    categories = db.list_active_wishlist_categories(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="Выбери категорию вишлиста для настройки срока купленного"
        if categories
        else "Категорий пока нет.",
        reply_markup=wishlist_categories_select_reply_keyboard(categories)
        if categories
        else wishlist_settings_reply_keyboard(),
        screen_id="wl:purchased_select_category",
        force_new=True,
    )
    await state.update_data(
        wl_purchased_map={
            category.get("title", ""): category.get("id") for category in categories
        }
    )
    if categories:
        await state.set_state(WishlistSettingsState.waiting_for_purchased_category)


async def _render_wishlist_purchased_mode(
    *,
    state: FSMContext,
    message: Message,
    db: FinanceDatabase,
    user_id: int,
    category_id: int,
) -> None:
    category = db.get_wishlist_category_by_id(user_id, category_id)
    await state.set_state(WishlistSettingsState.waiting_for_purchased_mode)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=(
            f'⏳ Купленное — "{category.get("title", "")}"\nКак показывать купленное?'
        ),
        reply_markup=wishlist_purchased_mode_reply_keyboard(),
        screen_id="wl:purchased_mode",
        force_new=True,
    )


async def _render_byt_timer_delete_menu(
    *, state: FSMContext, message: Message, db: FinanceDatabase, user_id: int
) -> None:
    times = db.list_active_byt_timer_times(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="Что удалить?" if times else "Времена пока не заданы.",
        reply_markup=byt_timer_times_select_reply_keyboard(times)
        if times
        else byt_timer_reply_keyboard(),
        screen_id="bt:del_time_menu",
        force_new=True,
    )
    await state.update_data(
        bt_delete_map={
            f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}": timer.get(
                "id"
            )
            for timer in times
        }
    )
    if times:
        await state.set_state(BytTimerState.waiting_for_removal)


async def render_settings_screen(
    screen_id: str,
    *,
    message: Message,
    state: FSMContext,
    error_message: str | None = None,
    force_new: bool = False,
) -> None:
    db = FinanceDatabase()
    data = await state.get_data()
    user_id = message.from_user.id
    if message.from_user.id == message.bot.id:
        user_id = data.get("settings_user_id") or message.from_user.id
    if screen_id == "st:home":
        await _render_settings_home(message, state)
    elif screen_id == "st:income":
        await _render_income_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "inc:del_menu":
        await _render_income_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "inc:pct_menu":
        await _render_income_percent_menu(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "st:wishlist":
        await _render_wishlist_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "st:household_payments":
        await _render_household_payments_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
            force_new_keyboard=force_new,
        )
    elif screen_id == "wl:del_cat_menu":
        await _render_wishlist_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "wl:purchased_select_category":
        await _render_wishlist_purchased_select_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "wl:purchased_mode":
        data = await state.get_data()
        category_id = data.get("editing_wl_category_id")
        if category_id is not None:
            await _render_wishlist_purchased_mode(
                state=state,
                message=message,
                db=db,
                user_id=user_id,
                category_id=int(category_id),
            )
        else:
            await _render_wishlist_settings(
                state=state,
                message=message,
                db=db,
                user_id=user_id,
            )
    elif screen_id == "st:byt_rules":
        await _render_byt_rules_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "byt:timer_menu":
        await _render_byt_timer_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "bt:del_time_menu":
        await _render_byt_timer_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "hp:del_payment_menu":
        await _render_household_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    else:
        await _render_settings_home(message, state)
    await _set_current_screen(state, screen_id)


async def _navigate_to_screen(
    screen_id: str,
    *,
    message: Message,
    state: FSMContext,
    error_message: str | None = None,
    force_new: bool = False,
) -> None:
    await _push_current_screen(state, screen_id)
    await render_settings_screen(
        screen_id,
        message=message,
        state=state,
        error_message=error_message,
        force_new=force_new,
    )


async def _render_previous_screen_or_exit(
    message: Message, state: FSMContext
) -> None:
    previous = await _pop_previous_screen(state)
    if previous:
        await render_settings_screen(previous, message=message, state=state)
    else:
        await _exit_settings_to_main(
            bot=message.bot,
            state=state,
            chat_id=message.chat.id,
            user_id=message.from_user.id,
        )


async def handle_settings_back_action(message: Message, state: FSMContext) -> None:
    current_state = await state.get_state()
    data = await state.get_data()

    await _register_user_message(state, message)
    await _delete_user_message(message)

    numeric_cleanup_map = {
        IncomeSettingsState.waiting_for_percent.state: {
            "display_chat_key": "percent_display_chat_id",
            "display_message_key": "percent_display_message_id",
        },
        IncomeSettingsState.waiting_for_new_category_percent.state: {
            "display_chat_key": "new_income_display_chat_id",
            "display_message_key": "new_income_display_message_id",
        },
        WishlistSettingsState.waiting_for_purchased_days.state: {
            "display_chat_key": "purchased_display_chat_id",
            "display_message_key": "purchased_display_message_id",
        },
        HouseholdSettingsState.waiting_for_amount.state: {
            "display_chat_key": "hp_amount_display_chat_id",
            "display_message_key": "hp_amount_display_message_id",
        },
        BytSettingsState.waiting_for_max_defer_days.state: {
            "display_chat_key": "byt_max_display_chat_id",
            "display_message_key": "byt_max_display_message_id",
        },
        BytTimerState.waiting_for_hour.state: {
            "display_chat_key": "bt_hour_display_chat_id",
            "display_message_key": "bt_hour_display_message_id",
        },
        BytTimerState.waiting_for_minute.state: {
            "display_chat_key": "bt_min_display_chat_id",
            "display_message_key": "bt_min_display_message_id",
            "prompt_chat_key": "bt_min_prompt_chat_id",
            "prompt_message_key": "bt_min_prompt_message_id",
        },
    }

    cleanup_params = numeric_cleanup_map.get(current_state)
    if cleanup_params:
        await _cleanup_input_ui(message.bot, data, **cleanup_params)
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    await state.set_state(None)
    await _render_previous_screen_or_exit(message, state)


@router.message(F.text == "⚙️")
async def open_settings(message: Message, state: FSMContext) -> None:
    """Open settings entry point with inline navigation."""

    await ui_track_message(state, message.chat.id, message.message_id)
    await _delete_user_message(message)
    await ui_cleanup_to_context(message.bot, state, message.chat.id, "SETTINGS_MENU")
    await state.update_data(settings_user_id=message.from_user.id)
    screen_id = await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "⚙️ НАСТРОЙКИ",
        reply_markup=settings_home_reply_keyboard(),
    )
    await _store_settings_message(state, message.chat.id, screen_id)
    await _set_current_screen(state, "st:home")
    await _reset_navigation(state)


@router.callback_query(F.data == "st:home")
async def back_to_settings_home(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _reset_navigation(state)
    await render_settings_screen("st:home", message=callback.message, state=state)


@router.message(F.text == "⚙️ НАСТРОЙКИ")
async def back_to_settings_home_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _reset_navigation(state)
    await render_settings_screen("st:home", message=message, state=state)


@router.callback_query(F.data == "st:income")
async def open_income_settings(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:income", message=callback.message, state=state)


@router.message(F.text == "📊 Доход")
async def open_income_settings_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("st:income", message=message, state=state)


@router.message(F.text.in_({"Назад", "⬅ Назад", "⬅️ Назад"}))
async def settings_exit_via_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await handle_settings_back_action(message, state)


@router.callback_query(F.data == "st:wishlist")
async def open_wishlist(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:wishlist", message=callback.message, state=state)


@router.message(F.text == "🧾 Вишлист")
async def open_wishlist_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("st:wishlist", message=message, state=state)


@router.callback_query(F.data == "st:household_payments")
async def open_household_payments(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen(
        "st:household_payments", message=callback.message, state=state, force_new=True
    )


@router.message(F.text == "🧾 Бытовые платежи")
async def open_household_payments_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "st:household_payments", message=message, state=state, force_new=True
    )


@router.message(F.text == "🧺 БЫТ условия")
async def open_byt_rules_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "➕ Добавить")
async def household_payment_add_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "hp:add_payment")
    await state.set_state(HouseholdSettingsState.waiting_for_title)
    await state.update_data(hp_amount_str="0", hp_new_title=None)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Напиши платёж",
        reply_markup=back_only_keyboard(),
    )


@router.message(F.text == "➖ Удалить")
async def household_payment_delete_menu_reply(
    message: Message, state: FSMContext
) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "hp:del_payment_menu", message=message, state=state, force_new=True
    )


@router.message(F.text == "🧹 Обнулить")
async def household_reset_questions_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    db = FinanceDatabase()
    month = current_month_str()
    await db.reset_household_questions_for_month(message.from_user.id, month)
    LOGGER.info(
        "Reset household payment statuses (user_id=%s, month=%s)",
        message.from_user.id,
        month,
    )
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=False
    )


@router.message(F.text == "🔄 Обновить")
async def household_refresh_questions_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=True
    )


@router.message(
    InSettingsFilter(),
    F.text.in_(
        {
            "➕",
            "➕ Добавить категорию дохода",
            "➕ Добавить категорию вишлиста",
            "➕ Добавить время напоминания",
        }
    ),
)
async def settings_add_action_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    screen = data.get("settings_current_screen")
    if screen not in {"st:income", "st:wishlist", "st:byt_rules"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)

    if screen == "st:income":
        await _push_current_screen(state, "inc:add_category")
        await state.set_state(IncomeSettingsState.waiting_for_category_title)
        prompt = "Название новой категории дохода?"
        next_screen = "inc:add_category"
    elif screen == "st:wishlist":
        await _push_current_screen(state, "wl:add_category")
        await state.set_state(WishlistSettingsState.waiting_for_category_title)
        prompt = "Название новой категории вишлиста?"
        next_screen = "wl:add_category"
    else:
        await _push_current_screen(state, "bt:add_time_text")
        await state.set_state(BytTimerState.waiting_for_time_add)
        prompt = "Введи время в формате ЧЧ:ММ (например 12:00)"
        next_screen = "bt:add_time_text"

    await _render_reply_settings_page(
        message=message,
        state=state,
        text=prompt,
        reply_markup=back_only_keyboard(),
        screen_id=next_screen,
        force_new=True,
    )


@router.message(
    InSettingsFilter(),
    F.text.in_(
        {
            "➖",
            "➖ Удалить категорию дохода",
            "➖ Удалить категорию вишлиста",
            "➖ Удалить время напоминания",
        }
    ),
)
async def settings_delete_action_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    screen = data.get("settings_current_screen")
    if screen not in {"st:income", "st:wishlist", "st:byt_rules"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)

    if screen == "st:income":
        await _navigate_to_screen("inc:del_menu", message=message, state=state, force_new=True)
        return
    if screen == "st:wishlist":
        await _navigate_to_screen("wl:del_cat_menu", message=message, state=state, force_new=True)
        return
    await _navigate_to_screen("bt:del_time_menu", message=message, state=state, force_new=True)


@router.message(F.text.in_({"%", "⚙️ Проценты доходов"}))
async def income_percent_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    if data.get("settings_current_screen") != "st:income":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)

    db = FinanceDatabase()
    total = db.sum_income_category_percents(message.from_user.id)
    if total == 100:
        await render_settings_screen(
            "st:income",
            message=message,
            state=state,
            error_message="Сумма процентов 100%. ОК.",
        )
        return

    await _navigate_to_screen(
        "inc:pct_menu",
        message=message,
        state=state,
        force_new=True,
        error_message=f"Сумма процентов сейчас {total}%. Нужно 100%.",
    )


@router.message(F.text == "🕒 Настроить купленное")
async def wishlist_purchased_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    if data.get("settings_current_screen") != "st:wishlist":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "wl:purchased_select_category", message=message, state=state, force_new=True
    )


@router.message(F.text == "🔁 Вкл/Выкл напоминания")
async def byt_toggle_enabled_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(message.from_user.id)
    current = bool(settings_row.get("byt_reminders_enabled", 1))
    db.set_byt_reminders_enabled(message.from_user.id, not current)
    await render_settings_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "🔁 ОТЛОЖИТЬ Вкл/Выкл")
async def byt_toggle_defer_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(message.from_user.id)
    current = bool(settings_row.get("byt_defer_enabled", 1))
    db.set_byt_defer_enabled(message.from_user.id, not current)
    await render_settings_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "⏳ Макс. дни отложить")
async def edit_byt_max_defer_days_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "byt:edit_max_defer_days")
    await state.set_state(BytSettingsState.waiting_for_max_defer_days)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(message.from_user.id)
    await state.update_data(
        byt_max_days_str="0",
        previous_byt_max_days=settings_row.get("byt_defer_max_days", 365),
    )
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Максимум дней отложки?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        byt_max_display_chat_id=prompt.chat.id,
        byt_max_display_message_id=prompt.message_id,
    )


@router.message(F.text.in_({"⏰ Таймер", "⏱ Таймер"}))
async def open_byt_timer_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("byt:timer_menu", message=message, state=state)


@router.message(F.text == "⚙ Условия")
async def open_byt_rules_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") not in {"st:byt_rules", "byt:timer_menu"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    if data.get("settings_current_screen") == "st:byt_rules":
        await render_settings_screen("st:byt_rules", message=message, state=state)
        return
    await _navigate_to_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "➕ Добавить время")
async def byt_timer_add_hour_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "bt:add_time_hour")
    await state.set_state(BytTimerState.waiting_for_hour)
    await state.update_data(bt_hour_str="0")
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Введи ЧАС (0–23)",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        bt_hour_display_chat_id=prompt.chat.id,
        bt_hour_display_message_id=prompt.message_id,
    )


@router.message(F.text == "➖ Удалить время")
async def byt_timer_delete_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("bt:del_time_menu", message=message, state=state, force_new=True)


@router.message(F.text == "🔁 Сбросить по умолчанию")
async def byt_timer_reset_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    db = FinanceDatabase()
    db.reset_byt_timer_times(message.from_user.id)
    await render_settings_screen("byt:timer_menu", message=message, state=state)

@router.callback_query(F.data == "st:byt_rules")
async def open_byt_rules(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:byt_rules", message=callback.message, state=state)


@router.callback_query(F.data == "byt:toggle_enabled")
async def toggle_byt_enabled(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    current = bool(settings_row.get("byt_reminders_enabled", 1))
    db.set_byt_reminders_enabled(callback.from_user.id, not current)
    await render_settings_screen(
        "st:byt_rules", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:toggle_defer")
async def toggle_byt_defer(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    current = bool(settings_row.get("byt_defer_enabled", 1))
    db.set_byt_defer_enabled(callback.from_user.id, not current)
    await render_settings_screen(
        "st:byt_rules", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:edit_max_defer_days")
async def edit_byt_max_defer_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "byt:edit_max_defer_days")
    await state.set_state(BytSettingsState.waiting_for_max_defer_days)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    await state.update_data(
        byt_max_days_str="0", previous_byt_max_days=settings_row.get("byt_defer_max_days", 365)
    )
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Максимум дней отложки?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        byt_max_display_chat_id=prompt.chat.id,
        byt_max_display_message_id=prompt.message_id,
    )


@router.callback_query(F.data == "bt:add_time_hour")
async def byt_timer_add_hour(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "bt:add_time_hour")
    await state.set_state(BytTimerState.waiting_for_hour)
    await state.update_data(bt_hour_str="0")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Введи ЧАС (0–23)",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        bt_hour_display_chat_id=prompt.chat.id,
        bt_hour_display_message_id=prompt.message_id,
    )


@router.callback_query(F.data == "bt:del_time_menu")
async def byt_timer_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("bt:del_time_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("bt:del_time:"))
async def byt_timer_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        timer_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    times = db.list_active_byt_timer_times(callback.from_user.id)
    if len(times) <= 1:
        await _render_byt_timer_settings(
            state=state,
            message=callback.message,
            db=db,
            user_id=callback.from_user.id,
            error_message="Нельзя удалить последнее время.",
        )
        return

    db.deactivate_byt_timer_time(callback.from_user.id, timer_id)
    await _render_byt_timer_settings(
        state=state, message=callback.message, db=db, user_id=callback.from_user.id
    )


@router.callback_query(F.data == "bt:reset_default")
async def byt_timer_reset(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    db = FinanceDatabase()
    db.reset_byt_timer_times(callback.from_user.id)
    await render_settings_screen(
        "byt:timer_menu", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:timer_menu")
async def open_byt_timer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("byt:timer_menu", message=callback.message, state=state)


@router.message(HouseholdSettingsState.waiting_for_removal)
async def household_payment_delete_choice(
    message: Message, state: FSMContext
) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    mapping: dict[str, str] = data.get("hp_delete_map") or {}
    choice = (message.text or "").strip()
    if choice in {"⬅ Назад", "⬅️ Назад"}:
        await state.set_state(None)
        await render_settings_screen(
            "st:household_payments", message=message, state=state, force_new=False
        )
        return

    code = mapping.get(choice)
    if not code:
        await _send_and_register(
            message=message,
            state=state,
            text="Выбери платеж из списка.",
        )
        return

    db = FinanceDatabase()
    db.deactivate_household_payment_item(message.from_user.id, code)
    await db.init_household_questions_for_month(
        message.from_user.id, current_month_str()
    )
    LOGGER.info(
        "Deleted household payment item (user_id=%s, code=%s)",
        message.from_user.id,
        code,
    )
    await state.set_state(None)
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=False
    )


@router.message(IncomeSettingsState.waiting_for_removal)
async def income_category_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "⬅ Назад":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("inc_delete_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "inc:del_menu",
            message=message,
            state=state,
            error_message="Выбери категорию из списка.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    categories = db.list_active_income_categories(message.from_user.id)
    if len([cat for cat in categories if cat.get("is_active", 1)]) <= 1:
        await state.set_state(None)
        await render_settings_screen(
            "st:income",
            message=message,
            state=state,
            error_message="Нельзя удалить последнюю категорию.",
        )
        return

    db.deactivate_income_category(message.from_user.id, category_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:income"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(IncomeSettingsState.waiting_for_percent_category)
async def income_category_percent_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "⬅ Назад":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("inc_percent_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "inc:pct_menu",
            message=message,
            state=state,
            error_message="Выбери категорию из списка.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    category = db.get_income_category_by_id(message.from_user.id, category_id)
    if not category:
        await state.set_state(None)
        await render_settings_screen("st:income", message=message, state=state)
        return

    await _push_current_screen(state, "inc:pct_input")
    await state.update_data(
        edit_scope="income",
        editing_category_id=category_id,
        previous_percent=category.get("percent", 0),
        percent_str="0",
    )
    await state.set_state(IncomeSettingsState.waiting_for_percent)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f"Введи процент (0–100) для: {category['title']}",
        reply_markup=None,
    )
    percent_message = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        percent_display_chat_id=percent_message.chat.id,
        percent_display_message_id=percent_message.message_id,
    )
    LOGGER.info(
        "Percent edit start: user=%s scope=%s category_id=%s",
        message.from_user.id,
        "income",
        category_id,
    )


@router.message(WishlistSettingsState.waiting_for_removal)
async def wishlist_category_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "⬅ Назад":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("wl_delete_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "wl:del_cat_menu",
            message=message,
            state=state,
            error_message="Выбери категорию из списка.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    categories = db.list_active_wishlist_categories(message.from_user.id)
    if len(categories) <= 1:
        await state.set_state(None)
        await render_settings_screen(
            "st:wishlist",
            message=message,
            state=state,
            error_message="Нельзя удалить последнюю категорию.",
        )
        return

    db.deactivate_wishlist_category(message.from_user.id, category_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_category)
async def wishlist_purchased_category_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "⬅ Назад":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("wl_purchased_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "wl:purchased_select_category",
            message=message,
            state=state,
            error_message="Выбери категорию из списка.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    category = db.get_wishlist_category_by_id(message.from_user.id, category_id)
    if not category or not category.get("is_active", 1):
        await state.set_state(None)
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    await _push_current_screen(state, "wl:purchased_mode")
    await state.update_data(editing_wl_category_id=category_id)
    await state.set_state(WishlistSettingsState.waiting_for_purchased_mode)
    await _navigate_to_screen(
        "wl:purchased_mode", message=message, state=state, force_new=True
    )


@router.message(WishlistSettingsState.waiting_for_purchased_mode)
async def wishlist_purchased_mode_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "⬅ Назад":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await state.set_state(None)
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    db = FinanceDatabase()
    if choice == "Всегда":
        db.update_wishlist_category_purchased_mode(
            message.from_user.id, int(category_id), "always"
        )
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=message, state=state)
        return
    if choice != "Настроить дни":
        await render_settings_screen(
            "wl:purchased_mode",
            message=message,
            state=state,
            error_message="Выбери вариант из списка.",
            force_new=True,
        )
        return

    category = db.get_wishlist_category_by_id(message.from_user.id, int(category_id))
    if not category:
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(
        message.from_user.id, int(category_id), "days"
    )
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'На сколько дней показывать купленное для "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(BytTimerState.waiting_for_removal)
async def byt_timer_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "⬅ Назад":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("bt_delete_map") or {}
    timer_id = mapping.get(choice)
    if not timer_id:
        await render_settings_screen(
            "bt:del_time_menu",
            message=message,
            state=state,
            error_message="Выбери время из списка.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    times = db.list_active_byt_timer_times(message.from_user.id)
    if len(times) <= 1:
        await state.set_state(None)
        await _render_byt_timer_settings(
            state=state,
            message=message,
            db=db,
            user_id=message.from_user.id,
            error_message="Нельзя удалить последнее время.",
        )
        return

    db.deactivate_byt_timer_time(message.from_user.id, timer_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(BytTimerState.waiting_for_time_add)
async def byt_timer_add_time_value(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    text = (message.text or "").strip()
    parsed = _parse_time_text(text)
    if not parsed:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Нужно ввести время в формате ЧЧ:ММ.",
            reply_markup=None,
        )
        return

    hour, minute = parsed
    db = FinanceDatabase()
    db.add_byt_timer_time(message.from_user.id, hour, minute)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
    await render_settings_screen(previous_screen, message=message, state=state)

@router.callback_query(F.data == "inc:add")
async def category_add(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "inc:add_category")
    await state.set_state(IncomeSettingsState.waiting_for_category_title)
    await state.update_data(category_scope="income")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Введи название новой категории",
        reply_markup=None,
    )


@router.callback_query(F.data == "wl:add_cat")
async def wishlist_category_add(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "wl:add_category")
    await state.set_state(WishlistSettingsState.waiting_for_category_title)
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Введи название категории",
        reply_markup=None,
    )


@router.message(IncomeSettingsState.waiting_for_category_title)
async def income_add_category_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    title = (message.text or "").strip()
    if not title or len(title) > 32:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Название должно быть от 1 до 32 символов.",
            reply_markup=None,
        )
        return

    await state.update_data(new_income_category_title=title, new_income_percent_str="0")
    await state.set_state(IncomeSettingsState.waiting_for_new_category_percent)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="Процент для категории?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        new_income_display_chat_id=prompt.chat.id,
        new_income_display_message_id=prompt.message_id,
    )


@router.message(WishlistSettingsState.waiting_for_category_title)
async def wishlist_add_category_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    title = (message.text or "").strip()
    if not title or len(title) > 32:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Название должно быть от 1 до 32 символов.",
            reply_markup=None,
        )
        return

    db = FinanceDatabase()
    db.create_wishlist_category(message.from_user.id, title)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(
    IncomeSettingsState.waiting_for_new_category_percent, F.text.in_(PERCENT_INPUT_BUTTONS)
)
async def income_new_category_percent(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Используй кнопки калькулятора.",
            reply_markup=None,
        )
        return

    percent_str = data.get("new_income_percent_str", "0")
    display_chat_id = data.get("new_income_display_chat_id", message.chat.id)
    display_message_id = data.get("new_income_display_message_id")

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(
                chat_id=display_chat_id, text=f": {percent_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            new_income_percent_str=percent_str,
            new_income_display_chat_id=display_chat_id,
            new_income_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        percent_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            new_income_percent_str=percent_str,
            new_income_display_chat_id=display_chat_id,
            new_income_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "Процент должен быть числом."
            percent = 0
        else:
            if percent < 0 or percent > 100:
                error_message = "Процент должен быть в диапазоне 0–100."

        title = (data.get("new_income_category_title") or "").strip()
        if not title:
            error_message = error_message or "Название категории не задано."

        if error_message is None:
            db = FinanceDatabase()
            category_id = db.create_income_category(message.from_user.id, title)
            if category_id is not None:
                db.update_income_category_percent(
                    message.from_user.id, category_id, percent
                )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="new_income_display_chat_id",
            display_message_key="new_income_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(
            previous_screen, message=message, state=state, error_message=error_message
        )


@router.message(HouseholdSettingsState.waiting_for_title)
async def household_payment_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    title = (message.text or "").strip()
    if not title:
        await _send_and_register(
            message=message,
            state=state,
            text="Нужно ввести название платежа.",
        )
        return

    await state.update_data(hp_new_title=title, hp_amount_str="0")
    await state.set_state(HouseholdSettingsState.waiting_for_amount)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f'Сколько платить за "{title}"?',
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        hp_amount_display_chat_id=prompt.chat.id,
        hp_amount_display_message_id=prompt.message_id,
    )


@router.message(
    HouseholdSettingsState.waiting_for_amount, F.text.in_(PERCENT_INPUT_BUTTONS)
)
async def household_payment_amount(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    amount_str = data.get("hp_amount_str", "0")
    display_chat_id = data.get("hp_amount_display_chat_id", message.chat.id)
    display_message_id = data.get("hp_amount_display_message_id")

    if text in PERCENT_DIGITS:
        amount_str = amount_str.lstrip("0") if amount_str != "0" else ""
        amount_str = f"{amount_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {amount_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(
                chat_id=display_chat_id, text=f": {amount_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            hp_amount_str=amount_str,
            hp_amount_display_chat_id=display_chat_id,
            hp_amount_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        amount_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            hp_amount_str=amount_str,
            hp_amount_display_chat_id=display_chat_id,
            hp_amount_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        error_message = None
        try:
            amount = int(amount_str or "0")
        except ValueError:
            error_message = "Нужно ввести число."
            amount = 0
        else:
            if amount <= 0:
                error_message = "Сумма должна быть больше нуля."

        title = (data.get("hp_new_title") or "").strip()
        db = FinanceDatabase()

        if not title:
            error_message = error_message or "Название платежа не задано."

        if error_message is None:
            position = db.get_next_household_position(message.from_user.id)
            code = f"custom_{time.time_ns()}"
            text_value = f"{title} {amount}р?"
            db.add_household_payment_item(
                message.from_user.id, code, text_value, amount, position
            )
            await db.init_household_questions_for_month(
                message.from_user.id, current_month_str()
            )
            LOGGER.info(
                "Added household payment item (user_id=%s, code=%s, amount=%s, title=%s)",
                message.from_user.id,
                code,
                amount,
                title,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="hp_amount_display_chat_id",
            display_message_key="hp_amount_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:household_payments"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
            error_message=error_message,
        )


@router.callback_query(F.data == "inc:del_menu")
async def category_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("inc:del_menu", message=callback.message, state=state)


@router.callback_query(F.data == "wl:del_cat_menu")
async def wishlist_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("wl:del_cat_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("inc:del:"))
async def category_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    scope = "income"
    categories = db.list_active_income_categories(callback.from_user.id)
    if len([cat for cat in categories if cat.get("is_active", 1)]) <= 1:
        await render_settings_screen(
            "st:income",
            message=callback.message,
            state=state,
            error_message="Нельзя удалить последнюю категорию.",
        )
        return

    db.deactivate_income_category(callback.from_user.id, category_id)
    previous_screen = await _pop_previous_screen(state) or "st:income"
    await render_settings_screen(previous_screen, message=callback.message, state=state)


@router.callback_query(F.data.startswith("wl:del_cat:"))
async def wishlist_category_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    categories = db.list_active_wishlist_categories(callback.from_user.id)
    if len(categories) <= 1:
        await render_settings_screen(
            "st:wishlist",
            message=callback.message,
            state=state,
            error_message="Нельзя удалить последнюю категорию.",
        )
        return

    db.deactivate_wishlist_category(callback.from_user.id, category_id)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=callback.message, state=state)


@router.callback_query(F.data == "inc:pct_menu")
async def category_percent_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("inc:pct_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("inc:pct:"))
async def category_percent_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    scope = "income"
    category = db.get_income_category_by_id(callback.from_user.id, category_id)
    if not category:
        await _render_income_settings(
            state=state, message=callback.message, db=db, user_id=callback.from_user.id
        )
        return

    await _push_current_screen(state, "inc:pct_input")
    await state.update_data(
        edit_scope=scope,
        editing_category_id=category_id,
        previous_percent=category.get("percent", 0),
        percent_str="0",
    )
    await state.set_state(IncomeSettingsState.waiting_for_percent)
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f"Введи процент (0–100) для: {category['title']}",
        reply_markup=None,
    )

    percent_message = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        percent_display_chat_id=percent_message.chat.id,
        percent_display_message_id=percent_message.message_id,
    )
    LOGGER.info(
        "Percent edit start: user=%s scope=%s category_id=%s",
        callback.from_user.id,
        scope,
        category_id,
    )


@router.callback_query(F.data == "wl:purchased_select_category")
async def wishlist_purchased_select_category(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen(
        "wl:purchased_select_category", message=callback.message, state=state
    )


@router.callback_query(F.data.startswith("wl:purchased_cat:"))
async def wishlist_purchased_category(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    category = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category or not category.get("is_active", 1):
        await render_settings_screen(
            "st:wishlist", message=callback.message, state=state
        )
        return

    await _push_current_screen(state, "wl:purchased_mode")
    await state.update_data(editing_wl_category_id=category_id)
    await _navigate_to_screen(
        "wl:purchased_mode", message=callback.message, state=state
    )


@router.callback_query(F.data == "wl:purchased_mode:always")
async def wishlist_set_purchased_always(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = FinanceDatabase()
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "always")
    await state.set_state(None)
    await _reset_navigation(state, "st:wishlist")
    await render_settings_screen("st:wishlist", message=callback.message, state=state)


@router.callback_query(F.data == "wl:purchased_mode:days")
async def wishlist_set_purchased_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = FinanceDatabase()
    category = db.get_wishlist_category_by_id(callback.from_user.id, int(category_id))
    if not category:
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "days")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'На сколько дней показывать купленное для "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(IncomeSettingsState.waiting_for_percent)
async def income_percent_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Используй кнопки калькулятора.",
            reply_markup=None,
        )
        return

    percent_str = data.get("percent_str", "0")
    display_chat_id = data.get("percent_display_chat_id", message.chat.id)
    display_message_id = data.get("percent_display_message_id")

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        LOGGER.info(
            "Percent input: user=%s scope=%s value=%s",
            message.from_user.id,
            data.get("edit_scope", "income"),
            percent_str,
        )
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(
                chat_id=display_chat_id, text=f": {percent_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        percent_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "Процент должен быть числом."
        else:
            if percent < 0 or percent > 100:
                error_message = "Процент должен быть в диапазоне 0–100."

        category_id = data.get("editing_category_id")
        if category_id is None:
            await state.set_state(None)
            await _cleanup_input_ui(
                message.bot,
                data,
                display_chat_key="percent_display_chat_id",
                display_message_key="percent_display_message_id",
            )
            await _remove_calculator_keyboard(message)
            await _render_previous_screen_or_exit(message, state)
            return

        if error_message is None:
            db = FinanceDatabase()
            db.update_income_category_percent(message.from_user.id, category_id, percent)
            total = db.sum_income_category_percents(message.from_user.id)

            if total == 100:
                LOGGER.info(
                    "Percent saved: user=%s scope=%s category_id=%s value=%s",
                    message.from_user.id,
                    "income",
                    category_id,
                    percent,
                )
            else:
                error_message = f"Сумма процентов сейчас {total}%. Нужно 100%."

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="percent_display_chat_id",
            display_message_key="percent_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        if error_message:
            await state.set_state(IncomeSettingsState.waiting_for_percent_category)
            await _render_income_percent_menu(
                state=state,
                message=message,
                db=FinanceDatabase(),
                user_id=message.from_user.id,
                error_message=error_message,
            )
            return

        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_days)
async def wishlist_purchased_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Используй кнопки калькулятора.",
            reply_markup=None,
        )
        return

    days_str = data.get("purchased_days_str", "0")
    display_chat_id = data.get("purchased_display_chat_id", message.chat.id)
    display_message_id = data.get("purchased_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=f": {days_str}")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        days_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Нужно ввести число дней.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Количество дней должно быть от 1 до 3650.",
                reply_markup=None,
            )
            return

        db = FinanceDatabase()
        category_id = data.get("editing_wl_category_id")
        if category_id is not None:
            db.update_wishlist_category_purchased_days(
                message.from_user.id, int(category_id), days
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="purchased_display_chat_id",
            display_message_key="purchased_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen(
            "st:wishlist", message=message, state=state
        )


@router.message(BytSettingsState.waiting_for_max_defer_days)
async def byt_max_defer_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="Используй кнопки калькулятора.",
            reply_markup=None,
        )
        return

    days_str = data.get("byt_max_days_str", "0")
    display_chat_id = data.get("byt_max_display_chat_id", message.chat.id)
    display_message_id = data.get("byt_max_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=f": {days_str}")
            display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        days_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Нужно ввести число дней.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Количество дней должно быть от 1 до 3650.",
                reply_markup=None,
            )
            return

        db = FinanceDatabase()
        settings_row = db.get_user_settings(message.from_user.id)
        previous_days = settings_row.get("byt_defer_max_days")
        db.set_byt_defer_max_days(message.from_user.id, days)
        LOGGER.info(
            "Updated BYT defer max days for user %s: %s", message.from_user.id, days
        )
        previous_max = data.get("previous_byt_max_days")
        if previous_max is not None and previous_max != days:
            LOGGER.info(
                "Max defer days changed: user=%s from=%s to=%s",
                message.from_user.id,
                previous_max,
                days,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="byt_max_display_chat_id",
            display_message_key="byt_max_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
        )

@router.message(BytTimerState.waiting_for_hour, F.text.in_(PERCENT_INPUT_BUTTONS))
async def byt_timer_hour_input(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    hour_str = data.get("bt_hour_str", "0")
    display_chat_id = data.get("bt_hour_display_chat_id", message.chat.id)
    display_message_id = data.get("bt_hour_display_message_id")

    if text in PERCENT_DIGITS:
        hour_str = hour_str.lstrip("0") if hour_str != "0" else ""
        hour_str = f"{hour_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {hour_str}",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=f": {hour_str}")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_hour_str=hour_str,
            bt_hour_display_chat_id=display_chat_id,
            bt_hour_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        hour_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_hour_str=hour_str,
            bt_hour_display_chat_id=display_chat_id,
            bt_hour_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        try:
            hour = int(hour_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Нужно ввести число.",
                reply_markup=None,
            )
            return
        if hour < 0 or hour > 23:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Часы должны быть 0–23.",
                reply_markup=None,
            )
            return
        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="bt_hour_display_chat_id",
            display_message_key="bt_hour_display_message_id",
        )
        await state.set_state(BytTimerState.waiting_for_minute)
        await state.update_data(selected_hour=hour, bt_minute_str="0")
        await _set_current_screen(state, "bt:add_time_minute")
        prompt_message = await _send_and_register(
            message=message,
            state=state,
            text="Введи МИНУТЫ (0–59)",
        )
        prompt = await _send_and_register(
            message=message,
            state=state,
            text=": 0",
            reply_markup=income_calculator_keyboard(),
        )
        await state.update_data(
            bt_min_prompt_chat_id=prompt_message.chat.id,
            bt_min_prompt_message_id=prompt_message.message_id,
            bt_min_display_chat_id=prompt.chat.id,
            bt_min_display_message_id=prompt.message_id,
        )

@router.message(BytTimerState.waiting_for_minute, F.text.in_(PERCENT_INPUT_BUTTONS))
async def byt_timer_minute_input(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    minute_str = data.get("bt_minute_str", "0")
    display_chat_id = data.get("bt_min_display_chat_id", message.chat.id)
    display_message_id = data.get("bt_min_display_message_id")

    if text in PERCENT_DIGITS:
        minute_str = minute_str.lstrip("0") if minute_str != "0" else ""
        minute_str = f"{minute_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {minute_str}",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=f": {minute_str}")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_minute_str=minute_str,
            bt_min_display_chat_id=display_chat_id,
            bt_min_display_message_id=display_message_id,
        )
        return

    if text == "Очистить":
        minute_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_minute_str=minute_str,
            bt_min_display_chat_id=display_chat_id,
            bt_min_display_message_id=display_message_id,
        )
        return

    if text == "✅ Газ":
        try:
            minute = int(minute_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Нужно ввести число.",
                reply_markup=None,
            )
            return
        if minute < 0 or minute > 59:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="Минуты должны быть 0–59.",
                reply_markup=None,
            )
            return
        db = FinanceDatabase()
        selected_hour = int(data.get("selected_hour", 0))
        db.add_byt_timer_time(message.from_user.id, selected_hour, minute)
        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="bt_min_display_chat_id",
            display_message_key="bt_min_display_message_id",
            prompt_chat_key="bt_min_prompt_chat_id",
            prompt_message_key="bt_min_prompt_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "byt:timer_menu"
        await render_settings_screen(previous_screen, message=message, state=state)

===== Bot/handlers/start.py =====
"""Handlers for start and cancel commands."""
import logging

from aiogram import F, Router
from aiogram.exceptions import TelegramBadRequest
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from Bot.handlers.common import build_main_menu_for_user
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_cleanup_to_context,
    ui_render_screen,
    ui_set_welcome_message,
    ui_track_message,
)

LOGGER = logging.getLogger(__name__)

router = Router()


async def _handle_start_common(message: Message, state: FSMContext) -> None:
    """Shared start logic for /start and "Поехалиии" commands."""

    # ПРИВЕТСТВИЕ (PROTECTED)
    # Это сообщение защищено и НЕ должно удаляться массовыми чистками.
    # Автоматическое удаление запрещено. Удаление допускается только в отдельной задаче
    # после явного подтверждения пользователя.
    greeting = "Поработаем бл"
    await ui_set_welcome_message(message.bot, state, message.chat.id, greeting)
    await ui_cleanup_to_context(
        message.bot, state, message.chat.id, "MAIN_MENU"
    )
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "Главное меню",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "User %s started bot", message.from_user.id if message.from_user else "unknown"
    )


@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext) -> None:
    """Handle /start command."""

    await ui_track_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
    except Exception:  # noqa: BLE001
        LOGGER.warning("Failed to delete /start message", exc_info=True)
    await _handle_start_common(message, state)


@router.message(F.text == "Поехалиии")
async def handle_poehali(message: Message, state: FSMContext) -> None:
    """Handle alternative start phrase."""

    await ui_track_message(state, message.chat.id, message.message_id)
    await _handle_start_common(message, state)


@router.message(Command("cancel"))
async def cmd_cancel(message: Message, state: FSMContext) -> None:
    """Handle /cancel command."""

    await ui_track_message(state, message.chat.id, message.message_id)
    await ui_cleanup_messages(message.bot, state, chat_id=message.chat.id)
    await state.clear()
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "Операция отменена. Вы в главном меню.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info("User %s cancelled current operation", message.from_user.id if message.from_user else "unknown")


@router.message(F.text == "⏪ На главную")
async def back_to_main(message: Message, state: FSMContext) -> None:
    """Return user to main menu."""

    await ui_track_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
        LOGGER.info(
            "Deleted back_to_main user message (chat_id=%s, message_id=%s)",
            message.chat.id,
            message.message_id,
        )
    except TelegramBadRequest as exc:
        LOGGER.warning(
            "Failed to delete back_to_main user message (chat_id=%s, message_id=%s): %s",
            message.chat.id,
            message.message_id,
            exc,
        )
    except Exception:
        LOGGER.warning(
            "Unexpected error deleting back_to_main user message (chat_id=%s, message_id=%s)",
            message.chat.id,
            message.message_id,
            exc_info=True,
        )
    await ui_cleanup_messages(message.bot, state, chat_id=message.chat.id)
    await state.clear()
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "Главное меню",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info("User %s returned to main menu", message.from_user.id if message.from_user else "unknown")

===== Bot/handlers/wishlist.py =====
"""Handlers for wishlist flow."""

import asyncio
import logging
from collections import defaultdict
from datetime import datetime, time, timedelta
from typing import Optional

from aiogram import Bot, F, Router
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
    ReplyKeyboardRemove,
)

from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import (
    back_only_keyboard,
    wishlist_categories_keyboard,
    wishlist_reply_keyboard,
    wishlist_url_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.states.wishlist_states import BytDeferState, WishlistState
from Bot.utils.datetime_utils import now_tz
from Bot.utils.ui_cleanup import ui_register_message, ui_register_user_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def _push_wl_step(state: FSMContext, step: str) -> None:
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != step:
        stack.append(step)
    await state.update_data(wl_add_step_stack=stack)


async def _set_wl_steps(state: FSMContext, steps: list[str]) -> None:
    await state.update_data(wl_add_step_stack=steps)


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY = {
    "Инструменты": "инвестиции",
    "Финансы": "сбережения",
    "Разное": "спонтанные траты",
    "инвестиции в работу": "инвестиции",
    "вклад в себя": "сбережения",
    "кайфы": "спонтанные траты",
    "БЫТ": "быт",
}

def humanize_wishlist_category(category: str) -> str:
    """Return user-facing category name supporting legacy values."""

    mapping = {
        "Инструменты": "инвестиции в работу",
        "Финансы": "вклад в себя",
        "Разное": "кайфы",
        "инвестиции в работу": "инвестиции в работу",
        "вклад в себя": "вклад в себя",
        "кайфы": "кайфы",
        "byt": "БЫТ",
        "БЫТ": "БЫТ",
    }
    return mapping.get(category, category)


def _get_user_wishlist_categories(db: FinanceDatabase, user_id: int) -> list[dict]:
    """Return active wishlist categories ensuring defaults exist."""

    db.ensure_wishlist_categories_seeded(user_id)
    return db.list_active_wishlist_categories(user_id)


@router.message(F.text == "📋 Вишлист")
async def open_wishlist(message: Message, state: FSMContext) -> None:
    """Open wishlist menu."""

    await delete_welcome_message_if_exists(message, state)
    await ui_register_user_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
    except Exception:
        LOGGER.warning("Failed to delete user menu message (Вишлист)", exc_info=True)
    await state.clear()
    db = FinanceDatabase()
    wishes = db.get_wishes_by_user(message.from_user.id)
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    has_active_wishes = any(not wish.get("is_purchased") for wish in wishes)

    if not has_active_wishes:
        await message.answer(
            "В твоём вишлисте пока пусто.\nДавай добавим что-то новое в наши категории ✨",
            reply_markup=wishlist_reply_keyboard(),
        )
        LOGGER.info("User %s opened empty wishlist", message.from_user.id if message.from_user else "unknown")
        return

    await message.answer("Раздел вишлиста.", reply_markup=wishlist_reply_keyboard())
    await message.answer(
        "Выбери категорию для просмотра или добавь новое желание.",
        reply_markup=wishlist_categories_keyboard(categories),
    )
    LOGGER.info("User %s opened wishlist", message.from_user.id if message.from_user else "unknown")


@router.message(F.text.in_({"➕", "+"}))
async def add_wish_start(message: Message, state: FSMContext) -> None:
    """Start adding wish."""

    await state.set_state(WishlistState.waiting_for_name)
    await _set_wl_steps(state, ["name"])
    await message.answer(
        "Введи название желания.",
        reply_markup=back_only_keyboard(),
    )

@router.message(WishlistState.waiting_for_name, F.text != "⬅️ Назад")
async def add_wish_name(message: Message, state: FSMContext) -> None:
    """Save wish name and request price."""

    await state.update_data(name=message.text)
    await state.set_state(WishlistState.waiting_for_price)
    await _push_wl_step(state, "amount")

    question = await message.answer(
        "Введи цену (используй кнопки ниже).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = await message.answer(": 0")

    await state.update_data(
        price_sum="0",
        price_question_message_id=question.message_id,
        price_message_id=prompt.message_id,
    )


@router.message(
    WishlistState.waiting_for_price,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "Очистить",
            "✅ Газ",
        }
    ),
)
async def add_wish_price_calc(message: Message, state: FSMContext) -> None:
    """Handle price input via calculator buttons."""

    data = await state.get_data()
    current_sum = str(data.get("price_sum", "0"))
    price_message_id = data.get("price_message_id")

    if message.text == "Очистить":
        new_sum = "0"
    elif message.text == "✅ Газ":
        amount_str = current_sum.strip()
        if not amount_str:
            await message.answer("Нужно ввести число. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        normalized = amount_str.replace(",", ".")
        try:
            price = float(normalized)
        except (TypeError, ValueError):
            await message.answer("Нужно ввести число. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        if price <= 0:
            await message.answer("Цена должна быть больше нуля. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        await state.update_data(price=price)
        await state.set_state(WishlistState.waiting_for_url)
        await _push_wl_step(state, "pre_url")
        await message.answer("дай", reply_markup=back_only_keyboard())
        await _push_wl_step(state, "url")
        await message.answer("ссылочку", reply_markup=wishlist_url_keyboard())

        try:
            await message.delete()
        except Exception:
            pass
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if price_message_id:
        try:
            await message.bot.edit_message_text(
                chat_id=message.chat.id,
                message_id=price_message_id,
                text=f": {new_sum}",
            )
        except Exception:
            pass

    await state.update_data(price_sum=new_sum, price_message_id=price_message_id)

    try:
        await message.delete()
    except Exception:
        pass


@router.message(WishlistState.waiting_for_url, F.text != "⬅️ Назад")
async def add_wish_url(message: Message, state: FSMContext) -> None:
    """Save URL and request category selection."""

    text = message.text.strip() if message.text else ""
    url: Optional[str] = None if text in {"-", ""} else text
    await state.update_data(url=url)
    await state.set_state(WishlistState.waiting_for_category)
    await _push_wl_step(state, "category")
    db = FinanceDatabase()
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    await message.answer(
        "Выбери категорию желания.", reply_markup=wishlist_categories_keyboard(categories)
    )
    await message.answer("Если нужно, нажми ⬅️ Назад.", reply_markup=back_only_keyboard())


@router.message(F.text == "Купленное")
async def show_purchases(message: Message, state: FSMContext | None = None) -> None:
    """Show purchased items grouped by category with pretty headers."""

    db = FinanceDatabase()
    purchases = db.get_purchases_by_user(message.from_user.id)

    # Если покупок нет — сразу выходим
    if not purchases:
        sent = await message.answer(
            "Список покупок пуст.",
            reply_markup=await build_main_menu_for_user(message.from_user.id),
        )
        if state:
            await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    # Группируем покупки по "очеловеченным" категориям
    groups: dict[str, list[dict]] = defaultdict(list)
    for purchase in purchases:
        category_key = humanize_wishlist_category(purchase.get("category", ""))
        groups[category_key].append(purchase)

    lines: list[str] = ["Купленные желания:"]
    for category, items in groups.items():
        lines.append(f"\n💡 {category}:")
        for purchase in items:
            lines.append(
                f"• {purchase['wish_name']} — {purchase['price']:.2f} ₽ "
                f"(куплено {purchase['purchased_at']})"
            )

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    if state:
        await ui_register_message(state, sent.chat.id, sent.message_id)


@router.message(
    F.text == "⬅️ Назад",
    StateFilter(
        WishlistState.waiting_for_name,
        WishlistState.waiting_for_price,
        WishlistState.waiting_for_url,
        WishlistState.waiting_for_category,
    ),
)
async def wishlist_add_back(message: Message, state: FSMContext) -> None:
    """Handle back navigation in wishlist add flow."""

    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    current = stack[-1] if stack else None

    if current == "name":
        await state.clear()
        await open_wishlist(message, state)
        return

    if current == "amount":
        await state.update_data(
            price=None,
            price_sum=None,
            price_question_message_id=None,
            price_message_id=None,
        )
        await state.set_state(WishlistState.waiting_for_name)
        await _set_wl_steps(state, ["name"])
        await message.answer(
            "Введи название желания.",
            reply_markup=back_only_keyboard(),
        )
        return

    if current == "url":
        stack.pop()
        await state.update_data(url=None, wl_add_step_stack=stack)
        await message.answer("дай", reply_markup=back_only_keyboard())
        await message.answer("ссылочку", reply_markup=wishlist_url_keyboard())
        return

    if current == "pre_url":
        stack.pop()
        await state.update_data(
            price=None,
            price_sum=None,
            price_question_message_id=None,
            price_message_id=None,
            wl_add_step_stack=stack,
        )
        await state.set_state(WishlistState.waiting_for_price)
        question = await message.answer(
            "Введи цену (используй кнопки ниже).",
            reply_markup=income_calculator_keyboard(),
        )
        prompt = await message.answer(": 0")
        await state.update_data(
            price_sum="0",
            price_question_message_id=question.message_id,
            price_message_id=prompt.message_id,
        )
        await _push_wl_step(state, "amount")
        return

    if current == "category":
        stack.pop()
        await state.update_data(wl_add_step_stack=stack)
        await state.set_state(WishlistState.waiting_for_url)
        await message.answer("дай", reply_markup=back_only_keyboard())
        await message.answer("ссылочку", reply_markup=wishlist_url_keyboard())
        return


@router.message(WishlistState.waiting_for_price)
async def invalid_price(message: Message) -> None:
    """Handle invalid price input."""

    await message.answer("Используй кнопки калькулятора ниже для ввода цены.")


@router.message(WishlistState.waiting_for_category, F.text == "⬅️ Назад")
async def add_wish_back_from_category(message: Message, state: FSMContext) -> None:
    """Return to name step from category selection."""

    await state.update_data(name=None, price=None, price_sum=None, url=None)
    await state.set_state(WishlistState.waiting_for_name)
    await message.answer(
        "Введи название желания.",
        reply_markup=back_only_keyboard(),
    )


@router.message(WishlistState.waiting_for_category)
async def waiting_category_text(message: Message) -> None:
    """Prompt to use inline keyboard for category."""

    db = FinanceDatabase()
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    await message.answer(
        "Выбери категорию через кнопки ниже.",
        reply_markup=wishlist_categories_keyboard(categories),
    )
    await message.answer("Если нужно, нажми ⬅️ Назад.", reply_markup=back_only_keyboard())


def _build_byt_items_keyboard(items: list[dict], allow_defer: bool = True) -> InlineKeyboardMarkup:
    """Build inline keyboard for BYT items with optional two-column layout."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""), callback_data=f"byt_buy:{item.get('id')}"
                )
            )
        rows.append(row)
    if allow_defer:
        defer_callback = "byt_defer_menu"
        if len(items) == 1:
            try:
                defer_id = int(items[0].get("id"))
            except (TypeError, ValueError):
                defer_id = None
            else:
                defer_callback = f"byt_defer_menu:{defer_id}"
        rows.append(
            [InlineKeyboardButton(text="ОТЛОЖИТЬ", callback_data=defer_callback)]
        )
    return InlineKeyboardMarkup(inline_keyboard=rows)


def _build_byt_defer_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Build inline keyboard for selecting BYT item to defer."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""),
                    callback_data=f"byt_defer_pick:{item.get('id')}",
                )
            )
        rows.append(row)
    return InlineKeyboardMarkup(inline_keyboard=rows)


async def _refresh_byt_reminder_message(
    bot: Bot, chat_id: int, message_id: int, user_id: int
) -> None:
    """Refresh reminder message with current BYT items."""

    db = FinanceDatabase()
    items = db.list_active_byt_items_for_reminder(user_id, now_tz())
    settings_row = db.get_user_settings(user_id)
    allow_defer = bool(settings_row.get("byt_defer_enabled", 1))
    if not items:
        try:
            await bot.edit_message_text(
                chat_id=chat_id, message_id=message_id, text="Ок."
            )
        except Exception:
            try:
                await bot.edit_message_reply_markup(
                    chat_id=chat_id, message_id=message_id, reply_markup=None
                )
            except Exception:
                pass
        return


async def _start_byt_defer_flow(
    callback: CallbackQuery, state: FSMContext, wish_id: int
) -> bool:
    """Validate and start BYT defer input flow for specific item."""

    db = FinanceDatabase()
    wish = db.get_wish(wish_id)
    if not wish or humanize_wishlist_category(wish.get("category", "")) != "БЫТ":
        await callback.answer("Элемент не найден.", show_alert=True)
        return False

    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await callback.answer("Отключено в настройках", show_alert=True)
        await state.clear()
        return False

    await state.set_state(BytDeferState.waiting_for_days)
    await state.update_data(
        defer_item_id=wish_id,
        defer_days_str="0",
        reminder_message_id=callback.message.message_id if callback.message else None,
    )

    await callback.answer()
    target_chat_id = callback.message.chat.id if callback.message else callback.from_user.id
    question_message = await callback.bot.send_message(
        target_chat_id, "На сколько дней отложить?"
    )
    prompt = await callback.bot.send_message(
        target_chat_id, ": 0", reply_markup=income_calculator_keyboard()
    )
    await state.update_data(
        defer_display_chat_id=question_message.chat.id,
        defer_display_message_id=prompt.message_id,
    )
    return True

    keyboard = _build_byt_items_keyboard(items, allow_defer=allow_defer)
    try:
        await bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text="Что ты купил?",
            reply_markup=keyboard,
        )
    except Exception:
        try:
            await bot.edit_message_reply_markup(
                chat_id=chat_id, message_id=message_id, reply_markup=keyboard
            )
        except Exception:
            pass


async def run_byt_timer_check(
    bot: Bot,
    db: FinanceDatabase,
    user_id: int | None = None,
    simulated_time: time | None = None,
    run_time: datetime | None = None,
) -> None:
    """Run BYT reminders using timer configuration for the user."""

    await asyncio.sleep(0)
    trigger_dt = run_time or now_tz()
    if simulated_time:
        trigger_dt = trigger_dt.replace(
            hour=simulated_time.hour,
            minute=simulated_time.minute,
            second=0,
            microsecond=0,
        )

    db.cleanup_old_byt_purchases(trigger_dt)
    user_ids = (
        [user_id]
        if user_id is not None
        else list(
            set(db.get_users_with_active_byt_wishes())
            | set(db.get_users_with_byt_timer_times())
        )
    )
    if not user_ids:
        return

    for uid in user_ids:
        db.ensure_byt_timer_defaults(uid)
        settings_row = db.get_user_settings(uid)
        if not bool(settings_row.get("byt_reminders_enabled", 1)):
            continue

        times = db.list_active_byt_timer_times(uid)
        simulated = simulated_time is not None
        trigger_label = trigger_dt.strftime("%H:%M")
        LOGGER.info(
            "BYT timer check triggered (user_id=%s, simulated=%s, time=%s)",
            uid,
            simulated,
            trigger_label,
        )
        if not times:
            LOGGER.info(
                "BYT timer check: no active times (user_id=%s)",
                uid,
            )
            continue

        should_run = any(
            int(timer.get("hour", -1)) == trigger_dt.hour
            and int(timer.get("minute", -1)) == trigger_dt.minute
            for timer in times
        )
        if not should_run:
            continue

        items = db.list_active_byt_items_for_reminder(uid, trigger_dt)
        if not items:
            LOGGER.info("BYT timer: no items, skip (user_id=%s)", uid)
            continue

        allow_defer = bool(settings_row.get("byt_defer_enabled", 1))
        keyboard = _build_byt_items_keyboard(items, allow_defer=allow_defer)
        await bot.send_message(uid, "Что ты купил?", reply_markup=keyboard)
        LOGGER.info(
            "BYT timer: sending checklist, items=%s, user_id=%s", len(items), uid
        )


async def run_byt_wishlist_reminders(
    bot: Bot,
    db: FinanceDatabase,
    user_id: int | None = None,
    forced: bool = False,
    run_time=None,
) -> None:
    """Backward-compatible wrapper for BYT reminders."""

    await run_byt_timer_check(
        bot,
        db,
        user_id=user_id,
        simulated_time=None,
        run_time=run_time,
    )


@router.callback_query(F.data.startswith("byt_buy:"))
async def handle_byt_buy(callback: CallbackQuery) -> None:
    """Handle purchase confirmation from BYT reminder list."""

    data = callback.data.split(":", maxsplit=1)
    if len(data) != 2:
        await callback.answer("Некорректный формат.", show_alert=True)
        return

    try:
        item_id = int(data[1])
    except ValueError:
        await callback.answer("Некорректный элемент.", show_alert=True)
        return

    db = FinanceDatabase()
    wish = db.get_wish(item_id)
    if not wish or humanize_wishlist_category(wish.get("category", "")) != "БЫТ":
        await callback.answer("Элемент не найден.", show_alert=True)
        return

    price = float(wish.get("price", 0) or 0)
    purchase_time = now_tz()
    db.decrease_savings(callback.from_user.id, "быт", price)
    db.mark_wish_purchased(item_id, purchased_at=purchase_time)
    db.add_purchase(
        callback.from_user.id,
        wish.get("name", ""),
        price,
        humanize_wishlist_category(wish.get("category", "")),
        purchased_at=purchase_time,
    )

    await callback.answer()
    if callback.message:
        await _refresh_byt_reminder_message(
            callback.bot,
            callback.message.chat.id,
            callback.message.message_id,
            callback.from_user.id,
        )


@router.callback_query(F.data.startswith("byt_defer_menu"))
async def handle_byt_defer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    """Show BYT items to choose which to defer."""

    wish_id: int | None = None
    if callback.data and ":" in callback.data:
        parts = callback.data.split(":", maxsplit=1)
        if len(parts) == 2:
            try:
                wish_id = int(parts[1])
            except ValueError:
                wish_id = None
    if wish_id is None:
        data = await state.get_data()
        stored_id = data.get("current_byt_item_id")
        try:
            wish_id = int(stored_id) if stored_id is not None else None
        except (TypeError, ValueError):
            wish_id = None

    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await callback.answer("Отключено в настройках", show_alert=True)
        return
    now_dt = now_tz()
    items = db.list_active_byt_items_for_reminder(callback.from_user.id, now_dt)
    if wish_id is not None:
        await state.update_data(current_byt_item_id=wish_id)
        started = await _start_byt_defer_flow(callback, state, wish_id)
        if not started:
            await state.clear()
        return
    if not items:
        await state.clear()
        if callback.message:
            await callback.message.answer("Нет бытовых покупок для отложки.")
        else:
            await callback.bot.send_message(
                callback.from_user.id, "Нет бытовых покупок для отложки."
            )
        await callback.answer()
        return

    keyboard = _build_byt_defer_keyboard(items)
    await state.clear()
    if callback.message:
        try:
            await callback.message.edit_text("ЧТО?", reply_markup=keyboard)
        except Exception:
            await callback.message.answer("ЧТО?", reply_markup=keyboard)
    else:
        await callback.bot.send_message(callback.from_user.id, "ЧТО?", reply_markup=keyboard)
    await callback.answer()


@router.callback_query(F.data.startswith("byt_defer_pick:"))
async def handle_byt_defer_pick(callback: CallbackQuery, state: FSMContext) -> None:
    """Start deferring selected BYT item."""

    data = callback.data.split(":", maxsplit=1)
    wish_id: int | None = None
    if len(data) == 2:
        try:
            wish_id = int(data[1])
        except ValueError:
            wish_id = None
    if wish_id is None:
        state_data = await state.get_data()
        try:
            wish_id = (
                int(state_data.get("defer_item_id"))
                if state_data.get("defer_item_id") is not None
                else None
            )
        except (TypeError, ValueError):
            wish_id = None
    if wish_id is None:
        await callback.answer("Ошибка: не найден item_id", show_alert=True)
        return

    started = await _start_byt_defer_flow(callback, state, wish_id)
    if not started:
        await state.clear()


@router.message(
    BytDeferState.waiting_for_days,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "Очистить",
            "✅ Газ",
        }
    ),
)
async def handle_byt_defer_days(message: Message, state: FSMContext) -> None:
    """Handle calculator input for BYT defer days."""

    data = await state.get_data()
    current_sum = str(data.get("defer_days_str", "0"))
    display_chat_id = data.get("defer_display_chat_id", message.chat.id)
    display_message_id = data.get("defer_display_message_id")
    db = FinanceDatabase()

    if message.text == "Очистить":
        new_sum = "0"
    elif message.text == "✅ Газ":
        amount_str = current_sum.strip()
        if not amount_str:
            LOGGER.warning(
                "BYT defer submit missing entered_days user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("Нужно ввести число дней. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                pass
            return
        try:
            days = int(amount_str)
        except (TypeError, ValueError):
            LOGGER.warning(
                "BYT defer submit invalid days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                amount_str,
            )
            await message.answer("Нужно ввести число. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        if days <= 0:
            LOGGER.warning(
                "BYT defer submit non-positive days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                days,
            )
            await message.answer("Нужно ввести число дней. Попробуй снова.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        try:
            settings_row = db.get_user_settings(message.from_user.id)
        except Exception as exc:
            LOGGER.error(
                "Failed to load user settings for BYT defer user_id=%s",
                message.from_user.id if message.from_user else "unknown",
                exc_info=exc,
            )
            await message.answer("Ошибка БД")
            try:
                await message.delete()
            except Exception:
                pass
            return
        max_days = int(settings_row.get("byt_defer_max_days", 365) or 365)
        if days < 1 or days > max_days:
            await message.answer(f"Количество дней должно быть от 1 до {max_days}.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        raw_defer_item_id = data.get("defer_item_id")
        try:
            defer_item_id = int(raw_defer_item_id) if raw_defer_item_id is not None else None
        except (TypeError, ValueError):
            defer_item_id = None
        if defer_item_id is None:
            LOGGER.warning(
                "BYT defer submit missing item_id user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("Не выбран товар для отсрочки.")
            await state.clear()
            try:
                await message.delete()
            except Exception:
                pass
            return
        reminder_message_id = data.get("reminder_message_id")
        deferred_until = now_tz() + timedelta(days=days)

        try:
            db.set_wishlist_item_deferred_until(
                message.from_user.id, defer_item_id, deferred_until.isoformat()
            )
        except Exception as exc:
            LOGGER.error(
                "Failed to set BYT defer days user_id=%s item_id=%s days=%s",
                message.from_user.id if message.from_user else "unknown",
                defer_item_id,
                days,
                exc_info=exc,
            )
            await message.answer("Ошибка БД")
            try:
                await message.delete()
            except Exception:
                pass
            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        await message.answer(
            f"Отложено на {days} дн.", reply_markup=ReplyKeyboardRemove()
        )

        if reminder_message_id:
            await _refresh_byt_reminder_message(
                message.bot,
                message.chat.id,
                int(reminder_message_id),
                message.from_user.id,
            )

        try:
            await message.delete()
        except Exception:
            pass
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {new_sum}",
            )
        except Exception:
            try:
                prompt = await message.answer(f": {new_sum}")
                new_display_message_id = prompt.message_id
                new_display_chat_id = message.chat.id
            except Exception:
                pass
    else:
        try:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
        except Exception:
            pass

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

    try:
        await message.delete()
    except Exception:
        pass


@router.message(BytDeferState.waiting_for_days)
async def handle_byt_defer_days_invalid(message: Message) -> None:
    """Prompt to use calculator buttons for defer days."""

    await message.answer("Используй кнопки калькулятора ниже.")

===== Bot/utils/ui_cleanup.py =====
import logging
from typing import Iterable, List, Optional

from aiogram import Bot
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext

LOGGER = logging.getLogger(__name__)


async def ui_register_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Track a UI message id for later cleanup."""

    data = await state.get_data()
    ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    if message_id not in ids:
        ids.append(int(message_id))
    if len(ids) > 300:
        ids = ids[-300:]
    current_chat_id = data.get("ui_chat_id")
    await state.update_data(
        ui_chat_id=current_chat_id if current_chat_id is not None else chat_id,
        ui_tracked_message_ids=ids,
    )


async def ui_register_protected_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    """Track a UI message id that should never be deleted."""

    await ui_register_message(state, chat_id, message_id)


async def ui_register_user_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Track a user message id for later cleanup."""

    await ui_register_message(state, chat_id, message_id)


async def ui_set_welcome_message(
    bot: Bot, state: FSMContext, chat_id: int, text: str
) -> int:
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    if welcome_id is not None:
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=int(welcome_id),
                text=text,
            )
            LOGGER.info(
                "Reused welcome message (chat_id=%s, message_id=%s)",
                chat_id,
                welcome_id,
            )
            return int(welcome_id)
        except TelegramBadRequest as exc:
            if "message is not modified" in str(exc).lower():
                LOGGER.info(
                    "Welcome message already up to date (chat_id=%s, message_id=%s)",
                    chat_id,
                    welcome_id,
                )
                return int(welcome_id)
            LOGGER.warning(
                "Failed to edit welcome message (chat_id=%s, message_id=%s): %s",
                chat_id,
                welcome_id,
                exc,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error editing welcome message (chat_id=%s, message_id=%s)",
                chat_id,
                welcome_id,
                exc_info=True,
            )
    sent = await bot.send_message(chat_id=chat_id, text=text)
    await state.update_data(
        ui_chat_id=chat_id, ui_welcome_message_id=int(sent.message_id)
    )
    LOGGER.info(
        "Created welcome message (chat_id=%s, message_id=%s)",
        chat_id,
        sent.message_id,
    )
    if welcome_id is not None and int(welcome_id) != int(sent.message_id):
        try:
            await bot.delete_message(chat_id=chat_id, message_id=int(welcome_id))
        except TelegramBadRequest as exc:
            LOGGER.warning(
                "Failed to delete previous welcome message (chat_id=%s, message_id=%s): %s",
                chat_id,
                welcome_id,
                exc,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error deleting previous welcome message (chat_id=%s, message_id=%s)",
                chat_id,
                welcome_id,
                exc_info=True,
            )
    return int(sent.message_id)


async def ui_set_settings_mode_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_set_screen_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)
    await state.update_data(ui_screen_message_id=int(message_id), ui_chat_id=chat_id)


async def ui_track_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_cleanup_to_context(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    context_name: str,
    keep_ids: List[int] | None = None,
) -> None:
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    tracked_ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    legacy_ids: List[int] = list(data.get("ui_message_ids") or [])
    combined_ids = list(dict.fromkeys([*legacy_ids, *tracked_ids]))

    keep_id_set = {int(welcome_id)} if welcome_id else set()
    if keep_ids:
        keep_id_set.update(int(item) for item in keep_ids if item is not None)
    delete_ids = [int(mid) for mid in tracked_ids if int(mid) not in keep_id_set]

    for message_id in delete_ids:
        try:
            await bot.delete_message(chat_id=chat_id, message_id=message_id)
        except TelegramBadRequest as exc:
            LOGGER.warning(
                "Failed to delete message (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
                exc_info=True,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error deleting message (chat_id=%s, message_id=%s)",
                chat_id,
                message_id,
            )

    remaining_ids = [mid for mid in combined_ids if int(mid) in keep_id_set]
    await state.update_data(
        ui_tracked_message_ids=[],
    )


async def ui_cleanup_messages(bot: Bot, state: FSMContext, *args, **kwargs) -> None:
    data = await state.get_data()
    chat_id = kwargs.get("chat_id") or data.get("ui_chat_id")
    if chat_id is None:
        return
    await ui_cleanup_to_context(bot, state, int(chat_id), "MAIN_MENU")


async def ui_render_screen(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    text: str,
    reply_markup=None,
    parse_mode: str | None = None,
) -> int:
    data = await state.get_data()
    screen_id = data.get("ui_screen_message_id")
    if screen_id is not None:
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=int(screen_id),
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
            )
            await ui_set_screen_message(state, chat_id, int(screen_id))
            return int(screen_id)
        except TelegramBadRequest as exc:
            if "message is not modified" in str(exc).lower():
                await ui_set_screen_message(state, chat_id, int(screen_id))
                return int(screen_id)
            LOGGER.warning(
                "Failed to edit screen message (chat_id=%s, message_id=%s): %s",
                chat_id,
                screen_id,
                exc,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error editing screen message (chat_id=%s, message_id=%s)",
                chat_id,
                screen_id,
                exc_info=True,
            )
    sent = await bot.send_message(
        chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode
    )
    await ui_set_screen_message(state, chat_id, sent.message_id)
    return int(sent.message_id)

===== UPDATE LOG =====
- 2025-12-22T13:04:53: Обновлены ui_cleanup, start, settings, wishlist, household_payments для единого UI-экрана и очистки.
