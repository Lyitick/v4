    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(message.from_user.id)
    current = bool(settings_row.get("byt_reminders_enabled", 1))
    db.set_byt_reminders_enabled(message.from_user.id, not current)
    await render_settings_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª")
async def byt_toggle_defer_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(message.from_user.id)
    current = bool(settings_row.get("byt_defer_enabled", 1))
    db.set_byt_defer_enabled(message.from_user.id, not current)
    await render_settings_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")
async def edit_byt_max_defer_days_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "byt:edit_max_defer_days")
    await state.set_state(BytSettingsState.waiting_for_max_defer_days)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(message.from_user.id)
    await state.update_data(
        byt_max_days_str="0",
        previous_byt_max_days=settings_row.get("byt_defer_max_days", 365),
    )
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ú–∞–∫—Å–∏–º—É–º –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∫–∏?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        byt_max_display_chat_id=prompt.chat.id,
        byt_max_display_message_id=prompt.message_id,
    )


@router.message(F.text.in_({"‚è∞ –¢–∞–π–º–µ—Ä", "‚è± –¢–∞–π–º–µ—Ä"}))
async def open_byt_timer_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("byt:timer_menu", message=message, state=state)


@router.message(F.text == "‚öô –£—Å–ª–æ–≤–∏—è")
async def open_byt_rules_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") not in {"st:byt_rules", "byt:timer_menu"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    if data.get("settings_current_screen") == "st:byt_rules":
        await render_settings_screen("st:byt_rules", message=message, state=state)
        return
    await _navigate_to_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è")
async def byt_timer_add_hour_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "bt:add_time_hour")
    await state.set_state(BytTimerState.waiting_for_hour)
    await state.update_data(bt_hour_str="0")
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –ß–ê–° (0‚Äì23)",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        bt_hour_display_chat_id=prompt.chat.id,
        bt_hour_display_message_id=prompt.message_id,
    )


@router.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è")
async def byt_timer_delete_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("bt:del_time_menu", message=message, state=state, force_new=True)


@router.message(F.text == "üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
async def byt_timer_reset_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    db = FinanceDatabase()
    db.reset_byt_timer_times(message.from_user.id)
    await render_settings_screen("byt:timer_menu", message=message, state=state)

@router.callback_query(F.data == "st:byt_rules")
async def open_byt_rules(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:byt_rules", message=callback.message, state=state)


@router.callback_query(F.data == "byt:toggle_enabled")
async def toggle_byt_enabled(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    current = bool(settings_row.get("byt_reminders_enabled", 1))
    db.set_byt_reminders_enabled(callback.from_user.id, not current)
    await render_settings_screen(
        "st:byt_rules", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:toggle_defer")
async def toggle_byt_defer(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    current = bool(settings_row.get("byt_defer_enabled", 1))
    db.set_byt_defer_enabled(callback.from_user.id, not current)
    await render_settings_screen(
        "st:byt_rules", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:edit_max_defer_days")
async def edit_byt_max_defer_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "byt:edit_max_defer_days")
    await state.set_state(BytSettingsState.waiting_for_max_defer_days)
    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    await state.update_data(
        byt_max_days_str="0", previous_byt_max_days=settings_row.get("byt_defer_max_days", 365)
    )
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ú–∞–∫—Å–∏–º—É–º –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∫–∏?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        byt_max_display_chat_id=prompt.chat.id,
        byt_max_display_message_id=prompt.message_id,
    )


@router.callback_query(F.data == "bt:add_time_hour")
async def byt_timer_add_hour(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "bt:add_time_hour")
    await state.set_state(BytTimerState.waiting_for_hour)
    await state.update_data(bt_hour_str="0")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –ß–ê–° (0‚Äì23)",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        bt_hour_display_chat_id=prompt.chat.id,
        bt_hour_display_message_id=prompt.message_id,
    )


@router.callback_query(F.data == "bt:del_time_menu")
async def byt_timer_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("bt:del_time_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("bt:del_time:"))
async def byt_timer_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        timer_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    times = db.list_active_byt_timer_times(callback.from_user.id)
    if len(times) <= 1:
        await _render_byt_timer_settings(
            state=state,
            message=callback.message,
            db=db,
            user_id=callback.from_user.id,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è.",
        )
        return

    db.deactivate_byt_timer_time(callback.from_user.id, timer_id)
    await _render_byt_timer_settings(
        state=state, message=callback.message, db=db, user_id=callback.from_user.id
    )


@router.callback_query(F.data == "bt:reset_default")
async def byt_timer_reset(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    db = FinanceDatabase()
    db.reset_byt_timer_times(callback.from_user.id)
    await render_settings_screen(
        "byt:timer_menu", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:timer_menu")
async def open_byt_timer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("byt:timer_menu", message=callback.message, state=state)


@router.message(HouseholdSettingsState.waiting_for_removal)
async def household_payment_delete_choice(
    message: Message, state: FSMContext
) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    mapping: dict[str, str] = data.get("hp_delete_map") or {}
    choice = (message.text or "").strip()
    if choice in {"‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥"}:
        await state.set_state(None)
        await render_settings_screen(
            "st:household_payments", message=message, state=state, force_new=False
        )
        return

    code = mapping.get(choice)
    if not code:
        await _send_and_register(
            message=message,
            state=state,
            text="–í—ã–±–µ—Ä–∏ –ø–ª–∞—Ç–µ–∂ –∏–∑ —Å–ø–∏—Å–∫–∞.",
        )
        return

    db = FinanceDatabase()
    db.deactivate_household_payment_item(message.from_user.id, code)
    await db.init_household_questions_for_month(
        message.from_user.id, current_month_str()
    )
    LOGGER.info(
        "Deleted household payment item (user_id=%s, code=%s)",
        message.from_user.id,
        code,
    )
    await state.set_state(None)
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=False
    )


@router.message(IncomeSettingsState.waiting_for_removal)
async def income_category_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("inc_delete_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "inc:del_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    categories = db.list_active_income_categories(message.from_user.id)
    if len([cat for cat in categories if cat.get("is_active", 1)]) <= 1:
        await state.set_state(None)
        await render_settings_screen(
            "st:income",
            message=message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_income_category(message.from_user.id, category_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:income"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(IncomeSettingsState.waiting_for_percent_category)
async def income_category_percent_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("inc_percent_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "inc:pct_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    category = db.get_income_category_by_id(message.from_user.id, category_id)
    if not category:
        await state.set_state(None)
        await render_settings_screen("st:income", message=message, state=state)
        return

    await _push_current_screen(state, "inc:pct_input")
    await state.update_data(
        edit_scope="income",
        editing_category_id=category_id,
        previous_percent=category.get("percent", 0),
        percent_str="0",
    )
    await state.set_state(IncomeSettingsState.waiting_for_percent)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f"–í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç (0‚Äì100) –¥–ª—è: {category['title']}",
        reply_markup=None,
    )
    percent_message = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        percent_display_chat_id=percent_message.chat.id,
        percent_display_message_id=percent_message.message_id,
    )
    LOGGER.info(
        "Percent edit start: user=%s scope=%s category_id=%s",
        message.from_user.id,
        "income",
        category_id,
    )


@router.message(WishlistSettingsState.waiting_for_removal)
async def wishlist_category_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("wl_delete_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "wl:del_cat_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    categories = db.list_active_wishlist_categories(message.from_user.id)
    if len(categories) <= 1:
        await state.set_state(None)
        await render_settings_screen(
            "st:wishlist",
            message=message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_wishlist_category(message.from_user.id, category_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_category)
async def wishlist_purchased_category_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("wl_purchased_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "wl:purchased_select_category",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    category = db.get_wishlist_category_by_id(message.from_user.id, category_id)
    if not category or not category.get("is_active", 1):
        await state.set_state(None)
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    await _push_current_screen(state, "wl:purchased_mode")
    await state.update_data(editing_wl_category_id=category_id)
    await state.set_state(WishlistSettingsState.waiting_for_purchased_mode)
    await _navigate_to_screen(
        "wl:purchased_mode", message=message, state=state, force_new=True
    )


@router.message(WishlistSettingsState.waiting_for_purchased_mode)
async def wishlist_purchased_mode_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await state.set_state(None)
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    db = FinanceDatabase()
    if choice == "–í—Å–µ–≥–¥–∞":
        db.update_wishlist_category_purchased_mode(
            message.from_user.id, int(category_id), "always"
        )
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=message, state=state)
        return
    if choice != "–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏":
        await render_settings_screen(
            "wl:purchased_mode",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    category = db.get_wishlist_category_by_id(message.from_user.id, int(category_id))
    if not category:
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(
        message.from_user.id, int(category_id), "days"
    )
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ –¥–ª—è "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(BytTimerState.waiting_for_removal)
async def byt_timer_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("bt_delete_map") or {}
    timer_id = mapping.get(choice)
    if not timer_id:
        await render_settings_screen(
            "bt:del_time_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –≤—Ä–µ–º—è –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = FinanceDatabase()
    times = db.list_active_byt_timer_times(message.from_user.id)
    if len(times) <= 1:
        await state.set_state(None)
        await _render_byt_timer_settings(
            state=state,
            message=message,
            db=db,
            user_id=message.from_user.id,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è.",
        )
        return

    db.deactivate_byt_timer_time(message.from_user.id, timer_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(BytTimerState.waiting_for_time_add)
async def byt_timer_add_time_value(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    text = (message.text or "").strip()
    parsed = _parse_time_text(text)
    if not parsed:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú.",
            reply_markup=None,
        )
        return

    hour, minute = parsed
    db = FinanceDatabase()
    db.add_byt_timer_time(message.from_user.id, hour, minute)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
    await render_settings_screen(previous_screen, message=message, state=state)

@router.callback_query(F.data == "inc:add")
async def category_add(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "inc:add_category")
    await state.set_state(IncomeSettingsState.waiting_for_category_title)
    await state.update_data(category_scope="income")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        reply_markup=None,
    )


@router.callback_query(F.data == "wl:add_cat")
async def wishlist_category_add(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "wl:add_category")
    await state.set_state(WishlistSettingsState.waiting_for_category_title)
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        reply_markup=None,
    )


@router.message(IncomeSettingsState.waiting_for_category_title)
async def income_add_category_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    title = (message.text or "").strip()
    if not title or len(title) > 32:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 32 —Å–∏–º–≤–æ–ª–æ–≤.",
            reply_markup=None,
        )
        return

    await state.update_data(new_income_category_title=title, new_income_percent_str="0")
    await state.set_state(IncomeSettingsState.waiting_for_new_category_percent)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ü—Ä–æ—Ü–µ–Ω—Ç –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        new_income_display_chat_id=prompt.chat.id,
        new_income_display_message_id=prompt.message_id,
    )


@router.message(WishlistSettingsState.waiting_for_category_title)
async def wishlist_add_category_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    title = (message.text or "").strip()
    if not title or len(title) > 32:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 32 —Å–∏–º–≤–æ–ª–æ–≤.",
            reply_markup=None,
        )
        return

    db = FinanceDatabase()
    db.create_wishlist_category(message.from_user.id, title)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(
    IncomeSettingsState.waiting_for_new_category_percent, F.text.in_(PERCENT_INPUT_BUTTONS)
)
async def income_new_category_percent(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    percent_str = data.get("new_income_percent_str", "0")
    display_chat_id = data.get("new_income_display_chat_id", message.chat.id)
    display_message_id = data.get("new_income_display_message_id")

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(
                chat_id=display_chat_id, text=f": {percent_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            new_income_percent_str=percent_str,
            new_income_display_chat_id=display_chat_id,
            new_income_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        percent_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            new_income_percent_str=percent_str,
            new_income_display_chat_id=display_chat_id,
            new_income_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º."
            percent = 0
        else:
            if percent < 0 or percent > 100:
                error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 0‚Äì100."

        title = (data.get("new_income_category_title") or "").strip()
        if not title:
            error_message = error_message or "–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ –∑–∞–¥–∞–Ω–æ."

        if error_message is None:
            db = FinanceDatabase()
            category_id = db.create_income_category(message.from_user.id, title)
            if category_id is not None:
                db.update_income_category_percent(
                    message.from_user.id, category_id, percent
                )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="new_income_display_chat_id",
            display_message_key="new_income_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(
            previous_screen, message=message, state=state, error_message=error_message
        )


@router.message(HouseholdSettingsState.waiting_for_title)
async def household_payment_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    title = (message.text or "").strip()
    if not title:
        await _send_and_register(
            message=message,
            state=state,
            text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞.",
        )
        return

    await state.update_data(hp_new_title=title, hp_amount_str="0")
    await state.set_state(HouseholdSettingsState.waiting_for_amount)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f'–°–∫–æ–ª—å–∫–æ –ø–ª–∞—Ç–∏—Ç—å –∑–∞ "{title}"?',
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        hp_amount_display_chat_id=prompt.chat.id,
        hp_amount_display_message_id=prompt.message_id,
    )


@router.message(
    HouseholdSettingsState.waiting_for_amount, F.text.in_(PERCENT_INPUT_BUTTONS)
)
async def household_payment_amount(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    amount_str = data.get("hp_amount_str", "0")
    display_chat_id = data.get("hp_amount_display_chat_id", message.chat.id)
    display_message_id = data.get("hp_amount_display_message_id")

    if text in PERCENT_DIGITS:
        amount_str = amount_str.lstrip("0") if amount_str != "0" else ""
        amount_str = f"{amount_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {amount_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(
                chat_id=display_chat_id, text=f": {amount_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            hp_amount_str=amount_str,
            hp_amount_display_chat_id=display_chat_id,
            hp_amount_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        amount_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            hp_amount_str=amount_str,
            hp_amount_display_chat_id=display_chat_id,
            hp_amount_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            amount = int(amount_str or "0")
        except ValueError:
            error_message = "–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ."
            amount = 0
        else:
            if amount <= 0:
                error_message = "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è."

        title = (data.get("hp_new_title") or "").strip()
        db = FinanceDatabase()

        if not title:
            error_message = error_message or "–ù–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –∑–∞–¥–∞–Ω–æ."

        if error_message is None:
            position = db.get_next_household_position(message.from_user.id)
            code = f"custom_{time.time_ns()}"
            text_value = f"{title} {amount}—Ä?"
            db.add_household_payment_item(
                message.from_user.id, code, text_value, amount, position
            )
            await db.init_household_questions_for_month(
                message.from_user.id, current_month_str()
            )
            LOGGER.info(
                "Added household payment item (user_id=%s, code=%s, amount=%s, title=%s)",
                message.from_user.id,
                code,
                amount,
                title,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="hp_amount_display_chat_id",
            display_message_key="hp_amount_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:household_payments"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
            error_message=error_message,
        )


@router.callback_query(F.data == "inc:del_menu")
async def category_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("inc:del_menu", message=callback.message, state=state)


@router.callback_query(F.data == "wl:del_cat_menu")
async def wishlist_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("wl:del_cat_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("inc:del:"))
async def category_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    scope = "income"
    categories = db.list_active_income_categories(callback.from_user.id)
    if len([cat for cat in categories if cat.get("is_active", 1)]) <= 1:
        await render_settings_screen(
            "st:income",
            message=callback.message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_income_category(callback.from_user.id, category_id)
    previous_screen = await _pop_previous_screen(state) or "st:income"
    await render_settings_screen(previous_screen, message=callback.message, state=state)


@router.callback_query(F.data.startswith("wl:del_cat:"))
async def wishlist_category_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    categories = db.list_active_wishlist_categories(callback.from_user.id)
    if len(categories) <= 1:
        await render_settings_screen(
            "st:wishlist",
            message=callback.message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_wishlist_category(callback.from_user.id, category_id)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=callback.message, state=state)


@router.callback_query(F.data == "inc:pct_menu")
async def category_percent_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("inc:pct_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("inc:pct:"))
async def category_percent_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    scope = "income"
    category = db.get_income_category_by_id(callback.from_user.id, category_id)
    if not category:
        await _render_income_settings(
            state=state, message=callback.message, db=db, user_id=callback.from_user.id
        )
        return

    await _push_current_screen(state, "inc:pct_input")
    await state.update_data(
        edit_scope=scope,
        editing_category_id=category_id,
        previous_percent=category.get("percent", 0),
        percent_str="0",
    )
    await state.set_state(IncomeSettingsState.waiting_for_percent)
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f"–í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç (0‚Äì100) –¥–ª—è: {category['title']}",
        reply_markup=None,
    )

    percent_message = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        percent_display_chat_id=percent_message.chat.id,
        percent_display_message_id=percent_message.message_id,
    )
    LOGGER.info(
        "Percent edit start: user=%s scope=%s category_id=%s",
        callback.from_user.id,
        scope,
        category_id,
    )


@router.callback_query(F.data == "wl:purchased_select_category")
async def wishlist_purchased_select_category(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen(
        "wl:purchased_select_category", message=callback.message, state=state
    )


@router.callback_query(F.data.startswith("wl:purchased_cat:"))
async def wishlist_purchased_category(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = FinanceDatabase()
    category = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category or not category.get("is_active", 1):
        await render_settings_screen(
            "st:wishlist", message=callback.message, state=state
        )
        return

    await _push_current_screen(state, "wl:purchased_mode")
    await state.update_data(editing_wl_category_id=category_id)
    await _navigate_to_screen(
        "wl:purchased_mode", message=callback.message, state=state
    )


@router.callback_query(F.data == "wl:purchased_mode:always")
async def wishlist_set_purchased_always(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = FinanceDatabase()
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "always")
    await state.set_state(None)
    await _reset_navigation(state, "st:wishlist")
    await render_settings_screen("st:wishlist", message=callback.message, state=state)


@router.callback_query(F.data == "wl:purchased_mode:days")
async def wishlist_set_purchased_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = FinanceDatabase()
    category = db.get_wishlist_category_by_id(callback.from_user.id, int(category_id))
    if not category:
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "days")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ –¥–ª—è "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(IncomeSettingsState.waiting_for_percent)
async def income_percent_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    percent_str = data.get("percent_str", "0")
    display_chat_id = data.get("percent_display_chat_id", message.chat.id)
    display_message_id = data.get("percent_display_message_id")

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        LOGGER.info(
            "Percent input: user=%s scope=%s value=%s",
            message.from_user.id,
            data.get("edit_scope", "income"),
            percent_str,
        )
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(
                chat_id=display_chat_id, text=f": {percent_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        percent_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º."
        else:
            if percent < 0 or percent > 100:
                error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 0‚Äì100."

        category_id = data.get("editing_category_id")
        if category_id is None:
            await state.set_state(None)
            await _cleanup_input_ui(
                message.bot,
                data,
                display_chat_key="percent_display_chat_id",
                display_message_key="percent_display_message_id",
            )
            await _remove_calculator_keyboard(message)
            await _render_previous_screen_or_exit(message, state)
            return

        if error_message is None:
            db = FinanceDatabase()
            db.update_income_category_percent(message.from_user.id, category_id, percent)
            total = db.sum_income_category_percents(message.from_user.id)

            if total == 100:
                LOGGER.info(
                    "Percent saved: user=%s scope=%s category_id=%s value=%s",
                    message.from_user.id,
                    "income",
                    category_id,
                    percent,
                )
            else:
                error_message = f"–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ —Å–µ–π—á–∞—Å {total}%. –ù—É–∂–Ω–æ 100%."

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="percent_display_chat_id",
            display_message_key="percent_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        if error_message:
            await state.set_state(IncomeSettingsState.waiting_for_percent_category)
            await _render_income_percent_menu(
                state=state,
                message=message,
                db=FinanceDatabase(),
                user_id=message.from_user.id,
                error_message=error_message,
            )
            return

        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_days)
async def wishlist_purchased_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    days_str = data.get("purchased_days_str", "0")
    display_chat_id = data.get("purchased_display_chat_id", message.chat.id)
    display_message_id = data.get("purchased_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=f": {days_str}")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        days_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 3650.",
                reply_markup=None,
            )
            return

        db = FinanceDatabase()
        category_id = data.get("editing_wl_category_id")
        if category_id is not None:
            db.update_wishlist_category_purchased_days(
                message.from_user.id, int(category_id), days
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="purchased_display_chat_id",
            display_message_key="purchased_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen(
            "st:wishlist", message=message, state=state
        )


@router.message(BytSettingsState.waiting_for_max_defer_days)
async def byt_max_defer_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    days_str = data.get("byt_max_days_str", "0")
    display_chat_id = data.get("byt_max_display_chat_id", message.chat.id)
    display_message_id = data.get("byt_max_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=f": {days_str}")
            display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        days_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 3650.",
                reply_markup=None,
            )
            return

        db = FinanceDatabase()
        settings_row = db.get_user_settings(message.from_user.id)
        previous_days = settings_row.get("byt_defer_max_days")
        db.set_byt_defer_max_days(message.from_user.id, days)
        LOGGER.info(
            "Updated BYT defer max days for user %s: %s", message.from_user.id, days
        )
        previous_max = data.get("previous_byt_max_days")
        if previous_max is not None and previous_max != days:
            LOGGER.info(
                "Max defer days changed: user=%s from=%s to=%s",
                message.from_user.id,
                previous_max,
                days,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="byt_max_display_chat_id",
            display_message_key="byt_max_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
        )

@router.message(BytTimerState.waiting_for_hour, F.text.in_(PERCENT_INPUT_BUTTONS))
async def byt_timer_hour_input(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    hour_str = data.get("bt_hour_str", "0")
    display_chat_id = data.get("bt_hour_display_chat_id", message.chat.id)
    display_message_id = data.get("bt_hour_display_message_id")

    if text in PERCENT_DIGITS:
        hour_str = hour_str.lstrip("0") if hour_str != "0" else ""
        hour_str = f"{hour_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {hour_str}",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=f": {hour_str}")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_hour_str=hour_str,
            bt_hour_display_chat_id=display_chat_id,
            bt_hour_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        hour_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_hour_str=hour_str,
            bt_hour_display_chat_id=display_chat_id,
            bt_hour_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            hour = int(hour_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        if hour < 0 or hour > 23:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ß–∞—Å—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å 0‚Äì23.",
                reply_markup=None,
            )
            return
        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="bt_hour_display_chat_id",
            display_message_key="bt_hour_display_message_id",
        )
        await state.set_state(BytTimerState.waiting_for_minute)
        await state.update_data(selected_hour=hour, bt_minute_str="0")
        await _set_current_screen(state, "bt:add_time_minute")
        prompt_message = await _send_and_register(
            message=message,
            state=state,
            text="–í–≤–µ–¥–∏ –ú–ò–ù–£–¢–´ (0‚Äì59)",
        )
        prompt = await _send_and_register(
            message=message,
            state=state,
            text=": 0",
            reply_markup=income_calculator_keyboard(),
        )
        await state.update_data(
            bt_min_prompt_chat_id=prompt_message.chat.id,
            bt_min_prompt_message_id=prompt_message.message_id,
            bt_min_display_chat_id=prompt.chat.id,
            bt_min_display_message_id=prompt.message_id,
        )

@router.message(BytTimerState.waiting_for_minute, F.text.in_(PERCENT_INPUT_BUTTONS))
async def byt_timer_minute_input(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    minute_str = data.get("bt_minute_str", "0")
    display_chat_id = data.get("bt_min_display_chat_id", message.chat.id)
    display_message_id = data.get("bt_min_display_message_id")

    if text in PERCENT_DIGITS:
        minute_str = minute_str.lstrip("0") if minute_str != "0" else ""
        minute_str = f"{minute_str}{text}" or "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {minute_str}",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=f": {minute_str}")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_minute_str=minute_str,
            bt_min_display_chat_id=display_chat_id,
            bt_min_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        minute_str = "0"
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            prompt = await message.bot.send_message(chat_id=display_chat_id, text=": 0")
            display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_minute_str=minute_str,
            bt_min_display_chat_id=display_chat_id,
            bt_min_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            minute = int(minute_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        if minute < 0 or minute > 59:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ú–∏–Ω—É—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å 0‚Äì59.",
                reply_markup=None,
            )
            return
        db = FinanceDatabase()
        selected_hour = int(data.get("selected_hour", 0))
        db.add_byt_timer_time(message.from_user.id, selected_hour, minute)
        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="bt_min_display_chat_id",
            display_message_key="bt_min_display_message_id",
            prompt_chat_key="bt_min_prompt_chat_id",
            prompt_message_key="bt_min_prompt_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "byt:timer_menu"
        await render_settings_screen(previous_screen, message=message, state=state)


===== Bot/handlers/start.py =====
"""Handlers for start and cancel commands."""
import logging

from aiogram import F, Router
from aiogram.exceptions import TelegramBadRequest
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from Bot.handlers.common import build_main_menu_for_user
from Bot.utils.ui_cleanup import (
    ui_cleanup_to_context,
    ui_set_screen_message,
    ui_set_welcome_message,
    ui_track_message,
)

LOGGER = logging.getLogger(__name__)

router = Router()


async def _handle_start_common(message: Message, state: FSMContext) -> None:
    """Shared start logic for /start and "–ü–æ–µ—Ö–∞–ª–∏–∏–∏" commands."""

    # –ü–†–ò–í–ï–¢–°–¢–í–ò–ï (PROTECTED)
    # –≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞—â–∏—â–µ–Ω–æ –∏ –ù–ï –¥–æ–ª–∂–Ω–æ —É–¥–∞–ª—è—Ç—å—Å—è –º–∞—Å—Å–æ–≤—ã–º–∏ —á–∏—Å—Ç–∫–∞–º–∏.
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–µ—â–µ–Ω–æ. –£–¥–∞–ª–µ–Ω–∏–µ –¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
    # –ø–æ—Å–ª–µ —è–≤–Ω–æ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    greeting = "–ü–æ—Ä–∞–±–æ—Ç–∞–µ–º –±–ª"
    await ui_set_welcome_message(message.bot, state, message.chat.id, greeting)
    await ui_cleanup_to_context(
        message.bot, state, message.chat.id, "MAIN_MENU"
    )
    sent = await message.answer(
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_set_screen_message(state, sent.chat.id, sent.message_id)
    LOGGER.info(
        "User %s started bot", message.from_user.id if message.from_user else "unknown"
    )


@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext) -> None:
    """Handle /start command."""

    await ui_track_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
    except Exception:  # noqa: BLE001
        LOGGER.warning("Failed to delete /start message", exc_info=True)
    await _handle_start_common(message, state)


@router.message(F.text == "–ü–æ–µ—Ö–∞–ª–∏–∏–∏")
async def handle_poehali(message: Message, state: FSMContext) -> None:
    """Handle alternative start phrase."""

    await ui_track_message(state, message.chat.id, message.message_id)
    await _handle_start_common(message, state)


@router.message(Command("cancel"))
async def cmd_cancel(message: Message, state: FSMContext) -> None:
    """Handle /cancel command."""

    await ui_track_message(state, message.chat.id, message.message_id)
    await ui_cleanup_to_context(message.bot, state, message.chat.id, "MAIN_MENU")
    sent = await message.answer(
        "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞. –í—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_set_screen_message(state, sent.chat.id, sent.message_id)
    LOGGER.info("User %s cancelled current operation", message.from_user.id if message.from_user else "unknown")


@router.message(F.text == "‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")
async def back_to_main(message: Message, state: FSMContext) -> None:
    """Return user to main menu."""

    try:
        await message.delete()
        LOGGER.info(
            "Deleted back_to_main user message (chat_id=%s, message_id=%s)",
            message.chat.id,
            message.message_id,
        )
    except TelegramBadRequest as exc:
        LOGGER.warning(
            "Failed to delete back_to_main user message (chat_id=%s, message_id=%s): %s",
            message.chat.id,
            message.message_id,
            exc,
        )
    except Exception:
        LOGGER.warning(
            "Unexpected error deleting back_to_main user message (chat_id=%s, message_id=%s)",
            message.chat.id,
            message.message_id,
            exc_info=True,
        )
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    await ui_cleanup_to_context(
        message.bot,
        state,
        message.chat.id,
        "MAIN_MENU",
        keep_ids=[welcome_id] if welcome_id else None,
    )
    sent = await message.answer(
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_set_screen_message(state, sent.chat.id, sent.message_id)
    LOGGER.info("User %s returned to main menu", message.from_user.id if message.from_user else "unknown")


===== Bot/handlers/wishlist.py =====
"""Handlers for wishlist flow."""

import asyncio
import logging
from collections import defaultdict
from datetime import datetime, time, timedelta
from typing import Optional

from aiogram import Bot, F, Router
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
    ReplyKeyboardRemove,
)

from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import (
    back_only_keyboard,
    wishlist_categories_keyboard,
    wishlist_reply_keyboard,
    wishlist_url_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.states.wishlist_states import BytDeferState, WishlistState
from Bot.utils.datetime_utils import now_tz
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def _push_wl_step(state: FSMContext, step: str) -> None:
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != step:
        stack.append(step)
    await state.update_data(wl_add_step_stack=stack)


async def _set_wl_steps(state: FSMContext, steps: list[str]) -> None:
    await state.update_data(wl_add_step_stack=steps)


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY = {
    "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã": "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏",
    "–§–∏–Ω–∞–Ω—Å—ã": "—Å–±–µ—Ä–µ–∂–µ–Ω–∏—è",
    "–†–∞–∑–Ω–æ–µ": "—Å–ø–æ–Ω—Ç–∞–Ω–Ω—ã–µ —Ç—Ä–∞—Ç—ã",
    "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ –≤ —Ä–∞–±–æ—Ç—É": "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏",
    "–≤–∫–ª–∞–¥ –≤ —Å–µ–±—è": "—Å–±–µ—Ä–µ–∂–µ–Ω–∏—è",
    "–∫–∞–π—Ñ—ã": "—Å–ø–æ–Ω—Ç–∞–Ω–Ω—ã–µ —Ç—Ä–∞—Ç—ã",
    "–ë–´–¢": "–±—ã—Ç",
}

def humanize_wishlist_category(category: str) -> str:
    """Return user-facing category name supporting legacy values."""

    mapping = {
        "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã": "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ –≤ —Ä–∞–±–æ—Ç—É",
        "–§–∏–Ω–∞–Ω—Å—ã": "–≤–∫–ª–∞–¥ –≤ —Å–µ–±—è",
        "–†–∞–∑–Ω–æ–µ": "–∫–∞–π—Ñ—ã",
        "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ –≤ —Ä–∞–±–æ—Ç—É": "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ –≤ —Ä–∞–±–æ—Ç—É",
        "–≤–∫–ª–∞–¥ –≤ —Å–µ–±—è": "–≤–∫–ª–∞–¥ –≤ —Å–µ–±—è",
        "–∫–∞–π—Ñ—ã": "–∫–∞–π—Ñ—ã",
        "byt": "–ë–´–¢",
        "–ë–´–¢": "–ë–´–¢",
    }
    return mapping.get(category, category)


def _get_user_wishlist_categories(db: FinanceDatabase, user_id: int) -> list[dict]:
    """Return active wishlist categories ensuring defaults exist."""

    db.ensure_wishlist_categories_seeded(user_id)
    return db.list_active_wishlist_categories(user_id)


@router.message(F.text == "üìã –í–∏—à–ª–∏—Å—Ç")
async def open_wishlist(message: Message, state: FSMContext) -> None:
    """Open wishlist menu."""

    await delete_welcome_message_if_exists(message, state)
    await state.clear()
    db = FinanceDatabase()
    wishes = db.get_wishes_by_user(message.from_user.id)
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    has_active_wishes = any(not wish.get("is_purchased") for wish in wishes)

    if not has_active_wishes:
        await message.answer(
            "–í —Ç–≤–æ—ë–º –≤–∏—à–ª–∏—Å—Ç–µ –ø–æ–∫–∞ –ø—É—Å—Ç–æ.\n–î–∞–≤–∞–π –¥–æ–±–∞–≤–∏–º —á—Ç–æ-—Ç–æ –Ω–æ–≤–æ–µ –≤ –Ω–∞—à–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚ú®",
            reply_markup=wishlist_reply_keyboard(),
        )
        LOGGER.info("User %s opened empty wishlist", message.from_user.id if message.from_user else "unknown")
        return

    await message.answer("–†–∞–∑–¥–µ–ª –≤–∏—à–ª–∏—Å—Ç–∞.", reply_markup=wishlist_reply_keyboard())
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–ª–∏ –¥–æ–±–∞–≤—å –Ω–æ–≤–æ–µ –∂–µ–ª–∞–Ω–∏–µ.",
        reply_markup=wishlist_categories_keyboard(categories),
    )
    LOGGER.info("User %s opened wishlist", message.from_user.id if message.from_user else "unknown")


@router.message(F.text.in_({"‚ûï", "+"}))
async def add_wish_start(message: Message, state: FSMContext) -> None:
    """Start adding wish."""

    await state.set_state(WishlistState.waiting_for_name)
    await _set_wl_steps(state, ["name"])
    await message.answer(
        "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–µ–ª–∞–Ω–∏—è.",
        reply_markup=back_only_keyboard(),
    )

@router.message(WishlistState.waiting_for_name, F.text != "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_name(message: Message, state: FSMContext) -> None:
    """Save wish name and request price."""

    await state.update_data(name=message.text)
    await state.set_state(WishlistState.waiting_for_price)
    await _push_wl_step(state, "amount")

    question = await message.answer(
        "–í–≤–µ–¥–∏ —Ü–µ–Ω—É (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = await message.answer(": 0")

    await state.update_data(
        price_sum="0",
        price_question_message_id=question.message_id,
        price_message_id=prompt.message_id,
    )


@router.message(
    WishlistState.waiting_for_price,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "–û—á–∏—Å—Ç–∏—Ç—å",
            "‚úÖ –ì–∞–∑",
        }
    ),
)
async def add_wish_price_calc(message: Message, state: FSMContext) -> None:
    """Handle price input via calculator buttons."""

    data = await state.get_data()
    current_sum = str(data.get("price_sum", "0"))
    price_message_id = data.get("price_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        normalized = amount_str.replace(",", ".")
        try:
            price = float(normalized)
        except (TypeError, ValueError):
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        if price <= 0:
            await message.answer("–¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        await state.update_data(price=price)
        await state.set_state(WishlistState.waiting_for_url)
        await _push_wl_step(state, "pre_url")
        await message.answer("–¥–∞–π", reply_markup=back_only_keyboard())
        await _push_wl_step(state, "url")
        await message.answer("—Å—Å—ã–ª–æ—á–∫—É", reply_markup=wishlist_url_keyboard())

        try:
            await message.delete()
        except Exception:
            pass
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if price_message_id:
        try:
            await message.bot.edit_message_text(
                chat_id=message.chat.id,
                message_id=price_message_id,
                text=f": {new_sum}",
            )
        except Exception:
            pass

    await state.update_data(price_sum=new_sum, price_message_id=price_message_id)

    try:
        await message.delete()
    except Exception:
        pass


@router.message(WishlistState.waiting_for_url, F.text != "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_url(message: Message, state: FSMContext) -> None:
    """Save URL and request category selection."""

    text = message.text.strip() if message.text else ""
    url: Optional[str] = None if text in {"-", ""} else text
    await state.update_data(url=url)
    await state.set_state(WishlistState.waiting_for_category)
    await _push_wl_step(state, "category")
    db = FinanceDatabase()
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∂–µ–ª–∞–Ω–∏—è.", reply_markup=wishlist_categories_keyboard(categories)
    )
    await message.answer("–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.", reply_markup=back_only_keyboard())


@router.message(F.text == "–ö—É–ø–ª–µ–Ω–Ω–æ–µ")
async def show_purchases(message: Message, state: FSMContext | None = None) -> None:
    """Show purchased items grouped by category with pretty headers."""

    db = FinanceDatabase()
    purchases = db.get_purchases_by_user(message.from_user.id)

    # –ï—Å–ª–∏ –ø–æ–∫—É–ø–æ–∫ –Ω–µ—Ç ‚Äî —Å—Ä–∞–∑—É –≤—ã—Ö–æ–¥–∏–º
    if not purchases:
        sent = await message.answer(
            "–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫ –ø—É—Å—Ç.",
            reply_markup=await build_main_menu_for_user(message.from_user.id),
        )
        if state:
            await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ–∫—É–ø–∫–∏ –ø–æ "–æ—á–µ–ª–æ–≤–µ—á–µ–Ω–Ω—ã–º" –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    groups: dict[str, list[dict]] = defaultdict(list)
    for purchase in purchases:
        category_key = humanize_wishlist_category(purchase.get("category", ""))
        groups[category_key].append(purchase)

    lines: list[str] = ["–ö—É–ø–ª–µ–Ω–Ω—ã–µ –∂–µ–ª–∞–Ω–∏—è:"]
    for category, items in groups.items():
        lines.append(f"\nüí° {category}:")
        for purchase in items:
            lines.append(
                f"‚Ä¢ {purchase['wish_name']} ‚Äî {purchase['price']:.2f} ‚ÇΩ "
                f"(–∫—É–ø–ª–µ–Ω–æ {purchase['purchased_at']})"
            )

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    if state:
        await ui_register_message(state, sent.chat.id, sent.message_id)


@router.message(
    F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
    StateFilter(
        WishlistState.waiting_for_name,
        WishlistState.waiting_for_price,
        WishlistState.waiting_for_url,
        WishlistState.waiting_for_category,
    ),
)
async def wishlist_add_back(message: Message, state: FSMContext) -> None:
    """Handle back navigation in wishlist add flow."""

    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    current = stack[-1] if stack else None

    if current == "name":
        await state.clear()
        await open_wishlist(message, state)
        return

    if current == "amount":
        await state.update_data(
            price=None,
            price_sum=None,
            price_question_message_id=None,
            price_message_id=None,
        )
        await state.set_state(WishlistState.waiting_for_name)
        await _set_wl_steps(state, ["name"])
        await message.answer(
            "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–µ–ª–∞–Ω–∏—è.",
            reply_markup=back_only_keyboard(),
        )
        return

    if current == "url":
        stack.pop()
        await state.update_data(url=None, wl_add_step_stack=stack)
        await message.answer("–¥–∞–π", reply_markup=back_only_keyboard())
        await message.answer("—Å—Å—ã–ª–æ—á–∫—É", reply_markup=wishlist_url_keyboard())
        return

    if current == "pre_url":
        stack.pop()
        await state.update_data(
            price=None,
            price_sum=None,
            price_question_message_id=None,
            price_message_id=None,
            wl_add_step_stack=stack,
        )
        await state.set_state(WishlistState.waiting_for_price)
        question = await message.answer(
            "–í–≤–µ–¥–∏ —Ü–µ–Ω—É (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
            reply_markup=income_calculator_keyboard(),
        )
        prompt = await message.answer(": 0")
        await state.update_data(
            price_sum="0",
            price_question_message_id=question.message_id,
            price_message_id=prompt.message_id,
        )
        await _push_wl_step(state, "amount")
        return

    if current == "category":
        stack.pop()
        await state.update_data(wl_add_step_stack=stack)
        await state.set_state(WishlistState.waiting_for_url)
        await message.answer("–¥–∞–π", reply_markup=back_only_keyboard())
        await message.answer("—Å—Å—ã–ª–æ—á–∫—É", reply_markup=wishlist_url_keyboard())
        return


@router.message(WishlistState.waiting_for_price)
async def invalid_price(message: Message) -> None:
    """Handle invalid price input."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞ –Ω–∏–∂–µ –¥–ª—è –≤–≤–æ–¥–∞ —Ü–µ–Ω—ã.")


@router.message(WishlistState.waiting_for_category, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_back_from_category(message: Message, state: FSMContext) -> None:
    """Return to name step from category selection."""

    await state.update_data(name=None, price=None, price_sum=None, url=None)
    await state.set_state(WishlistState.waiting_for_name)
    await message.answer(
        "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–µ–ª–∞–Ω–∏—è.",
        reply_markup=back_only_keyboard(),
    )


@router.message(WishlistState.waiting_for_category)
async def waiting_category_text(message: Message) -> None:
    """Prompt to use inline keyboard for category."""

    db = FinanceDatabase()
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ.",
        reply_markup=wishlist_categories_keyboard(categories),
    )
    await message.answer("–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.", reply_markup=back_only_keyboard())


def _build_byt_items_keyboard(items: list[dict], allow_defer: bool = True) -> InlineKeyboardMarkup:
    """Build inline keyboard for BYT items with optional two-column layout."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""), callback_data=f"byt_buy:{item.get('id')}"
                )
            )
        rows.append(row)
    if allow_defer:
        defer_callback = "byt_defer_menu"
        if len(items) == 1:
            try:
                defer_id = int(items[0].get("id"))
            except (TypeError, ValueError):
                defer_id = None
            else:
                defer_callback = f"byt_defer_menu:{defer_id}"
        rows.append(
            [InlineKeyboardButton(text="–û–¢–õ–û–ñ–ò–¢–¨", callback_data=defer_callback)]
        )
    return InlineKeyboardMarkup(inline_keyboard=rows)


def _build_byt_defer_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Build inline keyboard for selecting BYT item to defer."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""),
                    callback_data=f"byt_defer_pick:{item.get('id')}",
                )
            )
        rows.append(row)
    return InlineKeyboardMarkup(inline_keyboard=rows)


async def _refresh_byt_reminder_message(
    bot: Bot, chat_id: int, message_id: int, user_id: int
) -> None:
    """Refresh reminder message with current BYT items."""

    db = FinanceDatabase()
    items = db.list_active_byt_items_for_reminder(user_id, now_tz())
    settings_row = db.get_user_settings(user_id)
    allow_defer = bool(settings_row.get("byt_defer_enabled", 1))
    if not items:
        try:
            await bot.edit_message_text(
                chat_id=chat_id, message_id=message_id, text="–û–∫."
            )
        except Exception:
            try:
                await bot.edit_message_reply_markup(
                    chat_id=chat_id, message_id=message_id, reply_markup=None
                )
            except Exception:
                pass
        return


async def _start_byt_defer_flow(
    callback: CallbackQuery, state: FSMContext, wish_id: int
) -> bool:
    """Validate and start BYT defer input flow for specific item."""

    db = FinanceDatabase()
    wish = db.get_wish(wish_id)
    if not wish or humanize_wishlist_category(wish.get("category", "")) != "–ë–´–¢":
        await callback.answer("–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return False

    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await callback.answer("–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö", show_alert=True)
        await state.clear()
        return False

    await state.set_state(BytDeferState.waiting_for_days)
    await state.update_data(
        defer_item_id=wish_id,
        defer_days_str="0",
        reminder_message_id=callback.message.message_id if callback.message else None,
    )

    await callback.answer()
    target_chat_id = callback.message.chat.id if callback.message else callback.from_user.id
    question_message = await callback.bot.send_message(
        target_chat_id, "–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∏—Ç—å?"
    )
    prompt = await callback.bot.send_message(
        target_chat_id, ": 0", reply_markup=income_calculator_keyboard()
    )
    await state.update_data(
        defer_display_chat_id=question_message.chat.id,
        defer_display_message_id=prompt.message_id,
    )
    return True

    keyboard = _build_byt_items_keyboard(items, allow_defer=allow_defer)
    try:
        await bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text="–ß—Ç–æ —Ç—ã –∫—É–ø–∏–ª?",
            reply_markup=keyboard,
        )
    except Exception:
        try:
            await bot.edit_message_reply_markup(
                chat_id=chat_id, message_id=message_id, reply_markup=keyboard
            )
        except Exception:
            pass


async def run_byt_timer_check(
    bot: Bot,
    db: FinanceDatabase,
    user_id: int | None = None,
    simulated_time: time | None = None,
    run_time: datetime | None = None,
) -> None:
    """Run BYT reminders using timer configuration for the user."""

    await asyncio.sleep(0)
    trigger_dt = run_time or now_tz()
    if simulated_time:
        trigger_dt = trigger_dt.replace(
            hour=simulated_time.hour,
            minute=simulated_time.minute,
            second=0,
            microsecond=0,
        )

    db.cleanup_old_byt_purchases(trigger_dt)
    user_ids = (
        [user_id]
        if user_id is not None
        else list(
            set(db.get_users_with_active_byt_wishes())
            | set(db.get_users_with_byt_timer_times())
        )
    )
    if not user_ids:
        return

    for uid in user_ids:
        db.ensure_byt_timer_defaults(uid)
        settings_row = db.get_user_settings(uid)
        if not bool(settings_row.get("byt_reminders_enabled", 1)):
            continue

        times = db.list_active_byt_timer_times(uid)
        simulated = simulated_time is not None
        trigger_label = trigger_dt.strftime("%H:%M")
        LOGGER.info(
            "BYT timer check triggered (user_id=%s, simulated=%s, time=%s)",
            uid,
            simulated,
            trigger_label,
        )
        if not times:
            LOGGER.info(
                "BYT timer check: no active times (user_id=%s)",
                uid,
            )
            continue

        should_run = any(
            int(timer.get("hour", -1)) == trigger_dt.hour
            and int(timer.get("minute", -1)) == trigger_dt.minute
            for timer in times
        )
        if not should_run:
            continue

        items = db.list_active_byt_items_for_reminder(uid, trigger_dt)
        if not items:
            LOGGER.info("BYT timer: no items, skip (user_id=%s)", uid)
            continue

        allow_defer = bool(settings_row.get("byt_defer_enabled", 1))
        keyboard = _build_byt_items_keyboard(items, allow_defer=allow_defer)
        await bot.send_message(uid, "–ß—Ç–æ —Ç—ã –∫—É–ø–∏–ª?", reply_markup=keyboard)
        LOGGER.info(
            "BYT timer: sending checklist, items=%s, user_id=%s", len(items), uid
        )


async def run_byt_wishlist_reminders(
    bot: Bot,
    db: FinanceDatabase,
    user_id: int | None = None,
    forced: bool = False,
    run_time=None,
) -> None:
    """Backward-compatible wrapper for BYT reminders."""

    await run_byt_timer_check(
        bot,
        db,
        user_id=user_id,
        simulated_time=None,
        run_time=run_time,
    )


@router.callback_query(F.data.startswith("byt_buy:"))
async def handle_byt_buy(callback: CallbackQuery) -> None:
    """Handle purchase confirmation from BYT reminder list."""

    data = callback.data.split(":", maxsplit=1)
    if len(data) != 2:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.", show_alert=True)
        return

    try:
        item_id = int(data[1])
    except ValueError:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.", show_alert=True)
        return

    db = FinanceDatabase()
    wish = db.get_wish(item_id)
    if not wish or humanize_wishlist_category(wish.get("category", "")) != "–ë–´–¢":
        await callback.answer("–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    price = float(wish.get("price", 0) or 0)
    purchase_time = now_tz()
    db.decrease_savings(callback.from_user.id, "–±—ã—Ç", price)
    db.mark_wish_purchased(item_id, purchased_at=purchase_time)
    db.add_purchase(
        callback.from_user.id,
        wish.get("name", ""),
        price,
        humanize_wishlist_category(wish.get("category", "")),
        purchased_at=purchase_time,
    )

    await callback.answer()
    if callback.message:
        await _refresh_byt_reminder_message(
            callback.bot,
            callback.message.chat.id,
            callback.message.message_id,
            callback.from_user.id,
        )


@router.callback_query(F.data.startswith("byt_defer_menu"))
async def handle_byt_defer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    """Show BYT items to choose which to defer."""

    wish_id: int | None = None
    if callback.data and ":" in callback.data:
        parts = callback.data.split(":", maxsplit=1)
        if len(parts) == 2:
            try:
                wish_id = int(parts[1])
            except ValueError:
                wish_id = None
    if wish_id is None:
        data = await state.get_data()
        stored_id = data.get("current_byt_item_id")
        try:
            wish_id = int(stored_id) if stored_id is not None else None
        except (TypeError, ValueError):
            wish_id = None

    db = FinanceDatabase()
    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await callback.answer("–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö", show_alert=True)
        return
    now_dt = now_tz()
    items = db.list_active_byt_items_for_reminder(callback.from_user.id, now_dt)
    if wish_id is not None:
        await state.update_data(current_byt_item_id=wish_id)
        started = await _start_byt_defer_flow(callback, state, wish_id)
        if not started:
            await state.clear()
        return
    if not items:
        await state.clear()
        if callback.message:
            await callback.message.answer("–ù–µ—Ç –±—ã—Ç–æ–≤—ã—Ö –ø–æ–∫—É–ø–æ–∫ –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏.")
        else:
            await callback.bot.send_message(
                callback.from_user.id, "–ù–µ—Ç –±—ã—Ç–æ–≤—ã—Ö –ø–æ–∫—É–ø–æ–∫ –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏."
            )
        await callback.answer()
        return

    keyboard = _build_byt_defer_keyboard(items)
    await state.clear()
    if callback.message:
        try:
            await callback.message.edit_text("–ß–¢–û?", reply_markup=keyboard)
        except Exception:
            await callback.message.answer("–ß–¢–û?", reply_markup=keyboard)
    else:
        await callback.bot.send_message(callback.from_user.id, "–ß–¢–û?", reply_markup=keyboard)
    await callback.answer()


@router.callback_query(F.data.startswith("byt_defer_pick:"))
async def handle_byt_defer_pick(callback: CallbackQuery, state: FSMContext) -> None:
    """Start deferring selected BYT item."""

    data = callback.data.split(":", maxsplit=1)
    wish_id: int | None = None
    if len(data) == 2:
        try:
            wish_id = int(data[1])
        except ValueError:
            wish_id = None
    if wish_id is None:
        state_data = await state.get_data()
        try:
            wish_id = (
                int(state_data.get("defer_item_id"))
                if state_data.get("defer_item_id") is not None
                else None
            )
        except (TypeError, ValueError):
            wish_id = None
    if wish_id is None:
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω item_id", show_alert=True)
        return

    started = await _start_byt_defer_flow(callback, state, wish_id)
    if not started:
        await state.clear()


@router.message(
    BytDeferState.waiting_for_days,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "–û—á–∏—Å—Ç–∏—Ç—å",
            "‚úÖ –ì–∞–∑",
        }
    ),
)
async def handle_byt_defer_days(message: Message, state: FSMContext) -> None:
    """Handle calculator input for BYT defer days."""

    data = await state.get_data()
    current_sum = str(data.get("defer_days_str", "0"))
    display_chat_id = data.get("defer_display_chat_id", message.chat.id)
    display_message_id = data.get("defer_display_message_id")
    db = FinanceDatabase()

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            LOGGER.warning(
                "BYT defer submit missing entered_days user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                pass
            return
        try:
            days = int(amount_str)
        except (TypeError, ValueError):
            LOGGER.warning(
                "BYT defer submit invalid days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                amount_str,
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        if days <= 0:
            LOGGER.warning(
                "BYT defer submit non-positive days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                days,
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        try:
            settings_row = db.get_user_settings(message.from_user.id)
        except Exception as exc:
            LOGGER.error(
                "Failed to load user settings for BYT defer user_id=%s",
                message.from_user.id if message.from_user else "unknown",
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            try:
                await message.delete()
            except Exception:
                pass
            return
        max_days = int(settings_row.get("byt_defer_max_days", 365) or 365)
        if days < 1 or days > max_days:
            await message.answer(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ {max_days}.")
            try:
                await message.delete()
            except Exception:
                pass
            return

        raw_defer_item_id = data.get("defer_item_id")
        try:
            defer_item_id = int(raw_defer_item_id) if raw_defer_item_id is not None else None
        except (TypeError, ValueError):
            defer_item_id = None
        if defer_item_id is None:
            LOGGER.warning(
                "BYT defer submit missing item_id user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("–ù–µ –≤—ã–±—Ä–∞–Ω —Ç–æ–≤–∞—Ä –¥–ª—è –æ—Ç—Å—Ä–æ—á–∫–∏.")
            await state.clear()
            try:
                await message.delete()
            except Exception:
                pass
            return
        reminder_message_id = data.get("reminder_message_id")
        deferred_until = now_tz() + timedelta(days=days)

        try:
            db.set_wishlist_item_deferred_until(
                message.from_user.id, defer_item_id, deferred_until.isoformat()
            )
        except Exception as exc:
            LOGGER.error(
                "Failed to set BYT defer days user_id=%s item_id=%s days=%s",
                message.from_user.id if message.from_user else "unknown",
                defer_item_id,
                days,
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            try:
                await message.delete()
            except Exception:
                pass
            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        await message.answer(
            f"–û—Ç–ª–æ–∂–µ–Ω–æ –Ω–∞ {days} –¥–Ω.", reply_markup=ReplyKeyboardRemove()
        )

        if reminder_message_id:
            await _refresh_byt_reminder_message(
                message.bot,
                message.chat.id,
                int(reminder_message_id),
                message.from_user.id,
            )

        try:
            await message.delete()
        except Exception:
            pass
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        try:
            await message.bot.edit_message_text(
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {new_sum}",
            )
        except Exception:
            try:
                prompt = await message.answer(f": {new_sum}")
                new_display_message_id = prompt.message_id
                new_display_chat_id = message.chat.id
            except Exception:
                pass
    else:
        try:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
        except Exception:
            pass

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

    try:
        await message.delete()
    except Exception:
        pass


@router.message(BytDeferState.waiting_for_days)
async def handle_byt_defer_days_invalid(message: Message) -> None:
    """Prompt to use calculator buttons for defer days."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞ –Ω–∏–∂–µ.")


===== Bot/keyboards/__init__.py =====



===== Bot/keyboards/calculator.py =====
"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """–û–±—â–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Å—É–º–º."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å"),
            KeyboardButton(text="0"),
            KeyboardButton(text="‚úÖ –ì–∞–∑"),
        ],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


===== Bot/keyboards/household.py =====
"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="‚úÖ –î–∞"),
            KeyboardButton(text="‚ùå –ù–µ—Ç"),
            KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)


===== Bot/keyboards/main.py =====
"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")], [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


===== Bot/keyboards/settings.py =====
"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household payments settings."""

    inline_keyboard = [
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:add_payment")],
        [InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:del_payment_menu")],
        [InlineKeyboardButton(text="üîÑ –û–±–Ω—É–ª–∏—Ç—å", callback_data="hp:reset_questions")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_payments_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household payments in settings."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hp:del_payment:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for settings home screen."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="üìä –î–æ—Ö–æ–¥", callback_data="st:income"),
            InlineKeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç", callback_data="st:wishlist"),
        ],
        [InlineKeyboardButton(text="üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è", callback_data="st:byt_rules")],
        [InlineKeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏", callback_data="st:household_payments")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings home screen."""

    buttons = [
        [KeyboardButton(text="üìä –î–æ—Ö–æ–¥"), KeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç")],
        [KeyboardButton(text="üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è"), KeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:add_cat"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:del_cat_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –°—Ä–æ–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ", callback_data="wl:purchased_select_category"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for wishlist settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
        ],
        [KeyboardButton(text="üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_reply_keyboard(categories: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_purchased_mode_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist purchased mode."""

    buttons = [
        [KeyboardButton(text="–í—Å–µ–≥–¥–∞")],
        [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=category.get("title", ""),
            callback_data=f"{action_prefix}:{category.get('id')}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_purchased_mode_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist purchased mode."""

    inline_keyboard = [
        [InlineKeyboardButton(text="–í—Å–µ–≥–¥–∞", callback_data="wl:purchased_mode:always")],
        [InlineKeyboardButton(text="–ù–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π", callback_data="wl:purchased_mode:days")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT rules settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(
                text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="byt:toggle_enabled"
            ),
            InlineKeyboardButton(
                text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª", callback_data="byt:toggle_defer"
            ),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å", callback_data="byt:edit_max_defer_days"),
            InlineKeyboardButton(text="‚è∞ –¢–∞–π–º–µ—Ä", callback_data="byt:timer_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT rules settings."""

    buttons = [
        [
            KeyboardButton(text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª"),
        ],
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        ],
        [KeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT timer settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:add_time_hour"),
            InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:del_time_menu"),
        ],
        [
            InlineKeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é", callback_data="bt:reset_default"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT timer settings."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è"),
        ],
        [KeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_times_select_reply_keyboard(times: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT timer time."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_timer_times_select_keyboard(times: list[dict], action_prefix: str) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer time."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(
            InlineKeyboardButton(text=label, callback_data=f"{action_prefix}:{timer.get('id')}")
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_back_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with a single back button for settings mode."""

    buttons = [[KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for income settings actions."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:add"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:del_menu"),
        ],
        [
            InlineKeyboardButton(text="‚úèÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã", callback_data="inc:pct_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def income_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for income settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
        ],
        [KeyboardButton(text="‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_categories_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting income category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        title = category.get("title", "")
        percent = category.get("percent", 0)
        row.append(KeyboardButton(text=f"{title} ‚Äî {percent}%"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def income_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting an income category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=f"{category['title']} ({category['percent']}%)",
            callback_data=f"{action_prefix}:{category['id']}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_stub_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for stub sections with back button."""

    return InlineKeyboardMarkup(inline_keyboard=[])


===== Bot/main.py =====
"""Entry point for finance bot."""
import asyncio
import contextlib
import logging
import sys
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramUnauthorizedError

from Bot.config.settings import get_settings
from Bot.database.crud import FinanceDatabase
from Bot.handlers import (
    callbacks,
    common,
    finances,
    household_payments,
    settings,
    start,
    wishlist,
)
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.logging import init_logging


def register_routers(dispatcher: Dispatcher) -> None:
    """Register all routers to dispatcher."""

    dispatcher.include_router(start.router)
    dispatcher.include_router(finances.router)
    dispatcher.include_router(household_payments.router)
    dispatcher.include_router(settings.router)
    dispatcher.include_router(wishlist.router)
    dispatcher.include_router(callbacks.router)
    dispatcher.include_router(common.router)


def _token_fingerprint(token: str) -> str:
    if not token:
        return "empty"
    if len(token) <= 8:
        return f"{token[:2]}‚Ä¶{token[-2:]}"
    return f"{token[:4]}‚Ä¶{token[-4:]}"


def _validate_token(token: str) -> list[str]:
    if not token.strip():
        return ["BOT_TOKEN –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω"]

    errors = []
    if ":" not in token:
        errors.append("BOT_TOKEN –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ —Ç–æ–∫–µ–Ω (–Ω–µ—Ç ':')")
    if len(token) < 20:
        errors.append("BOT_TOKEN —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–æ–∂–∏–¥–∞–µ—Ç—Å—è > 20 —Å–∏–º–≤–æ–ª–æ–≤)")
    return errors


def _format_token_context(token_source: str, fingerprint: str, env_path: Path) -> str:
    if token_source == ".env":
        return f"token_source={token_source}, fingerprint={fingerprint}, env_path={env_path}"
    return f"token_source={token_source}, fingerprint={fingerprint}"


async def _run_byt_scheduler(bot: Bot, db: FinanceDatabase, timezone: ZoneInfo) -> None:
    """Background scheduler for BYT reminders."""

    while True:
        now = datetime.now(tz=timezone)
        user_ids = set(db.get_users_with_byt_timer_times()) | set(
            db.get_users_with_active_byt_wishes()
        )
        for uid in user_ids:
            await run_byt_timer_check(bot, db, user_id=uid, run_time=now)
        sleep_for = 60 - now.second - now.microsecond / 1_000_000
        await asyncio.sleep(max(sleep_for, 1))


async def main() -> None:
    """Run bot polling."""

    init_logging()
    settings = get_settings()
    logger = logging.getLogger(__name__)
    token = (settings.bot_token or "").strip()
    token_source = settings.bot_token_source
    fingerprint = _token_fingerprint(token)
    token_context = _format_token_context(token_source, fingerprint, project_root / ".env")

    errors = _validate_token(token)
    for error in errors:
        logger.error("%s (%s)", error, token_context)
    if errors:
        return

    bot = Bot(
        token=token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher()

    db = FinanceDatabase()
    register_routers(dp)

    try:
        await bot.me()
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
        await bot.session.close()
        return

    reminder_task = asyncio.create_task(
        _run_byt_scheduler(bot, db, settings.timezone)
    )
    try:
        logger.info(
            "Starting bot polling (%s)",
            token_context,
        )
        await dp.start_polling(bot)
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
    except Exception as error:  # noqa: BLE001
        logger.exception("Bot stopped due to error: %s", error)
    finally:
        reminder_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await reminder_task
        await bot.session.close()
        logger.info("Bot shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())


===== Bot/renderers/__init__.py =====
"""Renderer layer package."""


===== Bot/renderers/household.py =====
"""Renderers for household payments UI."""
from __future__ import annotations

import html
from typing import Dict, List

from aiogram.types import InlineKeyboardMarkup

from Bot.keyboards.household import household_payments_inline_keyboard


def render_household_questions_text(
    month: str,
    questions: list[dict],
    answers: dict[str, str],
    current_index: int | None,
) -> str:
    header = f"<b>–ë–´–¢–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò ‚Äî {html.escape(month)}</b>"
    lines = [header]
    for index, question in enumerate(questions, start=1):
        code = str(question.get("code", ""))
        text = html.escape(str(question.get("text", "")).strip())
        text = text.rstrip("?").strip()
        suffix = ""
        answer = answers.get(code)
        if answer == "yes":
            suffix = " ‚úÖ"
        elif answer == "no":
            suffix = " ‚ùå"
        display = text
        if current_index is not None and index - 1 == current_index:
            display = f"<b>{display.upper()}</b>"
        lines.append(f"{index}) {display}{suffix}")
    return "\n".join(lines)


def format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    if not items:
        return "–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π: (–ø—É—Å—Ç–æ)"

    lines = ["–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π:"]
    for index, item in enumerate(items, start=1):
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        code = str(item.get("code", ""))
        status = "‚ùå" if code in unpaid_set else "‚úÖ"
        if amount is not None:
            lines.append(f"{index}) {status} {title} ‚Äî {amount}")
        else:
            lines.append(f"{index}) {status} {title}")
    return "\n".join(lines)


def build_household_question_keyboard(
    question_code: str | None, show_back: bool
) -> InlineKeyboardMarkup:
    return household_payments_inline_keyboard(
        show_back=show_back, question_code=question_code
    )


===== Bot/services/__init__.py =====
"""Service layer package."""


===== Bot/services/household.py =====
"""Business logic for household payments flow."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable


@dataclass
class HouseholdFlowState:
    """Container for household flow state."""

    month: str
    questions: list[dict]
    current_step_index: int
    current_question_code: str | None
    answers: dict[str, str]
    processed_steps: set[str]


def build_household_questions(items: Iterable[dict]) -> list[dict]:
    return [
        {
            "code": str(item.get("code", "")),
            "text": str(item.get("text", "")),
            "amount": item.get("amount"),
        }
        for item in items
        if item.get("code") is not None
    ]


def build_answers_from_status(status_map: dict[str, int]) -> dict[str, str]:
    return {
        str(code): "yes"
        for code, value in status_map.items()
        if int(value) == 1
    }


def filter_unpaid_questions(
    questions: Iterable[dict], unpaid_codes: Iterable[str]
) -> list[dict]:
    unpaid_set = {str(code) for code in unpaid_codes}
    return [question for question in questions if question.get("code") in unpaid_set]


def get_current_question(questions: list[dict], index: int) -> dict | None:
    if index < 0 or index >= len(questions):
        return None
    return questions[index]


def get_next_index(index: int, questions: list[dict]) -> int:
    return min(index + 1, len(questions))


def get_previous_index(index: int) -> int:
    return max(index - 1, 0)


def should_ignore_answer(
    answers: dict[str, str],
    processed_steps: set[str],
    question_code: str,
    action: str,
) -> bool:
    return question_code in processed_steps and answers.get(question_code) == action


def normalize_processed_steps(value: Iterable[str] | None) -> set[str]:
    if not value:
        return set()
    return {str(item) for item in value}


def update_flow_state(
    month: str,
    questions: list[dict],
    current_step_index: int,
    answers: dict[str, str] | None,
    processed_steps: Iterable[str] | None,
) -> HouseholdFlowState:
    current_question = get_current_question(questions, current_step_index)
    return HouseholdFlowState(
        month=month,
        questions=questions,
        current_step_index=current_step_index,
        current_question_code=str(current_question.get("code"))
        if current_question
        else None,
        answers=dict(answers or {}),
        processed_steps=normalize_processed_steps(processed_steps),
    )


===== Bot/states/__init__.py =====



===== Bot/states/money_states.py =====
"""FSM states for money flow."""
from aiogram.fsm.state import State, StatesGroup


class MoneyState(StatesGroup):
    """State machine for income distribution."""

    waiting_for_amount = State()
    confirm_category = State()
    waiting_for_purchase_confirmation = State()


class HouseholdPaymentsState(StatesGroup):
    """State machine for household payments flow."""

    waiting_for_answer = State()


class HouseholdSettingsState(StatesGroup):
    """State machine for household payments settings."""

    waiting_for_title = State()
    waiting_for_amount = State()
    waiting_for_removal = State()


class IncomeSettingsState(StatesGroup):
    """State machine for income settings."""

    waiting_for_category_title = State()
    waiting_for_new_category_percent = State()
    waiting_for_removal = State()
    waiting_for_percent_category = State()
    waiting_for_percent = State()


===== Bot/states/wishlist_states.py =====
"""FSM states for wishlist."""
from aiogram.fsm.state import State, StatesGroup


class WishlistState(StatesGroup):
    """State machine for wishlist management."""

    waiting_for_name = State()
    waiting_for_price = State()
    waiting_for_url = State()
    waiting_for_category = State()


class WishlistBytReminderState(StatesGroup):
    """State machine for BYT reminder flow."""

    waiting_answer = State()


class BytDeferState(StatesGroup):
    """State machine for deferring BYT wishlist items."""

    waiting_for_days = State()


class WishlistSettingsState(StatesGroup):
    """States for wishlist settings inputs."""

    waiting_for_category_title = State()
    waiting_for_removal = State()
    waiting_for_purchased_category = State()
    waiting_for_purchased_mode = State()
    waiting_for_purchased_days = State()


class BytSettingsState(StatesGroup):
    """States for BYT settings inputs."""

    waiting_for_max_defer_days = State()


class BytTimerState(StatesGroup):
    """States for BYT timer settings inputs."""

    waiting_for_removal = State()
    waiting_for_time_add = State()
    waiting_for_hour = State()
    waiting_for_minute = State()


===== Bot/utils/__init__.py =====



===== Bot/utils/datetime_utils.py =====
"""Datetime utilities for the bot."""
from datetime import datetime, timedelta

from Bot.config import settings


def now_tz() -> datetime:
    """Return current datetime in configured timezone."""

    return datetime.now(tz=settings.TIMEZONE)


def current_month_str(now: datetime | None = None) -> str:
    """Return current month label as YYYY-MM using configured timezone."""

    current = now or now_tz()
    return f"{current.year:04d}-{current.month:02d}"


def add_one_month(source: datetime) -> datetime:
    """Add one calendar month to datetime without external dependencies."""

    year = source.year + (source.month // 12)
    month = 1 if source.month == 12 else source.month + 1
    last_day = (
        (source.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    ).day
    day = min(source.day, last_day)
    return source.replace(year=year, month=month, day=day)


===== Bot/utils/logging.py =====
"""Logging utilities."""
import logging

from Bot.config.logging_config import setup_logging


def init_logging() -> logging.Logger:
    """Initialize logging and return module logger.

    Returns:
        logging.Logger: Configured logger instance.
    """

    setup_logging()
    return logging.getLogger(__name__)


===== Bot/utils/savings.py =====
"""Savings utility helpers."""
from typing import Any, Dict, List, Tuple


def format_savings_summary(savings: Dict[str, Dict[str, Any]]) -> str:
    """Format savings summary for user message."""

    if not savings:
        return "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π."

    lines: List[str] = []
    for category, data in savings.items():
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        purpose = data.get("purpose", "")
        line = f"{category}: {current:.2f}"
        if goal and goal > 0:
            progress = min(current / goal * 100, 100)
            extra = f" (—Ü–µ–ª—å {goal:.2f} –¥–ª—è '{purpose}', –ø—Ä–æ–≥—Ä–µ—Å—Å {progress:.1f}%)"
            line = f"{line}{extra}"
        lines.append(line)
    return "\n".join(lines)


def find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> Tuple[str, Dict[str, Any]] | Tuple[None, None]:
    """Find first saving goal that has been reached."""

    for category, data in savings.items():
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        if goal and current >= goal:
            return category, data
    return None, None


===== Bot/utils/ui_cleanup.py =====
import logging
from typing import Iterable, List, Optional

from aiogram import Bot
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext

LOGGER = logging.getLogger(__name__)


async def ui_register_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Track a UI message id for later cleanup."""

    data = await state.get_data()
    ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    if message_id not in ids:
        ids.append(int(message_id))
    if len(ids) > 300:
        ids = ids[-300:]
    current_chat_id = data.get("ui_chat_id")
    await state.update_data(
        ui_chat_id=current_chat_id if current_chat_id is not None else chat_id,
        ui_tracked_message_ids=ids,
    )


async def ui_register_protected_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    """Track a UI message id that should never be deleted."""

    await ui_register_message(state, chat_id, message_id)


async def ui_register_user_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Track a user message id for later cleanup."""

    await ui_register_message(state, chat_id, message_id)


async def ui_set_welcome_message(
    bot: Bot, state: FSMContext, chat_id: int, text: str
) -> int:
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    if welcome_id is not None:
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=int(welcome_id),
                text=text,
            )
            LOGGER.info(
                "Reused welcome message (chat_id=%s, message_id=%s)",
                chat_id,
                welcome_id,
            )
            return int(welcome_id)
        except TelegramBadRequest as exc:
            if "message is not modified" in str(exc).lower():
                LOGGER.info(
                    "Welcome message already up to date (chat_id=%s, message_id=%s)",
                    chat_id,
                    welcome_id,
                )
                return int(welcome_id)
            LOGGER.warning(
                "Failed to edit welcome message (chat_id=%s, message_id=%s): %s",
                chat_id,
                welcome_id,
                exc,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error editing welcome message (chat_id=%s, message_id=%s)",
                chat_id,
                welcome_id,
                exc_info=True,
            )
    sent = await bot.send_message(chat_id=chat_id, text=text)
    await state.update_data(
        ui_chat_id=chat_id, ui_welcome_message_id=int(sent.message_id)
    )
    LOGGER.info(
        "Created welcome message (chat_id=%s, message_id=%s)",
        chat_id,
        sent.message_id,
    )
    if welcome_id is not None and int(welcome_id) != int(sent.message_id):
        try:
            await bot.delete_message(chat_id=chat_id, message_id=int(welcome_id))
        except TelegramBadRequest as exc:
            LOGGER.warning(
                "Failed to delete previous welcome message (chat_id=%s, message_id=%s): %s",
                chat_id,
                welcome_id,
                exc,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error deleting previous welcome message (chat_id=%s, message_id=%s)",
                chat_id,
                welcome_id,
                exc_info=True,
            )
    return int(sent.message_id)


async def ui_set_settings_mode_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_set_screen_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_track_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_cleanup_to_context(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    context_name: str,
    keep_ids: List[int] | None = None,
) -> None:
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    tracked_ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    legacy_ids: List[int] = list(data.get("ui_message_ids") or [])
    combined_ids = list(dict.fromkeys([*legacy_ids, *tracked_ids]))

    keep_id_set = {int(welcome_id)} if welcome_id else set()
    if keep_ids:
        keep_id_set.update(int(item) for item in keep_ids if item is not None)
    delete_ids = [int(mid) for mid in tracked_ids if int(mid) not in keep_id_set]

    for message_id in delete_ids:
        try:
            await bot.delete_message(chat_id=chat_id, message_id=message_id)
        except TelegramBadRequest as exc:
            LOGGER.warning(
                "Failed to delete message (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
                exc_info=True,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error deleting message (chat_id=%s, message_id=%s)",
                chat_id,
                message_id,
            )

    remaining_ids = [mid for mid in combined_ids if int(mid) in keep_id_set]
    await state.update_data(
        ui_tracked_message_ids=[],
    )


async def ui_cleanup_messages(bot: Bot, state: FSMContext, *args, **kwargs) -> None:
    data = await state.get_data()
    chat_id = kwargs.get("chat_id") or data.get("ui_chat_id")
    if chat_id is None:
        return
    await ui_cleanup_to_context(bot, state, int(chat_id), "MAIN_MENU")


===== Bot/utils/ui_flow.py =====
import logging
from collections.abc import Awaitable, Callable
from typing import Any

from aiogram import Bot
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

LOGGER = logging.getLogger(__name__)


async def ui_get(state: FSMContext) -> dict[str, Any]:
    data = await state.get_data()
    return {
        "greeting_id": data.get("ui_welcome_message_id"),
        "tracked_ids": list(data.get("ui_tracked_message_ids") or []),
    }


async def ui_set_greeting(state: FSMContext, message_id: int) -> None:
    ui = await ui_get(state)
    if ui.get("greeting_id") is not None:
        return
    # greeting_id –Ω–µ —É–¥–∞–ª—è–µ–º –Ω–∏–∫–æ–≥–¥–∞
    await state.update_data(ui_welcome_message_id=int(message_id))


async def ui_track(
    state: FSMContext, message_id: int, kind: str, screen: str | None
) -> None:
    ui = await ui_get(state)
    tracked: list[int] = list(ui.get("tracked_ids") or [])
    tracked.append(int(message_id))
    if len(tracked) > 300:
        tracked = tracked[-300:]
    await state.update_data(ui_tracked_message_ids=tracked)


async def ui_set_screen_message(
    state: FSMContext, screen: str, message_id: int
) -> None:
    await ui_track(state, message_id, kind="ui", screen=screen)


async def ui_cleanup_for_transition(
    bot: Bot, state: FSMContext, chat_id: int, keep_greeting: bool = True
) -> None:
    ui = await ui_get(state)
    greeting_id = ui.get("greeting_id") if keep_greeting else None
    tracked: list[int] = list(ui.get("tracked_ids") or [])
    ids = [int(item) for item in tracked]
    for message_id in ids:
        if greeting_id and message_id == greeting_id:
            continue
        try:
            await bot.delete_message(chat_id=chat_id, message_id=message_id)
        except TelegramBadRequest as exc:
            LOGGER.warning(
                "Failed to delete message (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
                exc_info=True,
            )
        except Exception:
            LOGGER.warning(
                "Unexpected error deleting message (chat_id=%s, message_id=%s)",
                chat_id,
                message_id,
                exc_info=True,
            )
    await state.update_data(ui_tracked_message_ids=[])


async def ui_transition(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    new_screen: str,
    send_screen: Callable[[], Awaitable[Message]],
) -> Message:
    await ui_cleanup_for_transition(bot, state, chat_id, keep_greeting=True)
    sent = await send_screen()
    await ui_set_screen_message(state, new_screen, sent.message_id)
    return sent


===== __init__.py =====



===== tests/__init__.py =====



===== tests/integration/__init__.py =====



===== tests/integration/test_database.py =====
"""Integration tests for database operations."""
from Bot.database.crud import FinanceDatabase


def setup_module(module) -> None:  # noqa: D401
    """Clean database tables before tests."""

    db = FinanceDatabase()
    cursor = db.connection.cursor()
    cursor.execute("DELETE FROM wishes")
    cursor.execute("DELETE FROM purchases")
    cursor.execute("DELETE FROM savings")
    db.connection.commit()


def test_add_and_get_wish() -> None:
    """Add wish and retrieve it."""

    db = FinanceDatabase()
    wish_id = db.add_wish(1, "Test", 10.0, None, "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã")
    wish = db.get_wish(wish_id)
    assert wish is not None
    assert wish["name"] == "Test"


def test_update_saving_and_purchase() -> None:
    """Update savings and add purchase entry."""

    db = FinanceDatabase()
    db.update_saving(1, "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", 20.0)
    savings = db.get_user_savings(1)
    assert savings.get("–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", {}).get("current") == 20.0
    db.add_purchase(1, "Test", 10.0, "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã")
    purchases = db.get_purchases_by_user(1)
    assert len(purchases) == 1


===== tests/run_all_tests.py =====
"""Run all pytest suites."""
import pytest


if __name__ == "__main__":
    raise SystemExit(pytest.main(["-q", "tests"]))


===== tests/test_runner.py =====
"""Helper to run tests programmatically."""
import subprocess
import sys
from pathlib import Path


def main() -> int:
    """Run pytest suite and return exit code."""

    root = Path(__file__).resolve().parents[1]
    result = subprocess.run([sys.executable, "-m", "pytest", "-q", str(root / "tests")], check=False)
    return result.returncode


if __name__ == "__main__":
    raise SystemExit(main())


===== tests/unit/__init__.py =====



===== tests/unit/test_handlers.py =====
"""Tests for handler utilities."""
from Bot.handlers.finances import _format_savings_summary, _find_reached_goal


def test_format_savings_summary_empty() -> None:
    """Empty savings returns default message."""

    assert _format_savings_summary({}) == "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π."


def test_find_reached_goal() -> None:
    """Goal detection returns first satisfied category."""

    savings = {
        "–∫–∞—Ç–µ–≥–æ—Ä–∏—è": {"current": 150, "goal": 100, "purpose": "test"},
        "–¥—Ä—É–≥–∞—è": {"current": 50, "goal": 100, "purpose": "none"},
    }
    category, data = _find_reached_goal(savings)
    assert category == "–∫–∞—Ç–µ–≥–æ—Ä–∏—è"
    assert data["goal"] == 100


===== tests/unit/test_household_payments.py =====
"""Tests for household payments workflow."""
from datetime import datetime

import pytest

from Bot.config import settings
from Bot.database.crud import FinanceDatabase
from Bot.handlers.household_payments import reset_household_cycle_if_needed
from Bot.utils.datetime_utils import current_month_str


@pytest.mark.asyncio
async def test_reset_cycle_creates_statuses_after_threshold() -> None:
    """Statuses should appear after threshold date only once."""

    db = FinanceDatabase()
    user_id = 99991
    month = "2025-01"
    db.connection.execute("DELETE FROM household_payments WHERE user_id = ?", (user_id,))
    db.connection.execute(
        "DELETE FROM household_payment_items WHERE user_id = ?", (user_id,)
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    before_threshold = datetime(2025, 1, 5, 10, 0, tzinfo=settings.TIMEZONE)
    await reset_household_cycle_if_needed(user_id, db, now=before_threshold)
    assert not await db.household_status_exists(user_id, month)

    after_threshold = datetime(2025, 1, 6, 12, 0, tzinfo=settings.TIMEZONE)
    await reset_household_cycle_if_needed(user_id, db, now=after_threshold)
    assert await db.has_unpaid_household_questions(user_id, month)

    await reset_household_cycle_if_needed(user_id, db, now=after_threshold)
    cursor = db.connection.execute(
        "SELECT COUNT(*) FROM household_payments WHERE user_id = ? AND month = ?",
        (user_id, month),
    )
    assert cursor.fetchone()[0] == len(items)


@pytest.mark.asyncio
async def test_mark_and_check_unpaid_questions() -> None:
    """Marking paid questions should update unpaid check."""

    db = FinanceDatabase()
    user_id = 99992
    month = current_month_str(datetime(2025, 2, 6, 12, 0, tzinfo=settings.TIMEZONE))
    db.connection.execute("DELETE FROM household_payments WHERE user_id = ?", (user_id,))
    db.connection.execute(
        "DELETE FROM household_payment_items WHERE user_id = ?", (user_id,)
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    await db.init_household_questions_for_month(user_id, month)
    assert await db.has_unpaid_household_questions(user_id, month)

    for item in items:
        await db.mark_household_question_paid(user_id, month, str(item.get("code")))
    assert not await db.has_unpaid_household_questions(user_id, month)


@pytest.mark.asyncio
async def test_question_flow_and_savings_update() -> None:
    """Yes/No answers adjust savings and skip paid questions."""

    db = FinanceDatabase()
    user_id = 99993
    month = current_month_str(datetime(2025, 3, 6, 12, 0, tzinfo=settings.TIMEZONE))
    db.connection.execute("DELETE FROM household_payments WHERE user_id = ?", (user_id,))
    db.connection.execute("DELETE FROM savings WHERE user_id = ? AND category = '–±—ã—Ç'", (user_id,))
    db.connection.execute(
        "DELETE FROM household_payment_items WHERE user_id = ?", (user_id,)
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    db.update_saving(user_id, "–±—ã—Ç", 5000)
    await db.init_household_questions_for_month(user_id, month)

    unpaid = await db.get_unpaid_household_questions(user_id, month)
    assert unpaid
    first_code = str(unpaid[0])
    first_item = next(item for item in items if str(item.get("code")) == first_code)
    amount = float(first_item.get("amount") or 0)

    changed = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="yes",
    )
    assert changed is True

    savings_map = db.get_user_savings_map(user_id)
    assert savings_map.get("–±—ã—Ç") == 5000 - amount

    changed_again = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="yes",
    )
    assert changed_again is False

    changed_back = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="no",
    )
    assert changed_back is True
    savings_map = db.get_user_savings_map(user_id)
    assert savings_map.get("–±—ã—Ç") == 5000


===== tests/unit/test_household_renderers.py =====
"""Tests for household renderers."""

from Bot.renderers.household import format_household_items, render_household_questions_text


def test_render_questions_text_marks_answers() -> None:
    questions = [
        {"code": "q1", "text": "–û–ø–ª–∞—Ç–∏–ª –∏–Ω—Ç–µ—Ä–Ω–µ—Ç?", "amount": 100},
        {"code": "q2", "text": "–û–ø–ª–∞—Ç–∏–ª —Å–≤–µ—Ç?", "amount": 200},
    ]
    answers = {"q1": "yes", "q2": "no"}
    text = render_household_questions_text("2025-02", questions, answers, current_index=1)
    assert "‚úÖ" in text
    assert "‚ùå" in text
    assert "2025-02" in text


def test_format_household_items() -> None:
    items = [
        {"code": "q1", "text": "–ò–Ω—Ç–µ—Ä–Ω–µ—Ç?", "amount": 100},
        {"code": "q2", "text": "–°–≤–µ—Ç?", "amount": 200},
    ]
    text = format_household_items(items, unpaid_set={"q2"})
    assert "‚úÖ" in text
    assert "‚ùå" in text
    assert "–ò–Ω—Ç–µ—Ä–Ω–µ—Ç" in text


===== tests/unit/test_household_services.py =====
"""Tests for household services."""

from Bot.services.household import (
    build_household_questions,
    get_current_question,
    get_next_index,
    get_previous_index,
    should_ignore_answer,
    update_flow_state,
)


def test_flow_state_and_navigation() -> None:
    questions = build_household_questions(
        [
            {"code": "q1", "text": "–ü–µ—Ä–≤—ã–π?", "amount": 100},
            {"code": "q2", "text": "–í—Ç–æ—Ä–æ–π?", "amount": 200},
        ]
    )
    flow = update_flow_state(
        month="2025-01",
        questions=questions,
        current_step_index=0,
        answers={},
        processed_steps=[],
    )
    assert flow.current_question_code == "q1"
    assert get_current_question(questions, 1)["code"] == "q2"
    assert get_next_index(0, questions) == 1
    assert get_next_index(1, questions) == 2
    assert get_previous_index(0) == 0
    assert get_previous_index(1) == 0


def test_idempotency_check() -> None:
    answers = {"q1": "yes"}
    processed_steps = {"q1"}
    assert should_ignore_answer(answers, processed_steps, "q1", "yes") is True
    assert should_ignore_answer(answers, processed_steps, "q1", "no") is False
    assert should_ignore_answer(answers, processed_steps, "q2", "yes") is False


===== tests/unit/test_imports.py =====
"""Basic import tests."""


def test_import_main() -> None:
    """Ensure main module is importable."""

    import Bot.main  # noqa: F401


def test_import_handlers() -> None:
    """Ensure handlers modules are importable."""

    import Bot.handlers.start  # noqa: F401
    import Bot.handlers.finances  # noqa: F401
    import Bot.handlers.household_payments  # noqa: F401
    import Bot.handlers.wishlist  # noqa: F401
    import Bot.handlers.callbacks  # noqa: F401
    import Bot.handlers.common  # noqa: F401


===== tests/unit/test_ui_cleanup.py =====
"""Tests for UI cleanup utilities."""
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock
import asyncio
import sys
import types
from pathlib import Path

import pytest

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

if "aiogram" not in sys.modules:
    aiogram = types.ModuleType("aiogram")

    class DummyRouter:
        def message(self, *args, **kwargs):
            def decorator(func):
                return func

            return decorator

    class DummyF:
        class _Field:
            def __eq__(self, other):
                return ("eq", other)

        text = _Field()

    class Bot:
        pass

    aiogram.F = DummyF()
    aiogram.Router = DummyRouter
    aiogram.Bot = Bot

    exceptions = types.ModuleType("aiogram.exceptions")

    class TelegramBadRequest(Exception):
        pass

    exceptions.TelegramBadRequest = TelegramBadRequest
    aiogram.exceptions = exceptions

    filters = types.ModuleType("aiogram.filters")

    class Command:
        def __init__(self, *args, **kwargs):
            return None

    filters.Command = Command
    aiogram.filters = filters

    fsm = types.ModuleType("aiogram.fsm")
    fsm_context = types.ModuleType("aiogram.fsm.context")

    class FSMContext:
        pass

    fsm_context.FSMContext = FSMContext
    fsm.context = fsm_context
    aiogram.fsm = fsm

    types_mod = types.ModuleType("aiogram.types")

    class Message:
        pass

    class ReplyKeyboardMarkup:
        pass

    class InlineKeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    class InlineKeyboardMarkup:
        def __init__(self, *args, **kwargs):
            return None

    class KeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    types_mod.Message = Message
    types_mod.ReplyKeyboardMarkup = ReplyKeyboardMarkup
    types_mod.InlineKeyboardButton = InlineKeyboardButton
    types_mod.InlineKeyboardMarkup = InlineKeyboardMarkup
    types_mod.KeyboardButton = KeyboardButton
    aiogram.types = types_mod

    sys.modules["aiogram"] = aiogram
    sys.modules["aiogram.exceptions"] = exceptions
    sys.modules["aiogram.filters"] = filters
    sys.modules["aiogram.fsm"] = fsm
    sys.modules["aiogram.fsm.context"] = fsm_context
    sys.modules["aiogram.types"] = types_mod

from Bot.handlers.start import back_to_main
from Bot.utils.ui_cleanup import ui_cleanup_to_context, ui_register_message


class DummyState:
    """Minimal FSMContext stand-in for unit tests."""

    def __init__(self, initial=None) -> None:
        self.data = dict(initial or {})

    async def get_data(self) -> dict:
        return dict(self.data)

    async def update_data(self, **kwargs) -> None:
        self.data.update(kwargs)


class DummyBot:
    """Minimal bot mock with async delete_message."""

    def __init__(self) -> None:
        self.delete_message = AsyncMock()


def test_ui_cleanup_keeps_welcome() -> None:
    """Cleanup removes tracked messages while keeping welcome."""

    async def run_test() -> None:
        state = DummyState()
        await ui_register_message(state, 1, 10)
        await ui_register_message(state, 1, 11)
        await ui_register_message(state, 1, 12)
        await state.update_data(ui_welcome_message_id=11)

        bot = DummyBot()
        await ui_cleanup_to_context(bot, state, 1, "MAIN_MENU", keep_ids=[11])

        deleted_ids = {
            call.kwargs["message_id"] for call in bot.delete_message.call_args_list
        }
        assert deleted_ids == {10, 12}
        data = await state.get_data()
        assert data["ui_tracked_message_ids"] == [11]
        assert data["ui_message_ids"] == [11]

    asyncio.run(run_test())


def test_back_to_main_deletes_and_cleans(monkeypatch) -> None:
    """back_to_main deletes user message, cleans UI, and renders menu."""

    async def run_test() -> None:
        state = DummyState({"ui_welcome_message_id": 55})
        cleanup_mock = AsyncMock()
        set_screen_mock = AsyncMock()
        build_menu_mock = AsyncMock(return_value=MagicMock())

        monkeypatch.setattr("Bot.handlers.start.ui_cleanup_to_context", cleanup_mock)
        monkeypatch.setattr("Bot.handlers.start.ui_set_screen_message", set_screen_mock)
        monkeypatch.setattr(
            "Bot.handlers.start.build_main_menu_for_user", build_menu_mock
        )

        sent_message = SimpleNamespace(chat=SimpleNamespace(id=1), message_id=99)
        message = SimpleNamespace(
            chat=SimpleNamespace(id=1),
            from_user=SimpleNamespace(id=2),
            message_id=10,
            bot=SimpleNamespace(),
        )
        message.delete = AsyncMock()
        message.answer = AsyncMock(return_value=sent_message)

        await back_to_main(message, state)

        message.delete.assert_awaited_once()
        cleanup_mock.assert_awaited_once()
        _, kwargs = cleanup_mock.await_args
        assert kwargs["keep_ids"] == [55]
        build_menu_mock.assert_awaited_once_with(2)
        set_screen_mock.assert_awaited_once_with(state, 1, 99)

    asyncio.run(run_test())


===== tests/unit/test_utils.py =====
"""Utility tests."""
from Bot.utils.logging import init_logging


def test_init_logging_returns_logger() -> None:
    """init_logging should return a logger instance."""

    logger = init_logging()
    assert logger.name == "Bot.utils.logging"


===== utils/__init__.py =====
from Bot.utils import *  # noqa: F401,F403


===== utils/logging.py =====
from Bot.utils.logging import *  # noqa: F401,F403

