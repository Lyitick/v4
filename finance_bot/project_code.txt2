        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                UPDATE byt_timer_times
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, timer_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate BYT timer time %s for user %s: %s",
                timer_id,
                user_id,
                error,
            )

    def reset_byt_timer_times(self, user_id: int) -> None:
        """Reset BYT timer times to defaults."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "UPDATE byt_timer_times SET is_active = 0 WHERE user_id = ?",
                (user_id,),
            )
            for hour, minute in [(12, 0), (18, 0)]:
                cursor.execute(
                    """
                    INSERT INTO byt_timer_times (user_id, hour, minute, is_active)
                    VALUES (?, ?, ?, 1)
                    """,
                    (user_id, hour, minute),
                )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to reset BYT timer times for user %s: %s", user_id, error)

    def get_users_with_byt_timer_times(self) -> List[int]:
        """Return users that have BYT timer times configured."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT DISTINCT user_id
                FROM byt_timer_times
                WHERE is_active = 1
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with BYT timer times: %s", error)
            return []

    def get_users_with_active_byt_wishes(self) -> List[int]:
        """Return user ids that have active BYT wishes."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT DISTINCT user_id
                FROM wishes
                WHERE category IN ('byt', '–ë–´–¢') AND (is_purchased = 0 OR is_purchased IS NULL)
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with active BYT wishes: %s", error)
            return []

    def cleanup_old_byt_purchases(self, now: Optional[datetime] = None) -> None:
        """Remove BYT purchases older than one month from purchases and wishes."""

        current_time = now or now_tz()
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "SELECT id, purchased_at FROM purchases WHERE category IN ('byt', '–ë–´–¢')"
            )
            purchases = cursor.fetchall()
            ids_to_delete: list[int] = []
            for purchase in purchases:
                timestamp = purchase["purchased_at"]
                if not timestamp:
                    continue
                try:
                    purchase_dt = datetime.fromisoformat(timestamp)
                    if purchase_dt.tzinfo is None:
                        purchase_dt = purchase_dt.replace(tzinfo=settings.TIMEZONE)
                except ValueError:
                    continue
                if add_one_month(purchase_dt) <= current_time:
                    ids_to_delete.append(int(purchase["id"]))

            if ids_to_delete:
                cursor.execute(
                    "DELETE FROM purchases WHERE id IN ({})".format(
                        ",".join("?" * len(ids_to_delete))
                    ),
                    ids_to_delete,
                )

            cursor.execute(
                "SELECT id, purchased_at FROM wishes WHERE category IN ('byt', '–ë–´–¢') AND is_purchased = 1"
            )
            wish_rows = cursor.fetchall()
            wish_ids: list[int] = []
            for wish in wish_rows:
                purchased_at = wish["purchased_at"]
                if not purchased_at:
                    continue
                try:
                    wish_dt = datetime.fromisoformat(purchased_at)
                    if wish_dt.tzinfo is None:
                        wish_dt = wish_dt.replace(tzinfo=settings.TIMEZONE)
                except ValueError:
                    continue
                if add_one_month(wish_dt) <= current_time:
                    wish_ids.append(int(wish["id"]))

            if wish_ids:
                cursor.execute(
                    "DELETE FROM wishes WHERE id IN ({})".format(",".join("?" * len(wish_ids))),
                    wish_ids,
                )
            if ids_to_delete or wish_ids:
                self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to cleanup old BYT purchases: %s", error)

    def close(self) -> None:
        """Close database connection."""

        try:
            self.connection.close()
            LOGGER.info("Database connection closed")
        except sqlite3.Error as error:
            LOGGER.error("Failed to close database connection: %s", error)


===== Bot/database/models.py =====

"""Database model helpers."""
from dataclasses import dataclass
from typing import Optional


@dataclass
class Saving:
    """Saving record representation."""

    id: int
    user_id: int
    category: str
    current: float
    goal: float
    purpose: str


@dataclass
class Wish:
    """Wish record representation."""

    id: int
    user_id: int
    name: str
    price: float
    url: Optional[str]
    category: str
    is_purchased: bool
    saved_amount: float
    purchased_at: Optional[str]
    deferred_until: Optional[str]


@dataclass
class Purchase:
    """Purchase record representation."""

    id: int
    user_id: int
    wish_name: str
    price: float
    category: str
    purchased_at: str


===== Bot/handlers/__init__.py =====



===== Bot/handlers/callbacks.py =====

"""Callback query handlers."""
import logging
from typing import Dict
from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup

from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.finances import (
    _format_savings_summary,
    show_affordable_wishes,
)
from Bot.keyboards.main import back_only_keyboard, wishlist_categories_keyboard
from Bot.states.wishlist_states import WishlistState
from Bot.handlers.wishlist import (
    WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY,
    _get_user_wishlist_categories,
    humanize_wishlist_category,
)
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()

@router.callback_query(F.data.startswith("wlcat:"))
async def handle_category_selection(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle category selection for viewing or adding wishes."""

    try:
        category_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è", show_alert=True)
        return

    db = FinanceDatabase()
    category_row = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category_row:
        await callback.answer("–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return

    category_code = category_row.get("title", "")
    category = humanize_wishlist_category(category_code)
    category_code_norm = "byt" if category == "–ë–´–¢" else category_code
    data = await state.get_data()
    current_state = await state.get_state()

    if current_state == WishlistState.waiting_for_category.state:
        await _finalize_wish(callback, state, category_code_norm, category)
        return

    await _send_wishes_list(callback, category)


@router.callback_query(F.data == "wishlist_skip_url")
async def skip_wishlist_url(callback: CallbackQuery, state: FSMContext) -> None:
    """Skip wishlist URL step via inline button."""

    await callback.answer()
    current_state = await state.get_state()
    if current_state != WishlistState.waiting_for_url.state:
        return

    await state.update_data(url=None)
    await state.set_state(WishlistState.waiting_for_category)
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != "category":
        stack.append("category")
    await state.update_data(wl_add_step_stack=stack)
    try:
        await callback.message.delete()
    except Exception:
        pass
    await callback.message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∂–µ–ª–∞–Ω–∏—è.",
        reply_markup=wishlist_categories_keyboard(
            _get_user_wishlist_categories(FinanceDatabase(), callback.from_user.id)
        ),
    )
    await callback.message.answer(
        "–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.", reply_markup=back_only_keyboard()
    )


async def _finalize_wish(
    callback: CallbackQuery,
    state: FSMContext,
    category_code: str,
    humanized_category: str,
) -> None:
    """Finalize wish creation after category selection."""

    db = FinanceDatabase()
    data = await state.get_data()
    wish_id = db.add_wish(
        user_id=callback.from_user.id,
        name=data.get("name", ""),
        price=float(data.get("price", 0)),
        url=data.get("url"),
        category=category_code,
    )
    lines = [
        f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {humanized_category}",
        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {data.get('name')}",
        f"–¶–µ–Ω–∞: {data.get('price')}",
        f"ID: {wish_id}",
    ]
    url = data.get("url")
    if url:
        lines.insert(3, f"–°—Å—ã–ª–∫–∞: {url}")
    info = await callback.message.answer("\n".join(lines))
    await ui_register_message(state, info.chat.id, info.message_id)
    sent = await callback.message.answer(
        "‚úÖ –ñ–µ–ª–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ",
        reply_markup=await build_main_menu_for_user(callback.from_user.id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)
    await state.clear()
    LOGGER.info("User %s added wish %s", callback.from_user.id, wish_id)


async def _send_wishes_list(callback: CallbackQuery, category: str) -> None:
    """Send wishlist items for selected category."""

    db = FinanceDatabase()
    wishes = db.get_wishes_by_user(callback.from_user.id)
    savings_map = db.get_user_savings_map(callback.from_user.id)
    filtered = [
        wish
        for wish in wishes
        if (
            humanize_wishlist_category(wish.get("category", ""))
            == humanize_wishlist_category(category)
        )
        and not wish.get("is_purchased")
    ]

    if not filtered:
        await callback.message.edit_text(
            "–ñ–µ–ª–∞–Ω–∏–π –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç.",
            reply_markup=wishlist_categories_keyboard(
                _get_user_wishlist_categories(db, callback.from_user.id)
            ),
        )
        return

    for wish in filtered:
        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        savings_category = WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY.get(wishlist_category, "")
        saved_amount = float(savings_map.get(savings_category, 0.0) or 0.0)
        price = float(wish.get("price", 0) or 0.0)

        if price > 0:
            progress = min(saved_amount / price, 1.0)
        else:
            progress = 0.0
        total_blocks = 10
        filled_blocks = int(progress * total_blocks)
        bar = "‚ñ†" * filled_blocks + "‚ñ°" * (total_blocks - filled_blocks)
        remaining = max(price - saved_amount, 0.0)
        progress_percent = round(progress * 100)

        lines = [
            f"{wish['name']} ‚Äî {price:.2f} ({wishlist_category})",
            f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {bar} {progress_percent}%",
            f"–ù–∞–∫–æ–ø–ª–µ–Ω–æ: {saved_amount:.2f}, –æ—Å—Ç–∞–ª–æ—Å—å: {remaining:.2f}",
        ]
        if wish.get("url"):
            lines.append(f"–°—Å—ã–ª–∫–∞: {wish['url']}")
        text = "\n".join(lines)
        inline_kb = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="–ö—É–ø–∏–ª", callback_data=f"wish_buy_{wish['id']}")]]
        )
        await callback.message.answer(text, reply_markup=inline_kb)


@router.callback_query(F.data.startswith("wish_buy_"))
async def handle_wish_purchase(callback: CallbackQuery) -> None:
    """Handle purchase of a wish."""

    wish_id = int(callback.data.split("wish_buy_")[-1])
    db = FinanceDatabase()
    wish = db.get_wish(wish_id)

    if not wish:
        await callback.answer("–ñ–µ–ª–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
        return

    wishlist_category = humanize_wishlist_category(wish.get("category"))
    savings_category = WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY.get(wishlist_category)

    if not savings_category:
        LOGGER.error(
            "No savings mapping for wishlist category %s (wish_id=%s, user_id=%s)",
            wishlist_category,
            wish_id,
            callback.from_user.id,
        )
        await callback.answer(
            "–≠—Ç–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è–º, –Ω–∞—Å—Ç—Ä–æ–π –µ—ë –ø–æ–∑–∂–µ.",
            show_alert=True,
        )
        return

    savings_map = db.get_user_savings_map(callback.from_user.id)
    category_savings = savings_map.get(savings_category, 0.0)
    price = float(wish.get("price", 0) or 0.0)

    if category_savings < price:
        await callback.answer(
            (
                "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –≤ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è—Ö –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.\n"
                f"–ù—É–∂–Ω–æ: {price:.2f}, –¥–æ—Å—Ç—É–ø–Ω–æ: {category_savings:.2f}."
            ),
            show_alert=True,
        )
        return

    db.update_saving(callback.from_user.id, savings_category, -price)
    db.mark_wish_purchased(wish_id)
    db.add_purchase(callback.from_user.id, wish["name"], price, wishlist_category)

    await callback.message.edit_text(f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é, —Ç—ã –∫—É–ø–∏–ª {wish['name']} –∑–∞ {price:.2f}!")
    savings = db.get_user_savings(callback.from_user.id)
    summary = _format_savings_summary(savings)
    await callback.message.answer(f"–û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}")
    await show_affordable_wishes(message=callback.message, user_id=callback.from_user.id, db=db)
    await callback.answer()
    LOGGER.info(
        "User %s purchased wish %s (wishlist_category=%s, savings_category=%s, price=%.2f, savings_before=%.2f)",
        callback.from_user.id,
        wish_id,
        wishlist_category,
        savings_category,
        price,
        category_savings,
    )


@router.callback_query(F.data == "affordable_wishes_later")
async def handle_affordable_wishes_later(callback: CallbackQuery, state: FSMContext) -> None:
    """Close affordable wish suggestions and return to main menu."""

    await state.clear()
    if callback.message:
        try:
            await callback.message.edit_reply_markup(reply_markup=None)
        except Exception:
            LOGGER.debug("Failed to clear inline keyboard for affordable wishes", exc_info=True)
        sent = await callback.message.answer(
            "–•–æ—Ä–æ—à–æ, –≤–µ—Ä–Ω—ë–º—Å—è –∫ –ø–æ–∫—É–ø–∫–∞–º –ø–æ–∑–∂–µ. –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=await build_main_menu_for_user(callback.from_user.id),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
    await callback.answer()


===== Bot/handlers/common.py =====

"""Common handlers and fallbacks."""
import logging

from aiogram import Router
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ReplyKeyboardMarkup

from Bot.config import settings
from Bot.database.crud import FinanceDatabase
from Bot.keyboards.main import main_menu_keyboard
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def build_main_menu_for_user(user_id: int) -> ReplyKeyboardMarkup:
    """Construct main menu keyboard with optional household button."""

    db = FinanceDatabase()
    from Bot.handlers.household_payments import reset_household_cycle_if_needed

    await reset_household_cycle_if_needed(user_id, db)
    month = current_month_str()
    show_household = await db.should_show_household_payments_button(user_id, month)
    show_test_button = user_id == settings.ADMIN_ID
    return main_menu_keyboard(
        show_household=show_household,
        show_test_button=show_test_button,
        show_settings=True,
    )


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Compatibility no-op; welcome messages are kept."""

    return None


@router.message()
async def fallback_handler(message: Message, state: FSMContext) -> None:
    """Handle unmatched messages."""

    await delete_welcome_message_if_exists(message, state)
    current_state = await state.get_state()
    LOGGER.debug("Fallback triggered. User: %s State: %s Text: %s", message.from_user.id, current_state, message.text)
    sent = await message.answer(
        "–ù–µ –ø–æ–Ω—è–ª —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ª—å–∑—É–π—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –∏–ª–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)


===== Bot/handlers/finances.py =====

"""Handlers for income calculation and savings."""
import logging
from typing import Any, Dict, List, Optional

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, Message

from Bot.database.crud import FinanceDatabase
from Bot.keyboards.main import (
    back_to_main_keyboard,
    purchase_confirmation_keyboard,
    yes_no_inline_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.handlers.common import build_main_menu_for_user
from Bot.states.money_states import MoneyState
from Bot.handlers.wishlist import WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY, humanize_wishlist_category
from Bot.utils.savings import find_reached_goal, format_savings_summary
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


def _message_user_id(message: Message) -> int:
    """Extract user id from message."""

    return message.from_user.id if message.from_user else message.chat.id


def _callback_user_id(callback: CallbackQuery) -> int:
    """Extract user id from callback."""

    if callback.from_user:
        return callback.from_user.id
    return callback.message.chat.id


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

INCOME_DIGITS = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}
INCOME_INPUT_BUTTONS = INCOME_DIGITS | {"–û—á–∏—Å—Ç–∏—Ç—å"}


def _build_allocations(categories: List[Dict[str, Any]], amount: float) -> List[Dict[str, Any]]:
    """Build allocation list from income categories."""

    allocations: List[Dict[str, Any]] = []
    for category in categories:
        percent = float(category.get("percent", 0))
        allocated = amount * percent / 100
        allocations.append(
            {
                "label": category.get("title", ""),
                "category": category.get("code", ""),
                "amount": allocated,
            }
        )
    return allocations


def _build_income_prompt(income_sum: str) -> str:
    """Build income input prompt."""

    # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å—É–º–º—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ ": <—á–∏—Å–ª–æ>"
    return f": {income_sum}"


async def _refresh_income_message(
    message: Message, income_message_id: Optional[int], income_sum: str
) -> int:
    """Update or create income prompt message with current sum.

    –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –ø–æ —Å—É–º–º–µ.
    –ï—Å–ª–∏ id –Ω–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫) ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ.
    –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ,
    —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–∏–¥–µ–ª –∞–∫—Ç—É–∞–ª—å–Ω—É—é —Å—É–º–º—É.
    """

    text = _build_income_prompt(income_sum)

    # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –µ—â—ë –Ω–µ –±—ã–ª–æ ‚Äî —Å–æ–∑–¥–∞—ë–º –µ–≥–æ
    if income_message_id is None:
        new_message = await message.answer(text)
        return new_message.message_id

    # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        await message.bot.edit_message_text(
            chat_id=message.chat.id,
            message_id=income_message_id,
            text=text,
        )
        return income_message_id
    except Exception:  # noqa: BLE001
        LOGGER.warning(
            "Failed to edit income message %s",
            income_message_id,
            exc_info=True,
        )

    try:
        await message.bot.delete_message(
            chat_id=message.chat.id,
            message_id=income_message_id,
        )
    except Exception:
        pass

    new_message = await message.answer(text)
    return new_message.message_id


def _to_float(value: Any) -> float:
    """Safely convert value to float."""

    try:
        return float(value) if value is not None else 0.0
    except (TypeError, ValueError):
        return 0.0


def _format_savings_summary(savings: Dict[str, Dict[str, Any]]) -> str:
    """Format savings summary for user message."""

    return format_savings_summary(savings)


def _find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> tuple[str, Dict[str, Any]] | tuple[None, None]:
    """Find category where goal is reached."""

    return find_reached_goal(savings)


async def _ask_allocation_confirmation(
    message: Message, state: FSMContext, allocation: Dict[str, Any]
) -> None:
    """Ask user to confirm allocation for a specific category.

    Args:
        message: Aiogram message object used for sending prompts.
        allocation: Allocation details with label and amount.
    """

    text = (
        f"–ù–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—é {allocation['label']} –º–æ–∂–Ω–æ –Ω–∞–ø—Ä–∞–≤–∏—Ç—å "
        f"{allocation['amount']:.2f}. –ü–µ—Ä–µ–≤–µ—Å—Ç–∏?"
    )
    data = await state.get_data()
    existing_id: Optional[int] = data.get("allocation_question_message_id")
    if existing_id:
        try:
            await message.bot.edit_message_text(
                chat_id=message.chat.id,
                message_id=existing_id,
                text=text,
                reply_markup=yes_no_inline_keyboard(),
            )
            return
        except Exception:
            pass

    sent = await message.answer(text, reply_markup=yes_no_inline_keyboard())
    await state.update_data(allocation_question_message_id=sent.message_id)


@router.message(F.text == "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")
async def start_income_flow(message: Message, state: FSMContext) -> None:
    """Start income calculation workflow with calculator keyboard."""

    await delete_welcome_message_if_exists(message, state)
    await state.clear()
    FinanceDatabase().ensure_income_categories_seeded(message.from_user.id)
    await state.set_state(MoneyState.waiting_for_amount)

    income_sum = "0"
    question = await message.answer(
        "–í–≤–µ–¥–∏ —Å—É–º–º—É –¥–æ—Ö–æ–¥–∞ (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = _build_income_prompt(income_sum)
    income_message = await message.answer(prompt)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ message_id –∏ —Ç–µ–∫—É—â—É—é —Å—É–º–º—É
    await state.update_data(
        income_sum=income_sum,
        income_question_message_id=question.message_id,
        income_message_id=income_message.message_id,
    )

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥"
    try:
        await message.delete()
    except Exception:  # noqa: BLE001
        LOGGER.warning("Failed to delete user command message", exc_info=True)

    LOGGER.info(
        "User %s started income calculation",
        message.from_user.id if message.from_user else "unknown",
    )


async def _process_income_amount_value(
    message: Message,
    state: FSMContext,
    amount: float,
) -> None:
    """Validate amount and start category confirmation workflow."""

    # –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Å—É–º–º—ã
    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–µ –±–æ–ª—å—à–µ 10 000 000. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
        return

    # –£–¥–∞–ª—è–µ–º —Å–ª—É–∂–µ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Å—É–º–º–æ–π –∏ –≤–æ–ø—Ä–æ—Å —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
    data = await state.get_data()
    income_question_message_id: Optional[int] = data.get("income_question_message_id")
    income_message_id: Optional[int] = data.get("income_message_id")

    if income_question_message_id:
        try:
            await message.bot.delete_message(
                chat_id=message.chat.id,
                message_id=income_question_message_id,
            )
        except Exception:  # noqa: BLE001
            LOGGER.warning(
                "Failed to delete income helper message %s",
                income_question_message_id,
                exc_info=True,
            )

    if income_message_id:
        try:
            await message.bot.delete_message(
                chat_id=message.chat.id,
                message_id=income_message_id,
            )
        except Exception:  # noqa: BLE001
            LOGGER.warning(
                "Failed to delete income helper message %s",
                income_message_id,
                exc_info=True,
            )

    db = FinanceDatabase()
    db.ensure_income_categories_seeded(message.from_user.id)
    categories = db.list_active_income_categories(message.from_user.id)
    total_percent = db.sum_income_category_percents(message.from_user.id)
    if total_percent != 100:
        sent = await message.answer(
            f"–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å 100%. –°–µ–π—á–∞—Å: {total_percent}%. –ò—Å–ø—Ä–∞–≤—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–µ—Ä–µ–∑ ‚öôÔ∏è ‚Üí üìä –î–æ—Ö–æ–¥.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    allocations: List[Dict[str, Any]] = _build_allocations(categories, amount)

    if not allocations:
        sent = await message.answer(
            "–ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ FSM
    await state.update_data(
        income_amount=amount,
        allocations=allocations,
        index=0,
        life_message_id=None,
    )

    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    await state.set_state(MoneyState.confirm_category)

    # –ó–∞–¥–∞—ë–º –≤–æ–ø—Ä–æ—Å –¢–û–õ–¨–ö–û –ø–æ –ø–µ—Ä–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    current = allocations[0]
    await _ask_allocation_confirmation(
        message=message,
        state=state,
        allocation=current,
    )

    try:
        await message.delete()
    except Exception:
        pass


@router.message(
    MoneyState.waiting_for_amount,
    F.text.in_(INCOME_INPUT_BUTTONS),
)
async def handle_income_digit(message: Message, state: FSMContext) -> None:
    """Handle digit and clear input for income calculator."""

    data = await state.get_data()
    current_sum = str(data.get("income_sum", "0"))
    sum_message_id = data.get("income_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    income_message_id = await _refresh_income_message(
        message=message,
        income_message_id=sum_message_id,
        income_sum=new_sum,
    )

    await state.update_data(income_sum=new_sum, income_message_id=income_message_id)

    try:
        await message.delete()
    except Exception:
        pass


@router.message(MoneyState.waiting_for_amount, F.text == "‚úÖ –ì–∞–∑")
async def handle_income_confirm(message: Message, state: FSMContext) -> None:
    """Handle confirmation of income input via calculator button."""

    data = await state.get_data()
    amount_str = str(data.get("income_sum", "0")).strip()

    if not amount_str:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–±–µ—Ä–∏ —Å—É–º–º—É —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫.")
        try:
            await message.delete()
        except Exception:
            pass
        return

    normalized = amount_str.replace(",", ".")
    try:
        amount = float(normalized)
    except ValueError:
        await message.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        try:
            await message.delete()
        except Exception:
            pass
        return

    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–µ –±–æ–ª—å—à–µ 10 000 000. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
        try:
            await message.delete()
        except Exception:
            pass
        return

    await _process_income_amount_value(
        message=message,
        state=state,
        amount=amount,
    )

    try:
        await message.delete()
    except Exception:
        pass


@router.callback_query(MoneyState.confirm_category, F.data.in_({"confirm_yes", "confirm_no"}))
async def handle_category_confirmation(query: CallbackQuery, state: FSMContext) -> None:
    """Handle user confirmation for category allocation via inline buttons."""

    await query.answer()

    data = await state.get_data()
    allocations: List[Dict[str, Any]] = data.get("allocations", [])
    index: int = int(data.get("index", 0))
    # –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ—Ç –∏–ª–∏ –∏–Ω–¥–µ–∫—Å –≤—ã—à–µ–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã ‚Äî –≤—ã—Ö–æ–¥–∏–º –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    if not allocations or index >= len(allocations):
        sent = await query.message.answer(
            "–ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.",
            reply_markup=await build_main_menu_for_user(_callback_user_id(query)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    current = allocations[index]

    # --- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª "–î–∞" ---
    if query.data == "confirm_yes":
        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
        FinanceDatabase().update_saving(
            user_id=query.from_user.id if query.from_user else None,
            category=current["category"],
            amount_delta=current["amount"],
        )

        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        index += 1

    # --- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª "–ù–µ—Ç" ---
    else:
        await query.answer("–¢—ã —á—Ç–æ –ø—Ä–æ –∂–∏–∑–Ω—å –∑–∞–±—ã–ª?", show_alert=True)

    # –ï—Å–ª–∏ –µ—â—ë –µ—Å—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Äî –∑–∞–¥–∞—ë–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
    if index < len(allocations):
        await state.update_data(
            index=index,
        )
        next_allocation = allocations[index]
        await _ask_allocation_confirmation(
            message=query.message,
            state=state,
            allocation=next_allocation,
        )
    else:
        try:
            await query.message.edit_reply_markup(reply_markup=None)
        except Exception:
            pass
        await _send_summary_and_goal_prompt(
            message=query.message,
            state=state,
            user_id=query.from_user.id if query.from_user else None,
        )


async def _send_summary_and_goal_prompt(
    message: Message,
    state: FSMContext,
    user_id: Optional[int],
) -> None:
    """Send savings summary and suggest purchase if goal reached."""

    # –î–æ—Å—Ç–∞—ë–º —Å—É–º–º—É, –∫–æ—Ç–æ—Ä—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª –∫–∞–∫ –¥–æ—Ö–æ–¥
    data = await state.get_data()
    income_amount = data.get("income_amount", 0)

    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º user_id, –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–ª–∏ —è–≤–Ω–æ
    if user_id is None:
        user_id = message.from_user.id if message.from_user else message.chat.id

    await state.clear()
    db = FinanceDatabase()

    # –ß–∏—Ç–∞–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª—å–Ω–æ–º—É user_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    savings = db.get_user_savings(user_id)
    summary = _format_savings_summary(savings)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç: —Å–Ω–∞—á–∞–ª–∞ "–ü–æ–ª—É—á–µ–Ω–æ –±–∞–±–æ–∫", –∑–∞—Ç–µ–º —Ç–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
    lines: List[str] = []
    if income_amount:
        lines.append(f"–ü–æ–ª—É—á–µ–Ω–æ –±–∞–±–æ–∫: {income_amount:.2f}")
        lines.append("")  # –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏

    lines.append("–¢–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:")
    lines.append(summary)

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(user_id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

    category, goal_data = _find_reached_goal(savings)
    if category:
        goal = goal_data.get("goal", 0)
        purpose = goal_data.get("purpose", "—Ü–µ–ª—å")
        current = goal_data.get("current", 0)
        await message.answer(
            f"üéØ –¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}. "
            f"–ù–∞ —Ü–µ–ª–∏ {purpose} –Ω–∞–∫–æ–ø–ª–µ–Ω–æ {current:.2f} –∏–∑ {goal:.2f}.",
            reply_markup=purchase_confirmation_keyboard(),
        )
        await state.update_data(category=category, goal=goal)
        await state.set_state(MoneyState.waiting_for_purchase_confirmation)
        return

    # –ü–æ–¥–±–æ—Ä –∂–µ–ª–∞–Ω–∏–π –∏–∑ –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ —Ç–µ–º –∂–µ savings –∏ user_id
    await show_affordable_wishes(
        message=message,
        user_id=user_id,
        db=db,
    )


def _build_affordable_wishes_keyboard(wishes: List[Dict[str, Any]]) -> InlineKeyboardMarkup:
    """Build inline keyboard with purchase buttons for affordable wishes."""

    buttons = [
        [InlineKeyboardButton(text=f"{wish['name']}", callback_data=f"wish_buy_{wish['id']}")]
        for wish in wishes
    ]
    buttons.append([InlineKeyboardButton(text="–ü–æ—Ç–æ–º", callback_data="affordable_wishes_later")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


async def show_affordable_wishes(
    message: Message,
    user_id: int | None = None,
    db: FinanceDatabase | None = None,
) -> None:
    """Show all wishes that are affordable with current savings."""

    if message is None:
        return

    if user_id is None:
        user_id = message.from_user.id if message.from_user else None

    if user_id is None:
        return

    db = db or FinanceDatabase()
    savings_map = db.get_user_savings_map(user_id)
    wishes = db.get_wishes_by_user(user_id)

    affordable: List[Dict[str, Any]] = []
    for wish in wishes:
        if wish.get("is_purchased"):
            continue

        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        savings_category = WISHLIST_CATEGORY_TO_SAVINGS_CATEGORY.get(wishlist_category)
        if not savings_category:
            continue

        price = _to_float(wish.get("price"))
        available = _to_float(savings_map.get(savings_category))
        if price <= 0 or available < price:
            continue

        wish_copy: Dict[str, Any] = dict(wish)
        wish_copy["price"] = price
        wish_copy["wishlist_category"] = wishlist_category
        affordable.append(wish_copy)

    if not affordable:
        return

    lines = ["–¢—ã —É–∂–µ –º–æ–∂–µ—à—å –∫—É–ø–∏—Ç—å:"]
    for wish in affordable:
        lines.append(
            f"‚Ä¢ {wish['name']} ‚Äî {wish['price']:.2f} ‚ÇΩ (–∫–∞—Ç–µ–≥–æ—Ä–∏—è: {wish['wishlist_category']})"
        )
    lines.append("–ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥ –Ω—É–∂–Ω—ã–º —Ç–æ–≤–∞—Ä–æ–º, –µ—Å–ª–∏ –∫—É–ø–∏–ª.")

    keyboard = _build_affordable_wishes_keyboard(affordable)
    await message.answer("\n".join(lines), reply_markup=keyboard)


async def suggest_available_wish(message: Message) -> None:
    """Backward-compatible wrapper to show affordable wishes."""

    await show_affordable_wishes(message=message, user_id=message.from_user.id if message.from_user else None)


@router.message(MoneyState.waiting_for_purchase_confirmation, F.text.in_({"‚úÖ –ö—É–ø–∏–ª", "üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å"}))
async def handle_goal_purchase(message: Message, state: FSMContext) -> None:
    """Handle decision after reaching savings goal."""

    data = await state.get_data()
    category = data.get("category")
    goal_amount = data.get("goal", 0)
    db = FinanceDatabase()

    if message.text == "‚úÖ –ö—É–ø–∏–ª" and category:
        db.update_saving(message.from_user.id, category, -goal_amount)
        db.set_goal(message.from_user.id, category, 0, "")
        sent = await message.answer(
            f"–ü–æ–∑–¥—Ä–∞–≤–ª—è—é —Å –ø–æ–∫—É–ø–∫–æ–π –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}! –°—É–º–º–∞ {goal_amount:.2f} —Å–ø–∏—Å–∞–Ω–∞.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        savings = db.get_user_savings(message.from_user.id)
        summary = _format_savings_summary(savings)
        await message.answer(f"–û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}")
    else:
        sent = await message.answer(
            "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∫–æ–ø–∏—Ç—å!",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)

    await state.clear()
    LOGGER.info("User %s handled goal decision for category %s", message.from_user.id, category)


@router.message(MoneyState.confirm_category)
async def unexpected_confirmation_input(message: Message) -> None:
    """Handle unexpected text in confirmation state."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –î–∞/–ù–µ—Ç –¥–ª—è –≤—ã–±–æ—Ä–∞.")


@router.message(MoneyState.waiting_for_purchase_confirmation)
async def unexpected_purchase_input(message: Message) -> None:
    """Handle unexpected text in purchase confirmation state."""

    await message.answer("–í—ã–±–µ—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ: –ö—É–ø–∏–ª –∏–ª–∏ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å.")


===== Bot/handlers/household_payments.py =====

"""Handlers for household payments scenario."""
from datetime import datetime, time as dt_time
import logging
import time
from typing import Dict, List

from aiogram import F, Router
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, ReplyKeyboardRemove

from Bot.config import settings
from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.keyboards.settings import (
    household_remove_keyboard,
    household_settings_inline_keyboard,
    settings_menu_keyboard,
)
from Bot.renderers.household import (
    build_household_question_keyboard,
    format_household_items,
    render_household_questions_text,
)
from Bot.services.household import (
    build_answers_from_status,
    build_household_questions,
    filter_unpaid_questions,
    get_current_question,
    get_next_index,
    get_previous_index,
    should_ignore_answer,
    update_flow_state,
)
from Bot.states.money_states import HouseholdPaymentsState, HouseholdSettingsState
from Bot.utils.datetime_utils import current_month_str, now_tz
from Bot.utils.savings import format_savings_summary
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_register_message,
    ui_register_user_message,
)

LOGGER = logging.getLogger(__name__)

router = Router(name="household_payments")


def _format_meta(meta: dict) -> str:
    if not meta:
        return "-"
    return " ".join(f"{key}={value}" for key, value in meta.items())


async def _log_state_transition(
    state: FSMContext, user_id: int, to_state: str | None
) -> None:
    from_state = await state.get_state()
    LOGGER.info(
        "USER=%s ACTION=STATE_TRANSITION STATE=%s->%s META=-",
        user_id,
        from_state,
        to_state,
    )


def _log_event(user_id: int, action: str, state: str | None, **meta: str) -> None:
    LOGGER.info(
        "USER=%s ACTION=%s STATE=%s META=%s",
        user_id,
        action,
        state,
        _format_meta(meta),
    )


async def _send_main_menu_summary(
    bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    db = FinanceDatabase()
    savings = db.get_user_savings(user_id)
    summary = format_savings_summary(savings)
    menu = await build_main_menu_for_user(user_id)
    sent = await bot.send_message(
        chat_id=chat_id, text=f"–¢–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}", reply_markup=menu
    )
    await ui_register_message(state, chat_id, sent.message_id)


async def reset_household_cycle_if_needed(
    user_id: int, db: FinanceDatabase, now: datetime | None = None
) -> None:
    """Lazily reset household payments cycle after 6th of month at noon."""

    current = now or datetime.now(tz=settings.TIMEZONE)
    month = current_month_str(current)

    threshold = datetime(current.year, current.month, 6, 12, 0, tzinfo=settings.TIMEZONE)
    if current >= threshold:
        await db.init_household_questions_for_month(user_id, month)


def _format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    return format_household_items(items, unpaid_set)


async def _send_household_settings_overview(
    message: Message, db: FinanceDatabase, user_id: int
) -> None:
    items = db.list_active_household_items(user_id)
    month = current_month_str()
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    unpaid_set: set[str] = set(unpaid_codes)
    _log_event(
        user_id,
        "HOUSEHOLD_SETTINGS_OVERVIEW",
        None,
        month=month,
        items_count=str(len(items)),
        unpaid_count=str(len(unpaid_set)),
    )
    if not items:
        _log_event(
            user_id,
            "HOUSEHOLD_SETTINGS_EMPTY",
            None,
            source="list_active_household_items",
        )
    await message.answer(
        _format_household_items(items, unpaid_set),
        reply_markup=household_settings_inline_keyboard(),
    )


@router.message(F.text == "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")
async def open_household_settings(message: Message, state: FSMContext) -> None:
    """Open household payments settings menu."""

    if message.from_user.id != settings.ADMIN_ID:
        sent = await message.answer(
            "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –í–µ—Ä–Ω—ë–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=await build_main_menu_for_user(message.from_user.id),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    await state.clear()
    db = FinanceDatabase()
    sent = await message.answer(
        "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è", reply_markup=settings_menu_keyboard()
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)
    await _send_household_settings_overview(message, db, message.from_user.id)


@router.callback_query(F.data == "hh_set:add")
async def household_add_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Prompt for new household payment title."""

    await callback.answer()
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    await state.set_state(HouseholdSettingsState.waiting_for_title)
    await callback.message.answer("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞")


@router.message(HouseholdSettingsState.waiting_for_title)
async def household_add_set_title(message: Message, state: FSMContext) -> None:
    """Handle title input for new household payment."""

    title = (message.text or "").strip()
    if not title:
        await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞.")
        return

    await state.update_data(title=title)
    await state.set_state(HouseholdSettingsState.waiting_for_amount)

    question = await message.answer(
        "–í–≤–µ–¥–∏ —Å—É–º–º—É (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = await message.answer(": 0")

    await state.update_data(
        amount_sum="0",
        amount_message_id=prompt.message_id,
        amount_question_message_id=question.message_id,
    )


@router.message(
    HouseholdSettingsState.waiting_for_amount,
    F.text.in_({"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "–û—á–∏—Å—Ç–∏—Ç—å", "‚úÖ –ì–∞–∑"}),
)
async def household_add_amount_calc(message: Message, state: FSMContext) -> None:
    """Handle calculator input for new household payment amount."""

    data = await state.get_data()
    current_sum = str(data.get("amount_sum", "0"))
    amount_message_id = data.get("amount_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                LOGGER.warning("Failed to delete amount prompt message", exc_info=True)
            return

        try:
            amount = int(amount_str)
        except (TypeError, ValueError):
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                LOGGER.warning("Failed to delete amount prompt message", exc_info=True)
            return

        if amount <= 0:
            await message.answer("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            try:
                await message.delete()
            except Exception:
                LOGGER.warning("Failed to delete amount prompt message", exc_info=True)
            return

        user_id = message.from_user.id
        db = FinanceDatabase()
        position = db.get_next_household_position(user_id)
        title = str(data.get("title", "")).strip() or "–ü–ª–∞—Ç—ë–∂"
        code = f"custom_{time.time_ns()}"
        text = f"{title} {amount}—Ä?"
        db.add_household_payment_item(user_id, code, text, amount, position)
        await reset_household_cycle_if_needed(user_id, db)
        await state.clear()
        await message.answer(
            "–ü–ª–∞—Ç—ë–∂ –¥–æ–±–∞–≤–ª–µ–Ω.", reply_markup=ReplyKeyboardRemove()
        )
        await message.answer(
            "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è", reply_markup=settings_menu_keyboard()
        )
        await _send_household_settings_overview(message, db, user_id)
        try:
            await message.delete()
        except Exception:
            LOGGER.warning("Failed to delete amount confirmation message", exc_info=True)
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if amount_message_id:
        try:
            await message.bot.edit_message_text(
                chat_id=message.chat.id,
                message_id=amount_message_id,
                text=f": {new_sum}",
            )
        except Exception:
            LOGGER.warning("Failed to edit amount message", exc_info=True)

    await state.update_data(amount_sum=new_sum, amount_message_id=amount_message_id)

    try:
        await message.delete()
    except Exception:
        LOGGER.warning("Failed to delete calculator message", exc_info=True)


@router.callback_query(F.data == "hh_set:del")
async def household_remove_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Show list of household payments for removal."""

    await callback.answer()
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    db = FinanceDatabase()
    db.ensure_household_items_seeded(callback.from_user.id)
    items = db.list_active_household_items(callback.from_user.id)
    if not items:
        await callback.message.answer("–°–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π –ø—É—Å—Ç.")
        return

    await callback.message.answer(
        "–í—ã–±–µ—Ä–∏ –ø–ª–∞—Ç–µ–∂ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        reply_markup=household_remove_keyboard(items),
    )


@router.callback_query(F.data.startswith("hh_set:remove:"))
async def household_remove_item(callback: CallbackQuery, state: FSMContext) -> None:
    """Deactivate selected household payment item."""

    await callback.answer()
    if callback.from_user.id != settings.ADMIN_ID:
        return

    parts = callback.data.split(":") if callback.data else []
    if len(parts) != 3:
        return
    code = parts[2]
    db = FinanceDatabase()
    db.deactivate_household_payment_item(callback.from_user.id, code)
    await reset_household_cycle_if_needed(callback.from_user.id, db)
    await _send_household_settings_overview(callback.message, db, callback.from_user.id)


@router.message(F.text == "–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")
async def start_household_payments(message: Message, state: FSMContext) -> None:
    """Start household payments flow."""

    await ui_register_user_message(state, message.chat.id, message.message_id)
    try:
        await message.delete()
    except Exception:  # noqa: BLE001
        LOGGER.warning(
            "Failed to delete user menu message (–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏)", exc_info=True
        )

    user_id = message.from_user.id
    db = FinanceDatabase()

    await reset_household_cycle_if_needed(user_id, db)
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)
    if not items:
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        sent = await message.answer(
            "–°–ø–∏—Å–æ–∫ –±—ã—Ç–æ–≤—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        await ui_register_message(state, message.chat.id, sent.message_id)
        return

    month = current_month_str()
    await db.init_household_questions_for_month(user_id, month)
    status_map = await db.get_household_payment_status_map(user_id, month)
    questions = build_household_questions(items)
    answers = build_answers_from_status(status_map)
    all_paid = all(status_map.get(str(question.get("code", "")), 0) == 1 for question in questions)
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    hh_questions = filter_unpaid_questions(questions, unpaid_codes)

    if all_paid or not hh_questions:
        text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        lines = text.splitlines()
        if lines:
            lines[0] = f"‚úÖ –í—Å–µ –±—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ –æ–ø–ª–∞—á–µ–Ω—ã –∑–∞ {month}"
        text = "\n".join(lines)
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        sent = await message.answer(
            text,
            parse_mode="HTML",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        await ui_register_message(state, message.chat.id, sent.message_id)
        _log_event(
            user_id,
            "HOUSEHOLD_ALL_PAID",
            None,
            month=month,
        )
        return

    await _log_state_transition(state, user_id, HouseholdPaymentsState.waiting_for_answer.state)
    await state.set_state(HouseholdPaymentsState.waiting_for_answer)
    flow_state = update_flow_state(
        month=month,
        questions=hh_questions,
        current_step_index=0,
        answers=answers,
        processed_steps=[],
    )
    await state.update_data(
        hh_month=month,
        hh_questions=hh_questions,
        hh_index=0,
        hh_answers=answers,
        hh_ui_message_id=0,
        current_step_index=flow_state.current_step_index,
        current_question_code=flow_state.current_question_code,
        processed_steps=[],
    )
    text = render_household_questions_text(
        month, hh_questions, answers, current_index=0
    )
    sent = await message.answer(
        text,
        reply_markup=build_household_question_keyboard(
            flow_state.current_question_code, show_back=False
        ),
        parse_mode="HTML",
    )
    await state.update_data(hh_ui_message_id=sent.message_id)
    await ui_register_message(state, message.chat.id, sent.message_id)
    _log_event(
        user_id,
        "HOUSEHOLD_START",
        await state.get_state(),
        month=month,
    )


@router.message(F.text == "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")
async def trigger_household_notifications(message: Message, state: FSMContext) -> None:
    """Trigger BYT purchases check (household wishlist) as if timer fired."""

    user_id = message.from_user.id
    db = FinanceDatabase()
    _log_event(user_id, "BYT_MANUAL_CHECK", None)

    db.ensure_byt_timer_defaults(user_id)
    data = await state.get_data()
    last_ts = data.get("byt_manual_check_ts")
    current_ts = time.time()
    if last_ts is not None and current_ts - float(last_ts) < 2:
        sent = await message.answer(
            "–£–∂–µ –ø—Ä–æ–≤–µ—Ä–∏–ª. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ —á–µ—Ä–µ–∑ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥.",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        return
    await state.update_data(byt_manual_check_ts=current_ts)
    try:
        await message.delete()
    except TelegramBadRequest:
        LOGGER.warning("Failed to delete BYT manual check message", exc_info=True)

    times = db.list_active_byt_timer_times(user_id)
    simulated_time = None
    if times:
        first_time = times[0]
        try:
            simulated_time = dt_time(
                hour=int(first_time.get("hour", 0)),
                minute=int(first_time.get("minute", 0)),
            )
        except Exception:
            simulated_time = None

    now_dt = now_tz()
    total_items = db.get_active_byt_wishes(user_id)
    due_items = db.list_active_byt_items_for_reminder(user_id, now_dt)
    due_ids = {int(item.get("id")) for item in due_items if item.get("id") is not None}
    deferred_items = [
        item
        for item in total_items
        if item.get("id") is not None and int(item.get("id")) not in due_ids
    ]
    nearest_deferred = None
    for item in deferred_items:
        deferred_until = item.get("deferred_until")
        if not deferred_until:
            continue
        try:
            deferred_dt = datetime.fromisoformat(str(deferred_until))
        except ValueError:
            continue
        if nearest_deferred is None or deferred_dt < nearest_deferred:
            nearest_deferred = deferred_dt
    _log_event(
        user_id,
        "BYT_MANUAL_CHECK_SUMMARY",
        None,
        total_items=str(len(total_items)),
        due_items=str(len(due_items)),
        deferred_items=str(len(deferred_items)),
        nearest_deferred=nearest_deferred.isoformat() if nearest_deferred else "None",
    )
    if not due_items:
        text = "‚úÖ –°–µ–π—á–∞—Å –ø–æ–∫—É–ø–∞—Ç—å –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ. –°–ø–∏—Å–æ–∫ –ø—É—Å—Ç –∏–ª–∏ –≤—Å—ë –æ—Ç–ª–æ–∂–µ–Ω–æ."
        if deferred_items:
            if nearest_deferred:
                nearest_label = nearest_deferred.strftime("%d.%m.%Y %H:%M")
                text = (
                    f"{text}\n–ï—Å—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏: {len(deferred_items)} —à—Ç. "
                    f"(–±–ª–∏–∂–∞–π—à–∞—è ‚Äî {nearest_label})"
                )
            else:
                text = (
                    f"{text}\n–ï—Å—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏: {len(deferred_items)} —à—Ç."
                )
        sent = await message.answer(
            text, reply_markup=await build_main_menu_for_user(user_id)
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    await run_byt_timer_check(
        message.bot, db, user_id=user_id, simulated_time=simulated_time
    )


@router.callback_query(
    HouseholdPaymentsState.waiting_for_answer,
    F.data.startswith("hh_pay:"),
)
async def handle_household_answer(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle Yes/No/Back answers for household questions."""

    data = await state.get_data()
    month = data.get("hh_month")
    questions = list(data.get("hh_questions") or [])
    index = int(data.get("current_step_index") or data.get("hh_index") or 0)
    answers = dict(data.get("hh_answers") or {})
    ui_message_id = data.get("hh_ui_message_id")
    processed_steps = set(data.get("processed_steps") or [])
    user_id = callback.from_user.id

    if callback.message is None or callback.message.message_id != ui_message_id:
        await callback.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", show_alert=False)
        return

    callback_parts = callback.data.split(":") if callback.data else []
    if len(callback_parts) < 2:
        await callback.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", show_alert=False)
        return
    action = callback_parts[1]
    callback_code = callback_parts[2] if len(callback_parts) > 2 else None

    if action == "back" and index == 0:
        await callback.answer("–ù–∞–∑–∞–¥ –Ω–µ–ª—å–∑—è ‚Äî —ç—Ç–æ –ø–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å", show_alert=True)
        return

    await callback.answer()

    if not month or not questions:
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    current_question = get_current_question(questions, index)
    current_code = str(current_question.get("code")) if current_question else None
    target_code = callback_code or current_code

    if action == "back":
        index = get_previous_index(index)
        current_question = get_current_question(questions, index)
        current_code = str(current_question.get("code")) if current_question else None
        await state.update_data(
            hh_index=index,
            current_step_index=index,
            current_question_code=current_code,
        )
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        await callback.message.edit_text(
            text,
            reply_markup=build_household_question_keyboard(
                current_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        _log_event(
            user_id,
            "HOUSEHOLD_BACK",
            await state.get_state(),
            month=str(month),
            index=str(index),
            question_code=str(current_code),
        )
        return

    if index >= len(questions):
        final_text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        await callback.message.edit_text(
            final_text,
            reply_markup=None,
            parse_mode="HTML",
        )
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    if target_code and target_code != current_code:
        if target_code in processed_steps:
            await callback.answer("–£–∂–µ —É—á—Ç–µ–Ω–æ", show_alert=False)
            return
        await callback.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", show_alert=False)
        return

    question = current_question
    if not question:
        await callback.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", show_alert=False)
        return

    code = str(question.get("code", ""))
    amount = question.get("amount")
    amount_value = float(amount) if amount is not None else 0.0
    db = FinanceDatabase()

    if action not in {"yes", "no"}:
        await callback.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", show_alert=False)
        return

    if should_ignore_answer(answers, processed_steps, code, action):
        await callback.answer("–£–∂–µ —É—á—Ç–µ–Ω–æ", show_alert=False)
        return

    db.apply_household_payment_answer(
        user_id=user_id,
        month=str(month),
        question_code=code,
        amount=amount_value if amount is not None else None,
        answer=action,
    )
    answers[code] = "yes" if action == "yes" else "no"
    processed_steps.add(code)

    _log_event(
        user_id,
        "HOUSEHOLD_ANSWER",
        await state.get_state(),
        month=str(month),
        question_code=code,
        answer=action,
    )

    index = get_next_index(index, questions)
    next_question = get_current_question(questions, index)
    next_code = str(next_question.get("code")) if next_question else None
    await state.update_data(
        hh_answers=answers,
        hh_index=index,
        current_step_index=index,
        current_question_code=next_code,
        processed_steps=list(processed_steps),
    )
    if index < len(questions):
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        await callback.message.edit_text(
            text,
            reply_markup=build_household_question_keyboard(
                next_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        return

    final_text = render_household_questions_text(
        month, questions, answers, current_index=None
    )
    await callback.message.edit_text(
        final_text,
        reply_markup=None,
        parse_mode="HTML",
    )
    await ui_cleanup_messages(callback.bot, state)
    await _log_state_transition(state, user_id, None)
    await state.clear()
    await _send_main_menu_summary(callback.bot, state, callback.message.chat.id, user_id)


===== Bot/handlers/settings.py =====

"""Inline settings handlers for a single-page experience."""
import logging
import time

from aiogram import F, Router
from aiogram.filters import BaseFilter
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, ReplyKeyboardMarkup, ReplyKeyboardRemove

from Bot.database.crud import FinanceDatabase
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import back_only_keyboard
from Bot.keyboards.settings import (
    byt_rules_reply_keyboard,
    byt_timer_reply_keyboard,
    byt_timer_times_select_reply_keyboard,
    household_payments_remove_reply_keyboard,
    household_settings_reply_keyboard,
    income_categories_select_reply_keyboard,
    income_settings_reply_keyboard,
    settings_back_reply_keyboard,
    settings_home_reply_keyboard,
    wishlist_categories_select_reply_keyboard,
    wishlist_purchased_mode_reply_keyboard,
    wishlist_settings_reply_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.states.money_states import HouseholdSettingsState, IncomeSettingsState
from Bot.states.wishlist_states import (
    BytSettingsState,
    BytTimerState,
    WishlistSettingsState,
)
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.savings import format_savings_summary
from Bot.utils.ui_cleanup import (
    ui_cleanup_to_context,
    ui_register_message,
    ui_set_screen_message,
    ui_set_settings_mode_message,
    ui_track_message,
)

router = Router()
LOGGER = logging.getLogger(__name__)
PERCENT_DIGITS = {str(i) for i in range(10)}
PERCENT_INPUT_BUTTONS = PERCENT_DIGITS | {"–û—á–∏—Å—Ç–∏—Ç—å", "‚úÖ –ì–∞–∑"}


class InSettingsFilter(BaseFilter):
    async def __call__(self, message: Message, state: FSMContext) -> bool:
        data = await state.get_data()
        return bool(data.get("in_settings"))


async def _register_user_message(state: FSMContext, message: Message) -> None:
    await ui_track_message(state, message.chat.id, message.message_id)


async def _delete_message_safely(bot, chat_id: int | None, message_id: int | None) -> None:
    if chat_id is None or message_id is None:
        return
    try:
        await bot.delete_message(chat_id=chat_id, message_id=int(message_id))
    except Exception:
        pass


async def _delete_user_message(message: Message) -> None:
    try:
        await message.delete()
    except Exception:
        pass


async def _remove_calculator_keyboard(message: Message) -> None:
    try:
        temp = await message.answer(" ", reply_markup=ReplyKeyboardRemove())
        try:
            await temp.delete()
        except Exception:
            pass
    except Exception:
        pass


async def _apply_reply_keyboard(message: Message, reply_markup: ReplyKeyboardMarkup) -> None:
    try:
        temp = await message.answer(" ", reply_markup=reply_markup)
        try:
            await temp.delete()
        except Exception:
            pass
    except Exception:
        pass


def _parse_time_text(raw: str) -> tuple[int, int] | None:
    value = raw.strip()
    if ":" not in value:
        return None
    parts = value.split(":")
    if len(parts) != 2:
        return None
    try:
        hour = int(parts[0])
        minute = int(parts[1])
    except ValueError:
        return None
    if hour < 0 or hour > 23 or minute < 0 or minute > 59:
        return None
    return hour, minute


async def _cleanup_input_ui(
    bot,
    data: dict,
    *,
    display_chat_key: str | None = None,
    display_message_key: str | None = None,
    prompt_chat_key: str | None = None,
    prompt_message_key: str | None = None,
) -> None:
    if display_chat_key and display_message_key:
        await _delete_message_safely(
            bot, data.get(display_chat_key), data.get(display_message_key)
        )
    if prompt_chat_key and prompt_message_key:
        await _delete_message_safely(
            bot, data.get(prompt_chat_key), data.get(prompt_message_key)
        )


async def _store_settings_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    await state.update_data(
        settings_chat_id=chat_id, settings_message_id=message_id, in_settings=True
    )


async def _set_current_screen(state: FSMContext, screen_id: str) -> None:
    await state.update_data(settings_current_screen=screen_id, in_settings=True)


async def _reset_navigation(state: FSMContext, current_screen: str = "st:home") -> None:
    await state.update_data(settings_nav_stack=[], settings_current_screen=current_screen)


async def _push_current_screen(state: FSMContext, next_screen: str) -> None:
    data = await state.get_data()
    current_screen = data.get("settings_current_screen")
    stack = list(data.get("settings_nav_stack") or [])
    if current_screen and current_screen != next_screen:
        if not stack or stack[-1] != current_screen:
            stack.append(current_screen)
    await state.update_data(settings_nav_stack=stack, settings_current_screen=next_screen)


async def _pop_previous_screen(state: FSMContext) -> str | None:
    data = await state.get_data()
    stack = list(data.get("settings_nav_stack") or [])
    if not stack:
        return None
    previous = stack.pop()
    await state.update_data(settings_nav_stack=stack, settings_current_screen=previous)
    return previous


async def _send_and_register(
    *, message: Message, state: FSMContext, text: str, reply_markup=None
) -> Message:
