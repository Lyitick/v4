        amount_delta: float,
    ) -> None:
        cursor.execute(
            f"SELECT id, current FROM {TABLES.savings} WHERE user_id = ? AND category = ?",
            (user_id, category),
        )
        row = cursor.fetchone()
        delta = self._to_float(amount_delta)
        if row:
            current = self._to_float(row["current"])
            new_value = current + delta
            cursor.execute(
                f"UPDATE {TABLES.savings} SET current = ? WHERE id = ?",
                (new_value, row["id"]),
            )
        else:
            cursor.execute(
                f"INSERT INTO {TABLES.savings} (user_id, category, current, goal, purpose) VALUES (?, ?, ?, 0, '')",
                (user_id, category, delta),
            )

    def decrease_savings(self, user_id: int, category: str, amount: float) -> None:
        """Decrease savings for category by amount."""

        self.update_saving(user_id, category, -abs(amount))

    def set_goal(self, user_id: int, category: str, goal: float, purpose: str) -> None:
        """Set goal and purpose for saving category."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT id FROM {TABLES.savings} WHERE user_id = ? AND category = ?",
                (user_id, category),
            )
            row = cursor.fetchone()
            if row:
                cursor.execute(
                    f"UPDATE {TABLES.savings} SET goal = ?, purpose = ? WHERE id = ?",
                    (goal, purpose, row["id"]),
                )
            else:
                cursor.execute(
                    f"INSERT INTO {TABLES.savings} (user_id, category, current, goal, purpose) VALUES (?, ?, 0, ?, ?)",
                    (user_id, category, goal, goal, purpose),
                )
            self.connection.commit()
            LOGGER.info("Set goal for user %s category %s", user_id, category)
        except sqlite3.Error as error:
            LOGGER.error("Failed to set goal for user %s category %s: %s", user_id, category, error)

    def reset_goals(self, user_id: int) -> None:
        """Reset goals for user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.savings} SET goal = 0, purpose = '' WHERE user_id = ?",
                (user_id,),
            )
            self.connection.commit()
            LOGGER.info("Reset goals for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to reset goals for user %s: %s", user_id, error)

    def add_wish(self, user_id: int, name: str, price: float, url: Optional[str], category: str) -> int:
        """Add a wish to the wishlist."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"INSERT INTO {TABLES.wishes} (user_id, name, price, url, category, is_purchased, saved_amount, purchased_at) VALUES (?, ?, ?, ?, ?, 0, 0, NULL)",
                (user_id, name, price, url, category),
            )
            self.connection.commit()
            wish_id = cursor.lastrowid
            LOGGER.info("Added wish %s for user %s", wish_id, user_id)
            return wish_id
        except sqlite3.Error as error:
            LOGGER.error("Failed to add wish for user %s: %s", user_id, error)
            return 0

    def get_wishes_by_user(self, user_id: int) -> List[Dict[str, Any]]:
        """Get all wishes for a user."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, name, price, url, category, is_purchased, saved_amount, purchased_at, debited_at, deferred_until
                FROM {TABLES.wishes}
                WHERE user_id = ?
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched wishes for user %s", user_id)
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch wishes for user %s: %s", user_id, error)
            return []

    def get_wish(self, wish_id: int) -> Optional[Dict[str, Any]]:
        """Get wish by id."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, debited_at, deferred_until
                FROM {TABLES.wishes}
                WHERE id = ?
                """,
                (wish_id,),
            )
            row = cursor.fetchone()
            LOGGER.info("Fetched wish %s", wish_id)
            return dict(row) if row else None
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch wish %s: %s", wish_id, error)
            return None

    def get_active_byt_wishes(self, user_id: int, category_title: str) -> List[Dict[str, Any]]:
        """Return active BYT wishes for user and category."""

        if not category_title:
            return []
        try:
            cursor = self.connection.cursor()
            category_sql = "lower(trim(category)) = lower(trim(?))"
            params: tuple[Any, ...] = (user_id, category_title)
            if category_title.strip().casefold() == "–±—ã—Ç":
                category_sql = "lower(trim(category)) IN (lower(trim(?)), 'byt')"
            cursor.execute(
                f"""
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM {TABLES.wishes}
                WHERE user_id = ?
                  AND {category_sql}
                  AND (is_purchased = 0 OR is_purchased IS NULL)
                ORDER BY id
                """,
                params,
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched active BYT wishes for user %s", user_id)
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch BYT wishes for user %s: %s", user_id, error)
            return []

    def list_active_byt_items_for_reminder(
        self, user_id: int, now_dt: datetime, category_title: str
    ) -> List[Dict[str, Any]]:
        """Return BYT wishlist items available for reminders at given time."""

        if not category_title:
            return []
        try:
            cursor = self.connection.cursor()
            category_sql = "lower(trim(category)) = lower(trim(?))"
            params: tuple[Any, ...] = (user_id, category_title, now_dt.isoformat())
            if category_title.strip().casefold() == "–±—ã—Ç":
                category_sql = "lower(trim(category)) IN (lower(trim(?)), 'byt')"
            cursor.execute(
                f"""
                SELECT id, user_id, name, price, url, category, is_purchased, saved_amount, purchased_at, deferred_until
                FROM {TABLES.wishes}
                WHERE user_id = ?
                  AND {category_sql}
                  AND (is_purchased = 0 OR is_purchased IS NULL)
                  AND (deferred_until IS NULL OR deferred_until <= ?)
                ORDER BY id
                """,
                params,
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT reminder wishes for user %s: %s", user_id, error
            )
            return []

    def set_wishlist_item_deferred_until(
        self, user_id: int, item_id: int, deferred_until_iso: Optional[str]
    ) -> None:
        """Set deferred_until for wishlist item."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.wishes}
                SET deferred_until = ?
                WHERE id = ? AND user_id = ?
                """,
                (deferred_until_iso, item_id, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Set deferred_until for wish %s user %s to %s",
                item_id,
                user_id,
                deferred_until_iso,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to set deferred_until for wish %s user %s: %s",
                item_id,
                user_id,
                error,
            )

    def mark_wish_purchased(self, wish_id: int, purchased_at: Optional[datetime] = None) -> None:
        """Mark wish as purchased with timestamp."""

        try:
            cursor = self.connection.cursor()
            purchased_value = (purchased_at or now_tz()).isoformat()
            cursor.execute(
                f"""
                UPDATE {TABLES.wishes}
                SET is_purchased = 1, purchased_at = ?, deferred_until = NULL
                WHERE id = ?
                """,
                (purchased_value, wish_id),
            )
            self.connection.commit()
            LOGGER.info("Marked wish %s as purchased", wish_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to mark wish %s as purchased: %s", wish_id, error)

    def purchase_wish(
        self, user_id: int, wish_id: int, debit_category: str | None
    ) -> Dict[str, Any]:
        """Purchase wish with debit in a single transaction."""

        cursor = self.connection.cursor()
        try:
            cursor.execute("BEGIN IMMEDIATE")
            cursor.execute(
                f"""
                SELECT id, user_id, name, price, category, is_purchased, debited_at
                FROM {TABLES.wishes}
                WHERE id = ? AND user_id = ?
                LIMIT 1
                """,
                (wish_id, user_id),
            )
            row = cursor.fetchone()
            if not row:
                cursor.execute("ROLLBACK")
                return {"status": "not_found"}

            if row["is_purchased"] or row["debited_at"]:
                cursor.execute("ROLLBACK")
                return {"status": "already"}

            price = self._to_float(row["price"])
            if price <= 0 or debit_category is None:
                purchased_value = now_tz().isoformat()
                cursor.execute(
                    f"""
                    UPDATE {TABLES.wishes}
                    SET is_purchased = 1, purchased_at = ?, deferred_until = NULL
                    WHERE id = ?
                    """,
                    (purchased_value, wish_id),
                )
                cursor.execute(
                    f"""
                    INSERT INTO {TABLES.purchases} (user_id, wish_name, price, category, purchased_at)
                    VALUES (?, ?, ?, ?, ?)
                    """,
                    (user_id, row["name"], price, row["category"], purchased_value),
                )
                cursor.execute("COMMIT")
                return {
                    "status": "no_debit",
                    "price": price,
                    "wish_name": row["name"],
                    "category": row["category"],
                }

            cursor.execute(
                f"SELECT id, current FROM {TABLES.savings} WHERE user_id = ? AND category = ?",
                (user_id, debit_category),
            )
            savings_row = cursor.fetchone()
            savings_before = self._to_float(savings_row["current"]) if savings_row else 0.0
            if savings_before < price:
                cursor.execute("ROLLBACK")
                return {
                    "status": "insufficient",
                    "price": price,
                    "available": savings_before,
                }

            self._update_saving_in_transaction(cursor, user_id, debit_category, -price)
            purchased_value = now_tz().isoformat()
            cursor.execute(
                f"""
                UPDATE {TABLES.wishes}
                SET is_purchased = 1, purchased_at = ?, debited_at = ?, deferred_until = NULL
                WHERE id = ?
                """,
                (purchased_value, purchased_value, wish_id),
            )
            cursor.execute(
                f"""
                INSERT INTO {TABLES.purchases} (user_id, wish_name, price, category, purchased_at)
                VALUES (?, ?, ?, ?, ?)
                """,
                (user_id, row["name"], price, row["category"], purchased_value),
            )
            cursor.execute("COMMIT")
            return {
                "status": "debited",
                "price": price,
                "wish_name": row["name"],
                "category": row["category"],
                "savings_before": savings_before,
            }
        except sqlite3.Error as error:
            cursor.execute("ROLLBACK")
            LOGGER.error("Failed to purchase wish %s for user %s: %s", wish_id, user_id, error)
            return {"status": "error"}

    def add_purchase(
        self,
        user_id: int,
        wish_name: str,
        price: float,
        category: str,
        purchased_at: Optional[datetime] = None,
    ) -> None:
        """Add purchase record."""

        try:
            cursor = self.connection.cursor()
            purchased_value = (purchased_at or now_tz()).isoformat()
            cursor.execute(
                f"INSERT INTO {TABLES.purchases} (user_id, wish_name, price, category, purchased_at) VALUES (?, ?, ?, ?, ?)",
                (user_id, wish_name, price, category, purchased_value),
            )
            self.connection.commit()
            LOGGER.info("Added purchase for user %s", user_id)
        except sqlite3.Error as error:
            LOGGER.error("Failed to add purchase for user %s: %s", user_id, error)

    async def household_status_exists(self, user_id: int, month: str) -> bool:
        """Check if household payment statuses exist for month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT 1 FROM {TABLES.household_payments} WHERE user_id = ? AND month = ? LIMIT 1",
                (user_id, month),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to check household status for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def init_household_questions_for_month(self, user_id: int, month: str) -> None:
        """Initialize household payment questions for month."""

        try:
            if BOT_USER_ID is not None and user_id == BOT_USER_ID:
                LOGGER.warning(
                    "Skipping household questions init for bot user %s", user_id
                )
                return
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                INSERT OR IGNORE INTO {TABLES.household_payments} (user_id, month, question_code, is_paid)
                SELECT ?, ?, code, 0
                FROM {TABLES.household_payment_items}
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id, month, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Initialized household questions for user %s month %s", user_id, month
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to init household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )

    async def mark_household_question_paid(
        self, user_id: int, month: str, question_code: str
    ) -> None:
        """Mark household question as paid."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                INSERT INTO {TABLES.household_payments} (user_id, month, question_code, is_paid)
                VALUES (?, ?, ?, 1)
                ON CONFLICT(user_id, month, question_code)
                DO UPDATE SET is_paid = excluded.is_paid
                """,
                (user_id, month, question_code),
            )
            self.connection.commit()
            LOGGER.info(
                "Marked household question %s as paid for user %s month %s",
                question_code,
                user_id,
                month,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to mark household question %s paid for user %s month %s: %s",
                question_code,
                user_id,
                month,
                error,
            )

    async def mark_household_question_unpaid(
        self, user_id: int, month: str, question_code: str
    ) -> None:
        """Mark household question as unpaid."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                INSERT INTO {TABLES.household_payments} (user_id, month, question_code, is_paid)
                VALUES (?, ?, ?, 0)
                ON CONFLICT(user_id, month, question_code)
                DO UPDATE SET is_paid = excluded.is_paid
                """,
                (user_id, month, question_code),
            )
            self.connection.commit()
            LOGGER.info(
                "Marked household question %s as unpaid for user %s month %s",
                question_code,
                user_id,
                month,
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to mark household question %s unpaid for user %s month %s: %s",
                question_code,
                user_id,
                month,
                error,
            )

    def apply_household_payment_answer(
        self,
        user_id: int,
        month: str,
        question_code: str,
        amount: float | None,
        answer: str,
        debit_category: str | None = None,
    ) -> bool:
        """Apply household answer and savings update atomically.

        Returns True if state changed, False if it was already applied.
        """

        try:
            cursor = self.connection.cursor()
            self.connection.execute("BEGIN")
            cursor.execute(
                f"""
                SELECT is_paid
                FROM {TABLES.household_payments}
                WHERE user_id = ? AND month = ? AND question_code = ?
                """,
                (user_id, month, question_code),
            )
            row = cursor.fetchone()
            if row is None:
                cursor.execute(
                    f"""
                    INSERT INTO {TABLES.household_payments} (user_id, month, question_code, is_paid)
                    VALUES (?, ?, ?, 0)
                    """,
                    (user_id, month, question_code),
                )
                current_paid = 0
            else:
                current_paid = int(row["is_paid"])

            target_paid = 1 if answer == "yes" else 0
            if current_paid == target_paid:
                self.connection.commit()
                return False

            cursor.execute(
                f"""
                UPDATE {TABLES.household_payments}
                SET is_paid = ?
                WHERE user_id = ? AND month = ? AND question_code = ?
                """,
                (target_paid, user_id, month, question_code),
            )
            if amount is not None:
                delta = -abs(amount) if answer == "yes" else abs(amount)
                target_category = debit_category or "–±—ã—Ç"
                self._update_saving_in_transaction(cursor, user_id, target_category, delta)
            self.connection.commit()
            return True
        except sqlite3.Error as error:
            self.connection.rollback()
            LOGGER.error(
                "Failed to apply household answer for user %s month %s code %s: %s",
                user_id,
                month,
                question_code,
                error,
            )
            return False

    async def get_unpaid_household_questions(self, user_id: int, month: str) -> List[str]:
        """Get unpaid household question codes for user and month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT items.code
                FROM {TABLES.household_payment_items} AS items
                LEFT JOIN {TABLES.household_payments} AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                ORDER BY items.position, items.id
                """,
                (month, user_id),
            )
            rows = cursor.fetchall()
            return [row["code"] for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get unpaid household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return []

    async def get_household_payment_status_map(
        self, user_id: int, month: str
    ) -> Dict[str, int]:
        """Return mapping: question_code -> is_paid (0/1) for the given month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT items.code, COALESCE(payments.is_paid, 0) AS is_paid
                FROM {TABLES.household_payment_items} AS items
                LEFT JOIN {TABLES.household_payments} AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ? AND items.is_active = 1
                """,
                (month, user_id),
            )
            rows = cursor.fetchall()
            return {row["code"]: int(row["is_paid"]) for row in rows}
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to get household payment status for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return {}

    async def has_unpaid_household_questions(self, user_id: int, month: str) -> bool:
        """Return True if unpaid household questions exist for month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT 1
                FROM {TABLES.household_payment_items} AS items
                LEFT JOIN {TABLES.household_payments} AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                LIMIT 1
                """,
                (month, user_id),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to check unpaid household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def should_show_household_payments_button(
        self, user_id: int, month: str
    ) -> bool:
        """Return True if any active household payment is unpaid for the month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT 1
                FROM {TABLES.household_payment_items} AS items
                LEFT JOIN {TABLES.household_payments} AS payments
                  ON payments.user_id = items.user_id
                 AND payments.month = ?
                 AND payments.question_code = items.code
                WHERE items.user_id = ?
                  AND items.is_active = 1
                  AND COALESCE(payments.is_paid, 0) = 0
                LIMIT 1
                """,
                (month, user_id),
            )
            return cursor.fetchone() is not None
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to decide household payments button for user %s month %s: %s",
                user_id,
                month,
                error,
            )
            return False

    async def reset_household_questions_for_month(self, user_id: int, month: str) -> None:
        """Reset household payment progress for a specific month."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.household_payments}
                SET is_paid = 0
                WHERE user_id = ? AND month = ?
                """,
                (user_id, month),
            )
            cursor.execute(
                f"""
                INSERT OR IGNORE INTO {TABLES.household_payments} (user_id, month, question_code, is_paid)
                SELECT ?, ?, code, 0
                FROM {TABLES.household_payment_items}
                WHERE user_id = ? AND is_active = 1
                """,
                (user_id, month, user_id),
            )
            self.connection.commit()
            LOGGER.info(
                "Reset household questions for user %s month %s", user_id, month
            )
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to reset household questions for user %s month %s: %s",
                user_id,
                month,
                error,
            )

    def get_purchases_by_user(self, user_id: int) -> List[Dict[str, Any]]:
        """Get purchases for user honoring retention settings."""

        self.ensure_user_settings(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"SELECT id, wish_name, price, category, purchased_at FROM {TABLES.purchases} WHERE user_id = ? ORDER BY purchased_at DESC",
                (user_id,),
            )
            rows = cursor.fetchall()
            LOGGER.info("Fetched purchases for user %s", user_id)
            purchases = [dict(row) for row in rows]
            filtered: list[Dict[str, Any]] = []
            current_time = now_tz()
            settings_row = self.get_user_settings(user_id)
            default_days = int(settings_row.get("purchased_keep_days", 30) or 30)
            categories = self.list_active_wishlist_categories(user_id)
            category_map = {
                cat.get("title", ""): {
                    "mode": (cat.get("purchased_mode") or "days"),
                    "days": int(cat.get("purchased_days") or default_days),
                }
                for cat in categories
            }
            for purchase in purchases:
                cat_settings = category_map.get(
                    str(purchase.get("category", "")),
                    {"mode": "days", "days": default_days},
                )
                if cat_settings.get("mode") == "always":
                    filtered.append(purchase)
                    continue
                keep_delta = timedelta(days=int(cat_settings.get("days", default_days)))
                timestamp = purchase.get("purchased_at")
                if timestamp:
                    try:
                        purchase_dt = datetime.fromisoformat(str(timestamp))
                        if purchase_dt.tzinfo is None:
                            purchase_dt = purchase_dt.replace(tzinfo=settings.TIMEZONE)
                    except ValueError:
                        continue
                    if purchase_dt + keep_delta <= current_time:
                        continue
                filtered.append(purchase)
            return filtered
        except sqlite3.Error as error:
            LOGGER.error("Failed to fetch purchases for user %s: %s", user_id, error)
            return []

    def list_active_byt_timer_times(self, user_id: int) -> List[Dict[str, Any]]:
        """Return active BYT timer times for user."""

        self.ensure_byt_timer_defaults(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id, hour, minute
                FROM {TABLES.byt_timer_times}
                WHERE user_id = ? AND is_active = 1
                ORDER BY hour, minute, id
                """,
                (user_id,),
            )
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to fetch BYT timer times for user %s: %s", user_id, error
            )
            return []

    def add_byt_timer_time(self, user_id: int, hour: int, minute: int) -> Optional[int]:
        """Add a new BYT timer time if not duplicate."""

        self.ensure_byt_timer_defaults(user_id)
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT id FROM {TABLES.byt_timer_times}
                WHERE user_id = ? AND hour = ? AND minute = ? AND is_active = 1
                LIMIT 1
                """,
                (user_id, hour, minute),
            )
            existing = cursor.fetchone()
            if existing:
                return int(existing["id"])

            cursor.execute(
                f"""
                INSERT INTO {TABLES.byt_timer_times} (user_id, hour, minute, is_active)
                VALUES (?, ?, ?, 1)
                """,
                (user_id, hour, minute),
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.Error as error:
            LOGGER.error("Failed to add BYT timer time for user %s: %s", user_id, error)
            return None

    def deactivate_byt_timer_time(self, user_id: int, timer_id: int) -> None:
        """Deactivate specific BYT timer time."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                UPDATE {TABLES.byt_timer_times}
                SET is_active = 0
                WHERE user_id = ? AND id = ?
                """,
                (user_id, timer_id),
            )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error(
                "Failed to deactivate BYT timer time %s for user %s: %s",
                timer_id,
                user_id,
                error,
            )

    def reset_byt_timer_times(self, user_id: int) -> None:
        """Reset BYT timer times to defaults."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"UPDATE {TABLES.byt_timer_times} SET is_active = 0 WHERE user_id = ?",
                (user_id,),
            )
            for hour, minute in [(12, 0), (18, 0)]:
                cursor.execute(
                    f"""
                    INSERT INTO {TABLES.byt_timer_times} (user_id, hour, minute, is_active)
                    VALUES (?, ?, ?, 1)
                    """,
                    (user_id, hour, minute),
                )
            self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to reset BYT timer times for user %s: %s", user_id, error)

    def get_users_with_byt_timer_times(self) -> List[int]:
        """Return users that have BYT timer times configured."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT DISTINCT user_id
                FROM {TABLES.byt_timer_times}
                WHERE is_active = 1
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with BYT timer times: %s", error)
            return []

    def get_users_with_active_byt_wishes(self) -> List[int]:
        """Return user ids that have active BYT wishes."""

        try:
            cursor = self.connection.cursor()
            cursor.execute(
                f"""
                SELECT DISTINCT user_id
                FROM {TABLES.wishes}
                WHERE is_purchased = 0 OR is_purchased IS NULL
                """
            )
            rows = cursor.fetchall()
            return [int(row["user_id"]) for row in rows]
        except sqlite3.Error as error:
            LOGGER.error("Failed to get users with active BYT wishes: %s", error)
            return []

    def cleanup_old_byt_purchases(
        self, user_id: int, category_title: str, now: Optional[datetime] = None
    ) -> None:
        """Remove BYT purchases older than one month from purchases and wishes."""

        if not category_title:
            return
        current_time = now or now_tz()
        try:
            cursor = self.connection.cursor()
            category_sql = "lower(trim(category)) = lower(trim(?))"
            params: tuple[Any, ...] = (user_id, category_title)
            if category_title.strip().casefold() == "–±—ã—Ç":
                category_sql = "lower(trim(category)) IN (lower(trim(?)), 'byt')"

            cursor.execute(
                f"""
                SELECT id, purchased_at
                FROM {TABLES.purchases}
                WHERE user_id = ?
                  AND {category_sql}
                """,
                params,
            )
            purchases = cursor.fetchall()
            ids_to_delete: list[int] = []
            for purchase in purchases:
                timestamp = purchase["purchased_at"]
                if not timestamp:
                    continue
                try:
                    purchase_dt = datetime.fromisoformat(timestamp)
                    if purchase_dt.tzinfo is None:
                        purchase_dt = purchase_dt.replace(tzinfo=settings.TIMEZONE)
                except ValueError:
                    continue
                if add_one_month(purchase_dt) <= current_time:
                    ids_to_delete.append(int(purchase["id"]))

            if ids_to_delete:
                placeholders = ",".join("?" * len(ids_to_delete))
                query = "DELETE FROM {} WHERE id IN ({})".format(
                    TABLES.purchases,
                    placeholders,
                )
                cursor.execute(
                    query,
                    ids_to_delete,
                )

            cursor.execute(
                f"""
                SELECT id, purchased_at
                FROM {TABLES.wishes}
                WHERE user_id = ?
                  AND {category_sql}
                  AND is_purchased = 1
                """,
                params,
            )
            wish_rows = cursor.fetchall()
            wish_ids: list[int] = []
            for wish in wish_rows:
                purchased_at = wish["purchased_at"]
                if not purchased_at:
                    continue
                try:
                    wish_dt = datetime.fromisoformat(purchased_at)
                    if wish_dt.tzinfo is None:
                        wish_dt = wish_dt.replace(tzinfo=settings.TIMEZONE)
                except ValueError:
                    continue
                if add_one_month(wish_dt) <= current_time:
                    wish_ids.append(int(wish["id"]))

            if wish_ids:
                placeholders = ",".join("?" * len(wish_ids))
                query = "DELETE FROM {} WHERE id IN ({})".format(
                    TABLES.wishes,
                    placeholders,
                )
                cursor.execute(
                    query,
                    wish_ids,
                )
            if ids_to_delete or wish_ids:
                self.connection.commit()
        except sqlite3.Error as error:
            LOGGER.error("Failed to cleanup old BYT purchases: %s", error)

    def close(self) -> None:
        """Close database connection."""

        try:
            self.connection.close()
            LOGGER.info("Database connection closed")
        except sqlite3.Error as error:
            LOGGER.error("Failed to close database connection: %s", error)

===== Bot/database/get_db.py =====

"""Database accessor for a shared FinanceDatabase instance."""
from __future__ import annotations

from Bot.database.crud import FinanceDatabase

_DB_INSTANCE: FinanceDatabase | None = None


def get_db() -> FinanceDatabase:
    global _DB_INSTANCE
    if _DB_INSTANCE is None:
        _DB_INSTANCE = FinanceDatabase()
    return _DB_INSTANCE

===== Bot/database/models.py =====

"""Database model helpers."""
from dataclasses import dataclass
from typing import Optional


@dataclass
class Saving:
    """Saving record representation."""

    id: int
    user_id: int
    category: str
    current: float
    goal: float
    purpose: str


@dataclass
class Wish:
    """Wish record representation."""

    id: int
    user_id: int
    name: str
    price: float
    url: Optional[str]
    category: str
    is_purchased: bool
    saved_amount: float
    purchased_at: Optional[str]
    deferred_until: Optional[str]


@dataclass
class Purchase:
    """Purchase record representation."""

    id: int
    user_id: int
    wish_name: str
    price: float
    category: str
    purchased_at: str

===== Bot/handlers/__init__.py =====



===== Bot/handlers/callbacks.py =====

"""Callback query handlers."""
import logging
from typing import Dict
from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup

from Bot.database.get_db import get_db
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.finances import (
    _format_savings_summary,
    show_affordable_wishes,
)
from Bot.keyboards.main import back_only_keyboard, wishlist_categories_keyboard
from Bot.states.wishlist_states import WishlistState
from Bot.handlers.wishlist import (
    _get_user_wishlist_categories,
    humanize_wishlist_category,
)
from Bot.utils.telegram_safe import (
    safe_answer,
    safe_callback_answer,
    safe_delete_message,
    safe_edit_message_text,
)
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()

@router.callback_query(F.data.startswith("wlcat:"))
async def handle_category_selection(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle category selection for viewing or adding wishes."""

    await safe_callback_answer(callback, logger=LOGGER)
    try:
        category_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await safe_callback_answer(callback, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è", show_alert=True, logger=LOGGER)
        return

    db = get_db()
    category_row = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category_row:
        await safe_callback_answer(callback, "–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True, logger=LOGGER)
        return

    category_code = category_row.get("title", "")
    category = humanize_wishlist_category(category_code)
    data = await state.get_data()
    current_state = await state.get_state()

    if current_state == WishlistState.waiting_for_category.state:
        await _finalize_wish(callback, state, category_code, category)
        return

    await _send_wishes_list(callback, category)


@router.callback_query(F.data == "wishlist_skip_url")
async def skip_wishlist_url(callback: CallbackQuery, state: FSMContext) -> None:
    """Skip wishlist URL step via inline button."""

    await safe_callback_answer(callback, logger=LOGGER)
    current_state = await state.get_state()
    if current_state != WishlistState.waiting_for_url.state:
        return

    await state.update_data(url=None)
    await state.set_state(WishlistState.waiting_for_category)
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != "category":
        stack.append("category")
    await state.update_data(wl_add_step_stack=stack)
    if callback.message:
        await safe_delete_message(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            logger=LOGGER,
        )
        categories = _get_user_wishlist_categories(get_db(), callback.from_user.id)
        if not categories:
            await safe_answer(
                callback.message,
                "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ–∫–∞ –Ω–µ—Ç. –î–æ–±–∞–≤—å –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
                reply_markup=back_only_keyboard(),
                logger=LOGGER,
            )
            await state.clear()
            return
        await safe_answer(
            callback.message,
            "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∂–µ–ª–∞–Ω–∏—è.",
            reply_markup=wishlist_categories_keyboard(
                categories
            ),
            logger=LOGGER,
        )
        await safe_answer(
            callback.message,
            "–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.",
            reply_markup=back_only_keyboard(),
            logger=LOGGER,
        )


async def _finalize_wish(
    callback: CallbackQuery,
    state: FSMContext,
    category_code: str,
    humanized_category: str,
) -> None:
    """Finalize wish creation after category selection."""

    db = get_db()
    data = await state.get_data()
    wish_id = db.add_wish(
        user_id=callback.from_user.id,
        name=data.get("name", ""),
        price=float(data.get("price", 0)),
        url=data.get("url"),
        category=category_code,
    )
    lines = [
        f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {humanized_category}",
        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {data.get('name')}",
        f"–¶–µ–Ω–∞: {data.get('price')}",
        f"ID: {wish_id}",
    ]
    url = data.get("url")
    if url:
        lines.insert(3, f"–°—Å—ã–ª–∫–∞: {url}")
    if callback.message:
        info_id = await safe_answer(callback.message, "\n".join(lines), logger=LOGGER)
        if info_id:
            await ui_register_message(state, callback.message.chat.id, info_id)
        sent_id = await safe_answer(
            callback.message,
            "‚úÖ –ñ–µ–ª–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ",
            reply_markup=await build_main_menu_for_user(callback.from_user.id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, callback.message.chat.id, sent_id)
    await state.clear()
    LOGGER.info("User %s added wish %s", callback.from_user.id, wish_id)


async def _send_wishes_list(callback: CallbackQuery, category: str) -> None:
    """Send wishlist items for selected category."""

    db = get_db()
    wishes = db.get_wishes_by_user(callback.from_user.id)
    savings_map = db.get_user_savings_map(callback.from_user.id)
    debit_category = db.get_wishlist_debit_category(callback.from_user.id)
    saved_amount = (
        float(savings_map.get(debit_category, 0.0) or 0.0) if debit_category else 0.0
    )
    filtered = [
        wish
        for wish in wishes
        if (
            humanize_wishlist_category(wish.get("category", ""))
            == humanize_wishlist_category(category)
        )
        and not wish.get("is_purchased")
    ]

    if not filtered:
        if callback.message:
            edited = await safe_edit_message_text(
                callback.message.bot,
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                text="–ñ–µ–ª–∞–Ω–∏–π –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç.",
                reply_markup=wishlist_categories_keyboard(
                    _get_user_wishlist_categories(db, callback.from_user.id)
                ),
                logger=LOGGER,
            )
            if not edited:
                await safe_answer(
                    callback.message,
                    "–ñ–µ–ª–∞–Ω–∏–π –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç.",
                    reply_markup=wishlist_categories_keyboard(
                        _get_user_wishlist_categories(db, callback.from_user.id)
                    ),
                    logger=LOGGER,
                )
        return

    for wish in filtered:
        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        price = float(wish.get("price", 0) or 0.0)

        if price > 0:
            progress = min(saved_amount / price, 1.0)
        else:
            progress = 0.0
        total_blocks = 10
        filled_blocks = int(progress * total_blocks)
        bar = "‚ñ†" * filled_blocks + "‚ñ°" * (total_blocks - filled_blocks)
        remaining = max(price - saved_amount, 0.0)
        progress_percent = round(progress * 100)

        lines = [
            f"{wish['name']} ‚Äî {price:.2f} ({wishlist_category})",
            f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {bar} {progress_percent}%",
            f"–ù–∞–∫–æ–ø–ª–µ–Ω–æ: {saved_amount:.2f}, –æ—Å—Ç–∞–ª–æ—Å—å: {remaining:.2f}",
        ]
        if wish.get("url"):
            lines.append(f"–°—Å—ã–ª–∫–∞: {wish['url']}")
        text = "\n".join(lines)
        inline_kb = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="–ö—É–ø–∏–ª", callback_data=f"wish_buy_{wish['id']}")]]
        )
        if callback.message:
            await safe_answer(callback.message, text, reply_markup=inline_kb, logger=LOGGER)


@router.callback_query(F.data.startswith("wish_buy_"))
async def handle_wish_purchase(callback: CallbackQuery) -> None:
    """Handle purchase of a wish."""

    await safe_callback_answer(callback, logger=LOGGER)
    wish_id = int(callback.data.split("wish_buy_")[-1])
    db = get_db()
    wish = db.get_wish(wish_id)

    if not wish:
        await safe_callback_answer(callback, "–ñ–µ–ª–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True, logger=LOGGER)
        return
    if wish.get("is_purchased") or wish.get("debited_at"):
        await safe_callback_answer(callback, "–£–∂–µ –æ—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–µ.", logger=LOGGER)
        return

    wishlist_category = humanize_wishlist_category(wish.get("category"))
    price = float(wish.get("price", 0) or 0.0)
    LOGGER.info(
        "USER=%s ACTION=WISHLIST_PURCHASE META=item_id=%s price=%.2f",
        callback.from_user.id,
        wish_id,
        price,
    )
    debit_category = db.get_wishlist_debit_category(callback.from_user.id)

    if debit_category is not None:
        income_category = db.get_income_category_by_code(callback.from_user.id, debit_category)
        if not income_category:
            await safe_callback_answer(
                "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–ø–∏—Å–∞—Ç—å: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞/—É–¥–∞–ª–µ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–ø–∏—Å–∞–Ω–∏—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Wishlist.",
                show_alert=True,
                logger=LOGGER,
            )
            return

    result = db.purchase_wish(callback.from_user.id, wish_id, debit_category)
    status = result.get("status")
    if status == "not_found":
        await safe_callback_answer(callback, "–ñ–µ–ª–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True, logger=LOGGER)
        return
    if status == "already":
        await safe_callback_answer(callback, "–£–∂–µ –æ—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–µ.", logger=LOGGER)
        return
    if status == "insufficient":
        await safe_callback_answer(
            (
                "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –≤ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è—Ö –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.\n"
                f"–ù—É–∂–Ω–æ: {price:.2f}, –¥–æ—Å—Ç—É–ø–Ω–æ: {float(result.get('available', 0.0)):.2f}."
            ),
            show_alert=True,
            logger=LOGGER,
        )
        return
    if status == "error":
        await safe_callback_answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–ø–∏—Å–∞—Ç—å: –æ—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.",
            show_alert=True,
            logger=LOGGER,
        )
        return

    if callback.message:
        await safe_edit_message_text(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            text=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é, —Ç—ã –∫—É–ø–∏–ª {wish['name']} –∑–∞ {price:.2f}!",
            logger=LOGGER,
        )
    if status == "debited":
        LOGGER.info(
            "USER=%s ACTION=WISHLIST_DEBIT META=category=%s amount=%.2f item_id=%s",
            callback.from_user.id,
            debit_category,
            price,
            wish_id,
        )
        savings = db.get_user_savings(callback.from_user.id)
        categories_map = db.get_income_categories_map(callback.from_user.id)
        summary = _format_savings_summary(savings, categories_map)
        if callback.message:
            await safe_answer(
                callback.message, f"–û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}", logger=LOGGER
            )
            await show_affordable_wishes(
                message=callback.message, user_id=callback.from_user.id, db=db
            )


@router.callback_query(F.data == "affordable_wishes_later")
async def handle_affordable_wishes_later(callback: CallbackQuery, state: FSMContext) -> None:
    """Close affordable wish suggestions and return to main menu."""

    await safe_callback_answer(callback, logger=LOGGER)
    await state.clear()
    if callback.message:
        try:
            await callback.message.edit_reply_markup(reply_markup=None)
        except Exception:
            LOGGER.debug("Failed to clear inline keyboard for affordable wishes", exc_info=True)
        sent_id = await safe_answer(
            callback.message,
            "–•–æ—Ä–æ—à–æ, –≤–µ—Ä–Ω—ë–º—Å—è –∫ –ø–æ–∫—É–ø–∫–∞–º –ø–æ–∑–∂–µ. –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=await build_main_menu_for_user(callback.from_user.id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, callback.message.chat.id, sent_id)

===== Bot/handlers/common.py =====

"""Common handlers and fallbacks."""
import logging

from aiogram import Router
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ReplyKeyboardMarkup

from Bot.config import settings
from Bot.database.get_db import get_db
from Bot.keyboards.main import main_menu_keyboard
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def build_main_menu_for_user(user_id: int) -> ReplyKeyboardMarkup:
    """Construct main menu keyboard with optional household button."""

    db = get_db()
    from Bot.handlers.household_payments import reset_household_cycle_if_needed

    await reset_household_cycle_if_needed(user_id, db)
    month = current_month_str()
    show_household = await db.should_show_household_payments_button(user_id, month)
    show_test_button = user_id == settings.ADMIN_ID
    return main_menu_keyboard(
        show_household=show_household,
        show_test_button=show_test_button,
        show_settings=True,
    )


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Compatibility no-op; welcome messages are kept."""

    return None


@router.message()
async def fallback_handler(message: Message, state: FSMContext) -> None:
    """Handle unmatched messages."""

    await delete_welcome_message_if_exists(message, state)
    current_state = await state.get_state()
    LOGGER.debug("Fallback triggered. User: %s State: %s Text: %s", message.from_user.id, current_state, message.text)
    sent = await message.answer(
        "–ù–µ –ø–æ–Ω—è–ª —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ª—å–∑—É–π—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –∏–ª–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

===== Bot/handlers/finances.py =====

"""Handlers for income calculation and savings."""
import logging
from typing import Any, Dict, List, Optional

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, Message

from Bot.database.crud import FinanceDatabase
from Bot.database.get_db import get_db
from Bot.keyboards.main import (
    back_to_main_keyboard,
    purchase_confirmation_keyboard,
    yes_no_inline_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.handlers.common import build_main_menu_for_user
from Bot.states.money_states import MoneyState
from Bot.handlers.wishlist import humanize_wishlist_category
from Bot.utils.savings import find_reached_goal, format_savings_summary
from Bot.utils.telegram_safe import safe_delete_message, safe_edit_message_text
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


def _message_user_id(message: Message) -> int:
    """Extract user id from message."""

    return message.from_user.id if message.from_user else message.chat.id


def _callback_user_id(callback: CallbackQuery) -> int:
    """Extract user id from callback."""

    if callback.from_user:
        return callback.from_user.id
    return callback.message.chat.id


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

INCOME_DIGITS = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}
INCOME_INPUT_BUTTONS = INCOME_DIGITS | {"–û—á–∏—Å—Ç–∏—Ç—å"}


def _build_allocations(categories: List[Dict[str, Any]], amount: float) -> List[Dict[str, Any]]:
    """Build allocation list from income categories."""

    allocations: List[Dict[str, Any]] = []
    for category in categories:
        percent = float(category.get("percent", 0))
        allocated = amount * percent / 100
        allocations.append(
            {
                "label": category.get("title", ""),
                "category": category.get("code", ""),
                "amount": allocated,
            }
        )
    return allocations


def _build_income_prompt(income_sum: str) -> str:
    """Build income input prompt."""

    # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å—É–º–º—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ ": <—á–∏—Å–ª–æ>"
    return f": {income_sum}"


async def _refresh_income_message(
    message: Message, income_message_id: Optional[int], income_sum: str
) -> int:
    """Update or create income prompt message with current sum.

    –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –ø–æ —Å—É–º–º–µ.
    –ï—Å–ª–∏ id –Ω–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫) ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ.
    –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ,
    —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–∏–¥–µ–ª –∞–∫—Ç—É–∞–ª—å–Ω—É—é —Å—É–º–º—É.
    """

    text = _build_income_prompt(income_sum)

    # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –µ—â—ë –Ω–µ –±—ã–ª–æ ‚Äî —Å–æ–∑–¥–∞—ë–º –µ–≥–æ
    if income_message_id is None:
        new_message = await message.answer(text)
        return new_message.message_id

    edited = await safe_edit_message_text(
        message.bot,
        chat_id=message.chat.id,
        message_id=income_message_id,
        text=text,
        logger=LOGGER,
    )
    if edited:
        return income_message_id

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=income_message_id,
        logger=LOGGER,
    )

    new_message = await message.answer(text)
    return new_message.message_id


def _to_float(value: Any) -> float:
    """Safely convert value to float."""

    try:
        return float(value) if value is not None else 0.0
    except (TypeError, ValueError):
        return 0.0


def _format_savings_summary(
    savings: Dict[str, Dict[str, Any]],
    categories_map: Dict[str, str] | None = None,
) -> str:
    """Format savings summary for user message."""

    return format_savings_summary(savings, categories_map)


def _find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> tuple[str, Dict[str, Any]] | tuple[None, None]:
    """Find category where goal is reached."""

    return find_reached_goal(savings)


async def _ask_allocation_confirmation(
    message: Message, state: FSMContext, allocation: Dict[str, Any]
) -> None:
    """Ask user to confirm allocation for a specific category.

    Args:
        message: Aiogram message object used for sending prompts.
        allocation: Allocation details with label and amount.
    """

    text = (
        f"–ù–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—é {allocation['label']} –º–æ–∂–Ω–æ –Ω–∞–ø—Ä–∞–≤–∏—Ç—å "
        f"{allocation['amount']:.2f}. –ü–µ—Ä–µ–≤–µ—Å—Ç–∏?"
    )
    data = await state.get_data()
    existing_id: Optional[int] = data.get("allocation_question_message_id")
    if existing_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=message.chat.id,
            message_id=existing_id,
            text=text,
            reply_markup=yes_no_inline_keyboard(),
            logger=LOGGER,
        )
        if edited:
            return

    sent = await message.answer(text, reply_markup=yes_no_inline_keyboard())
    await state.update_data(allocation_question_message_id=sent.message_id)


@router.message(F.text == "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")
async def start_income_flow(message: Message, state: FSMContext) -> None:
    """Start income calculation workflow with calculator keyboard."""

    await delete_welcome_message_if_exists(message, state)
    await state.clear()
    user_id = message.from_user.id
    categories = get_db().list_active_income_categories(user_id)
    if not categories:
        sent = await message.answer(
            '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–æ—Ö–æ–¥–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã. –û—Ç–∫—Ä–æ–π "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –î–æ—Ö–æ–¥" –∏ –¥–æ–±–∞–≤—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–∞—Ç–µ–≥–æ—Ä–∏—é.',
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        try:
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
        except Exception:  # noqa: BLE001
            LOGGER.warning("Failed to delete user command message", exc_info=True)
        LOGGER.info("USER=%s ACTION=INCOME_START_NO_CATEGORIES", user_id)
        return
    await state.set_state(MoneyState.waiting_for_amount)

    income_sum = "0"
    question = await message.answer(
        "–í–≤–µ–¥–∏ —Å—É–º–º—É –¥–æ—Ö–æ–¥–∞ (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = _build_income_prompt(income_sum)
    income_message = await message.answer(prompt)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ message_id –∏ —Ç–µ–∫—É—â—É—é —Å—É–º–º—É
    await state.update_data(
        income_sum=income_sum,
        income_question_message_id=question.message_id,
        income_message_id=income_message.message_id,
    )

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥"
    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:  # noqa: BLE001
        LOGGER.warning("Failed to delete user command message", exc_info=True)

    LOGGER.info(
        "User %s started income calculation",
        message.from_user.id if message.from_user else "unknown",
    )


async def _process_income_amount_value(
    message: Message,
    state: FSMContext,
    amount: float,
) -> None:
    """Validate amount and start category confirmation workflow."""

    # –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Å—É–º–º—ã
    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–µ –±–æ–ª—å—à–µ 10 000 000. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
        return

    # –£–¥–∞–ª—è–µ–º —Å–ª—É–∂–µ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Å—É–º–º–æ–π –∏ –≤–æ–ø—Ä–æ—Å —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
    data = await state.get_data()
    income_question_message_id: Optional[int] = data.get("income_question_message_id")
    income_message_id: Optional[int] = data.get("income_message_id")

    if income_question_message_id:
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=income_question_message_id,
            logger=LOGGER,
        )

    if income_message_id:
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=income_message_id,
            logger=LOGGER,
        )

    db = get_db()
    categories = db.list_active_income_categories(message.from_user.id)
    total_percent = db.sum_income_category_percents(message.from_user.id)
    if total_percent != 100:
        sent = await message.answer(
            f"–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å 100%. –°–µ–π—á–∞—Å: {total_percent}%. –ò—Å–ø—Ä–∞–≤—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–µ—Ä–µ–∑ ‚öôÔ∏è ‚Üí üìä –î–æ—Ö–æ–¥.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    allocations: List[Dict[str, Any]] = _build_allocations(categories, amount)

    if not allocations:
        sent = await message.answer(
            "–ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ FSM
    await state.update_data(
        income_amount=amount,
        allocations=allocations,
        index=0,
        life_message_id=None,
    )

    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    await state.set_state(MoneyState.confirm_category)

    # –ó–∞–¥–∞—ë–º –≤–æ–ø—Ä–æ—Å –¢–û–õ–¨–ö–û –ø–æ –ø–µ—Ä–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    current = allocations[0]
    await _ask_allocation_confirmation(
        message=message,
        state=state,
        allocation=current,
    )

    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:
        pass


@router.message(
    MoneyState.waiting_for_amount,
    F.text.in_(INCOME_INPUT_BUTTONS),
)
async def handle_income_digit(message: Message, state: FSMContext) -> None:
    """Handle digit and clear input for income calculator."""

    data = await state.get_data()
    current_sum = str(data.get("income_sum", "0"))
    sum_message_id = data.get("income_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    income_message_id = await _refresh_income_message(
        message=message,
        income_message_id=sum_message_id,
        income_sum=new_sum,
    )

    await state.update_data(income_sum=new_sum, income_message_id=income_message_id)

    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:
        pass


@router.message(MoneyState.waiting_for_amount, F.text == "‚úÖ –ì–∞–∑")
async def handle_income_confirm(message: Message, state: FSMContext) -> None:
    """Handle confirmation of income input via calculator button."""

    data = await state.get_data()
    amount_str = str(data.get("income_sum", "0")).strip()

    if not amount_str:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–±–µ—Ä–∏ —Å—É–º–º—É —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫.")
        try:
            await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
        except Exception:
            pass
        return

    normalized = amount_str.replace(",", ".")
    try:
        amount = float(normalized)
    except ValueError:
        await message.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        try:
            await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
        except Exception:
            pass
        return

    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–µ –±–æ–ª—å—à–µ 10 000 000. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
        try:
            await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
        except Exception:
            pass
        return

    await _process_income_amount_value(
        message=message,
        state=state,
        amount=amount,
    )

    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:
        pass


@router.callback_query(MoneyState.confirm_category, F.data.in_({"confirm_yes", "confirm_no"}))
async def handle_category_confirmation(query: CallbackQuery, state: FSMContext) -> None:
    """Handle user confirmation for category allocation via inline buttons."""

    await query.answer()

    data = await state.get_data()
    allocations: List[Dict[str, Any]] = data.get("allocations", [])
    index: int = int(data.get("index", 0))
    # –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ—Ç –∏–ª–∏ –∏–Ω–¥–µ–∫—Å –≤—ã—à–µ–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã ‚Äî –≤—ã—Ö–æ–¥–∏–º –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    if not allocations or index >= len(allocations):
        sent = await query.message.answer(
            "–ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.",
            reply_markup=await build_main_menu_for_user(_callback_user_id(query)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    current = allocations[index]

    # --- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª "–î–∞" ---
    if query.data == "confirm_yes":
        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
        get_db().update_saving(
            user_id=query.from_user.id if query.from_user else None,
            category=current["category"],
            amount_delta=current["amount"],
        )

        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        index += 1

    # --- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª "–ù–µ—Ç" ---
    else:
        await query.answer("–¢—ã —á—Ç–æ –ø—Ä–æ –∂–∏–∑–Ω—å –∑–∞–±—ã–ª?", show_alert=True)

    # –ï—Å–ª–∏ –µ—â—ë –µ—Å—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Äî –∑–∞–¥–∞—ë–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
    if index < len(allocations):
        await state.update_data(
            index=index,
        )
        next_allocation = allocations[index]
        await _ask_allocation_confirmation(
            message=query.message,
            state=state,
            allocation=next_allocation,
        )
    else:
        try:
            await query.message.edit_reply_markup(reply_markup=None)
        except Exception:
            pass
        await _send_summary_and_goal_prompt(
            message=query.message,
            state=state,
            user_id=query.from_user.id if query.from_user else None,
        )


async def _send_summary_and_goal_prompt(
    message: Message,
    state: FSMContext,
    user_id: Optional[int],
) -> None:
    """Send savings summary and suggest purchase if goal reached."""

    # –î–æ—Å—Ç–∞—ë–º —Å—É–º–º—É, –∫–æ—Ç–æ—Ä—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª –∫–∞–∫ –¥–æ—Ö–æ–¥
    data = await state.get_data()
    income_amount = data.get("income_amount", 0)

    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º user_id, –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–ª–∏ —è–≤–Ω–æ
    if user_id is None:
        user_id = message.from_user.id if message.from_user else message.chat.id

    await state.clear()
    db = get_db()

    # –ß–∏—Ç–∞–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª—å–Ω–æ–º—É user_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    savings = db.get_user_savings(user_id)
    categories_map = db.get_income_categories_map(user_id)
    summary = _format_savings_summary(savings, categories_map)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç: —Å–Ω–∞—á–∞–ª–∞ "–ü–æ–ª—É—á–µ–Ω–æ –±–∞–±–æ–∫", –∑–∞—Ç–µ–º —Ç–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
    lines: List[str] = []
    if income_amount:
        lines.append(f"–ü–æ–ª—É—á–µ–Ω–æ –±–∞–±–æ–∫: {income_amount:.2f}")
        lines.append("")  # –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏

    lines.append("–¢–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:")
    lines.append(summary)

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(user_id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

    category, goal_data = _find_reached_goal(savings)
    if category:
        goal = goal_data.get("goal", 0)
        purpose = goal_data.get("purpose", "—Ü–µ–ª—å")
        current = goal_data.get("current", 0)
        await message.answer(
            f"üéØ –¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}. "
            f"–ù–∞ —Ü–µ–ª–∏ {purpose} –Ω–∞–∫–æ–ø–ª–µ–Ω–æ {current:.2f} –∏–∑ {goal:.2f}.",
            reply_markup=purchase_confirmation_keyboard(),
        )
        await state.update_data(category=category, goal=goal)
        await state.set_state(MoneyState.waiting_for_purchase_confirmation)
        return

    # –ü–æ–¥–±–æ—Ä –∂–µ–ª–∞–Ω–∏–π –∏–∑ –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ —Ç–µ–º –∂–µ savings –∏ user_id
    await show_affordable_wishes(
        message=message,
        user_id=user_id,
        db=db,
    )


def _build_affordable_wishes_keyboard(wishes: List[Dict[str, Any]]) -> InlineKeyboardMarkup:
    """Build inline keyboard with purchase buttons for affordable wishes."""

    buttons = [
        [InlineKeyboardButton(text=f"{wish['name']}", callback_data=f"wish_buy_{wish['id']}")]
        for wish in wishes
    ]
    buttons.append([InlineKeyboardButton(text="–ü–æ—Ç–æ–º", callback_data="affordable_wishes_later")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


async def show_affordable_wishes(
    message: Message,
    user_id: int | None = None,
    db: FinanceDatabase | None = None,
) -> None:
    """Show all wishes that are affordable with current savings."""

    if message is None:
        return

    if user_id is None:
        user_id = message.from_user.id if message.from_user else None

