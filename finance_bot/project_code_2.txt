===== Bot/database/get_db.py =====


"""Database accessor for a shared FinanceDatabase instance."""
from __future__ import annotations

from Bot.database.crud import FinanceDatabase

_DB_INSTANCE: FinanceDatabase | None = None


def get_db() -> FinanceDatabase:
    global _DB_INSTANCE
    if _DB_INSTANCE is None:
        _DB_INSTANCE = FinanceDatabase()
    return _DB_INSTANCE

===== Bot/database/models.py =====


"""Database model helpers."""
from dataclasses import dataclass
from typing import Optional


@dataclass
class Saving:
    """Saving record representation."""

    id: int
    user_id: int
    category: str
    current: float
    goal: float
    purpose: str


@dataclass
class Wish:
    """Wish record representation."""

    id: int
    user_id: int
    name: str
    price: float
    url: Optional[str]
    category: str
    is_purchased: bool
    saved_amount: float
    purchased_at: Optional[str]
    deferred_until: Optional[str]


@dataclass
class Purchase:
    """Purchase record representation."""

    id: int
    user_id: int
    wish_name: str
    price: float
    category: str
    purchased_at: str

===== Bot/handlers/__init__.py =====



===== Bot/handlers/callbacks.py =====

"""Callback query handlers."""
import logging
from typing import Dict
from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup

from Bot.database.get_db import get_db
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.finances import (
    _format_savings_summary,
    show_affordable_wishes,
)
from Bot.keyboards.main import back_only_keyboard, wishlist_categories_keyboard
from Bot.states.wishlist_states import WishlistState
from Bot.handlers.wishlist import (
    _get_user_wishlist_categories,
    humanize_wishlist_category,
)
from Bot.utils.telegram_safe import (
    safe_answer,
    safe_callback_answer,
    safe_delete_message,
    safe_edit_message_text,
)
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()

@router.callback_query(F.data.startswith("wlcat:"))
async def handle_category_selection(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle category selection for viewing or adding wishes."""

    await safe_callback_answer(callback, logger=LOGGER)
    try:
        category_id = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        await safe_callback_answer(callback, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è", show_alert=True, logger=LOGGER)
        return

    db = get_db()
    category_row = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category_row:
        await safe_callback_answer(callback, "–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True, logger=LOGGER)
        return

    category_code = category_row.get("title", "")
    category = humanize_wishlist_category(category_code)
    data = await state.get_data()
    current_state = await state.get_state()

    if current_state == WishlistState.waiting_for_category.state:
        await _finalize_wish(callback, state, category_code, category)
        return

    await _send_wishes_list(callback, category)


@router.callback_query(F.data == "wishlist_skip_url")
async def skip_wishlist_url(callback: CallbackQuery, state: FSMContext) -> None:
    """Skip wishlist URL step via inline button."""

    await safe_callback_answer(callback, logger=LOGGER)
    current_state = await state.get_state()
    if current_state != WishlistState.waiting_for_url.state:
        return

    await state.update_data(url=None)
    await state.set_state(WishlistState.waiting_for_category)
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != "category":
        stack.append("category")
    await state.update_data(wl_add_step_stack=stack)
    if callback.message:
        await safe_delete_message(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            logger=LOGGER,
        )
        categories = _get_user_wishlist_categories(get_db(), callback.from_user.id)
        if not categories:
            await safe_answer(
                callback.message,
                "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ–∫–∞ –Ω–µ—Ç. –î–æ–±–∞–≤—å –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
                reply_markup=back_only_keyboard(),
                logger=LOGGER,
            )
            await state.clear()
            return
        await safe_answer(
            callback.message,
            "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∂–µ–ª–∞–Ω–∏—è.",
            reply_markup=wishlist_categories_keyboard(
                categories
            ),
            logger=LOGGER,
        )
        await safe_answer(
            callback.message,
            "–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.",
            reply_markup=back_only_keyboard(),
            logger=LOGGER,
        )


async def _finalize_wish(
    callback: CallbackQuery,
    state: FSMContext,
    category_code: str,
    humanized_category: str,
) -> None:
    """Finalize wish creation after category selection."""

    db = get_db()
    data = await state.get_data()
    wish_id = db.add_wish(
        user_id=callback.from_user.id,
        name=data.get("name", ""),
        price=float(data.get("price", 0)),
        url=data.get("url"),
        category=category_code,
    )
    lines = [
        f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {humanized_category}",
        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {data.get('name')}",
        f"–¶–µ–Ω–∞: {data.get('price')}",
        f"ID: {wish_id}",
    ]
    url = data.get("url")
    if url:
        lines.insert(3, f"–°—Å—ã–ª–∫–∞: {url}")
    if callback.message:
        info_id = await safe_answer(callback.message, "\n".join(lines), logger=LOGGER)
        if info_id:
            await ui_register_message(state, callback.message.chat.id, info_id)
        sent_id = await safe_answer(
            callback.message,
            "‚úÖ –ñ–µ–ª–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ",
            reply_markup=await build_main_menu_for_user(callback.from_user.id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, callback.message.chat.id, sent_id)
    await state.clear()
    LOGGER.info("User %s added wish %s", callback.from_user.id, wish_id)


async def _send_wishes_list(callback: CallbackQuery, category: str) -> None:
    """Send wishlist items for selected category."""

    db = get_db()
    wishes = db.get_wishes_by_user(callback.from_user.id)
    savings_map = db.get_user_savings_map(callback.from_user.id)
    debit_category = db.get_wishlist_debit_category(callback.from_user.id)
    saved_amount = (
        float(savings_map.get(debit_category, 0.0) or 0.0) if debit_category else 0.0
    )
    filtered = [
        wish
        for wish in wishes
        if (
            humanize_wishlist_category(wish.get("category", ""))
            == humanize_wishlist_category(category)
        )
        and not wish.get("is_purchased")
    ]

    if not filtered:
        if callback.message:
            edited = await safe_edit_message_text(
                callback.message.bot,
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                text="–ñ–µ–ª–∞–Ω–∏–π –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç.",
                reply_markup=wishlist_categories_keyboard(
                    _get_user_wishlist_categories(db, callback.from_user.id)
                ),
                logger=LOGGER,
            )
            if not edited:
                await safe_answer(
                    callback.message,
                    "–ñ–µ–ª–∞–Ω–∏–π –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç.",
                    reply_markup=wishlist_categories_keyboard(
                        _get_user_wishlist_categories(db, callback.from_user.id)
                    ),
                    logger=LOGGER,
                )
        return

    for wish in filtered:
        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        price = float(wish.get("price", 0) or 0.0)

        if price > 0:
            progress = min(saved_amount / price, 1.0)
        else:
            progress = 0.0
        total_blocks = 10
        filled_blocks = int(progress * total_blocks)
        bar = "‚ñ†" * filled_blocks + "‚ñ°" * (total_blocks - filled_blocks)
        remaining = max(price - saved_amount, 0.0)
        progress_percent = round(progress * 100)

        lines = [
            f"{wish['name']} ‚Äî {price:.2f} ({wishlist_category})",
            f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {bar} {progress_percent}%",
            f"–ù–∞–∫–æ–ø–ª–µ–Ω–æ: {saved_amount:.2f}, –æ—Å—Ç–∞–ª–æ—Å—å: {remaining:.2f}",
        ]
        if wish.get("url"):
            lines.append(f"–°—Å—ã–ª–∫–∞: {wish['url']}")
        text = "\n".join(lines)
        inline_kb = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="–ö—É–ø–∏–ª", callback_data=f"wish_buy_{wish['id']}")]]
        )
        if callback.message:
            await safe_answer(callback.message, text, reply_markup=inline_kb, logger=LOGGER)


@router.callback_query(F.data.startswith("wish_buy_"))
async def handle_wish_purchase(callback: CallbackQuery) -> None:
    """Handle purchase of a wish."""

    await safe_callback_answer(callback, logger=LOGGER)
    wish_id = int(callback.data.split("wish_buy_")[-1])
    db = get_db()
    wish = db.get_wish(wish_id)

    if not wish:
        await safe_callback_answer(callback, "–ñ–µ–ª–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True, logger=LOGGER)
        return
    if wish.get("is_purchased") or wish.get("debited_at"):
        await safe_callback_answer(callback, "–£–∂–µ –æ—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–µ.", logger=LOGGER)
        return

    wishlist_category = humanize_wishlist_category(wish.get("category"))
    price = float(wish.get("price", 0) or 0.0)
    LOGGER.info(
        "USER=%s ACTION=WISHLIST_PURCHASE META=item_id=%s price=%.2f",
        callback.from_user.id,
        wish_id,
        price,
    )
    debit_category = db.get_wishlist_debit_category(callback.from_user.id)

    if debit_category is not None:
        income_category = db.get_income_category_by_code(callback.from_user.id, debit_category)
        if not income_category:
            await safe_callback_answer(
                "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–ø–∏—Å–∞—Ç—å: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞/—É–¥–∞–ª–µ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–ø–∏—Å–∞–Ω–∏—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Wishlist.",
                show_alert=True,
                logger=LOGGER,
            )
            return

    result = db.purchase_wish(callback.from_user.id, wish_id, debit_category)
    status = result.get("status")
    if status == "not_found":
        await safe_callback_answer(callback, "–ñ–µ–ª–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True, logger=LOGGER)
        return
    if status == "already":
        await safe_callback_answer(callback, "–£–∂–µ –æ—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–µ.", logger=LOGGER)
        return
    if status == "insufficient":
        await safe_callback_answer(
            (
                "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –≤ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è—Ö –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.\n"
                f"–ù—É–∂–Ω–æ: {price:.2f}, –¥–æ—Å—Ç—É–ø–Ω–æ: {float(result.get('available', 0.0)):.2f}."
            ),
            show_alert=True,
            logger=LOGGER,
        )
        return
    if status == "error":
        await safe_callback_answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–ø–∏—Å–∞—Ç—å: –æ—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.",
            show_alert=True,
            logger=LOGGER,
        )
        return

    if callback.message:
        await safe_edit_message_text(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            text=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é, —Ç—ã –∫—É–ø–∏–ª {wish['name']} –∑–∞ {price:.2f}!",
            logger=LOGGER,
        )
    if status == "debited":
        LOGGER.info(
            "USER=%s ACTION=WISHLIST_DEBIT META=category=%s amount=%.2f item_id=%s",
            callback.from_user.id,
            debit_category,
            price,
            wish_id,
        )
        savings = db.get_user_savings(callback.from_user.id)
        categories_map = db.get_income_categories_map(callback.from_user.id)
        summary = _format_savings_summary(savings, categories_map)
        if callback.message:
            await safe_answer(
                callback.message, f"–û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}", logger=LOGGER
            )
            await show_affordable_wishes(
                message=callback.message, user_id=callback.from_user.id, db=db
            )


@router.callback_query(F.data == "affordable_wishes_later")
async def handle_affordable_wishes_later(callback: CallbackQuery, state: FSMContext) -> None:
    """Close affordable wish suggestions and return to main menu."""

    await safe_callback_answer(callback, logger=LOGGER)
    await state.clear()
    if callback.message:
        try:
            await callback.message.edit_reply_markup(reply_markup=None)
        except Exception:
            LOGGER.debug("Failed to clear inline keyboard for affordable wishes", exc_info=True)
        sent_id = await safe_answer(
            callback.message,
            "–•–æ—Ä–æ—à–æ, –≤–µ—Ä–Ω—ë–º—Å—è –∫ –ø–æ–∫—É–ø–∫–∞–º –ø–æ–∑–∂–µ. –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=await build_main_menu_for_user(callback.from_user.id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, callback.message.chat.id, sent_id)

===== Bot/handlers/common.py =====


"""Common handlers and fallbacks."""
import logging

from aiogram import Router
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ReplyKeyboardMarkup

from Bot.config import settings
from Bot.database.get_db import get_db
from Bot.keyboards.main import main_menu_keyboard
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def build_main_menu_for_user(user_id: int) -> ReplyKeyboardMarkup:
    """Construct main menu keyboard with optional household button."""

    db = get_db()
    from Bot.handlers.household_payments import reset_household_cycle_if_needed

    await reset_household_cycle_if_needed(user_id, db)
    month = current_month_str()
    show_household = await db.should_show_household_payments_button(user_id, month)
    show_test_button = user_id == settings.ADMIN_ID
    return main_menu_keyboard(
        show_household=show_household,
        show_test_button=show_test_button,
        show_settings=True,
    )


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Compatibility no-op; welcome messages are kept."""

    return None


@router.message()
async def fallback_handler(message: Message, state: FSMContext) -> None:
    """Handle unmatched messages."""

    await delete_welcome_message_if_exists(message, state)
    current_state = await state.get_state()
    LOGGER.debug("Fallback triggered. User: %s State: %s Text: %s", message.from_user.id, current_state, message.text)
    sent = await message.answer(
        "–ù–µ –ø–æ–Ω—è–ª —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ª—å–∑—É–π—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –∏–ª–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

===== Bot/handlers/finances.py =====


"""Handlers for income calculation and savings."""
import logging
from typing import Any, Dict, List, Optional

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, Message

from Bot.database.crud import FinanceDatabase
from Bot.database.get_db import get_db
from Bot.keyboards.main import (
    back_to_main_keyboard,
    purchase_confirmation_keyboard,
    yes_no_inline_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.handlers.common import build_main_menu_for_user
from Bot.states.money_states import MoneyState
from Bot.handlers.wishlist import humanize_wishlist_category
from Bot.utils.savings import find_reached_goal, format_savings_summary
from Bot.utils.telegram_safe import safe_delete_message, safe_edit_message_text
from Bot.utils.ui_cleanup import ui_register_message

LOGGER = logging.getLogger(__name__)

router = Router()


def _message_user_id(message: Message) -> int:
    """Extract user id from message."""

    return message.from_user.id if message.from_user else message.chat.id


def _callback_user_id(callback: CallbackQuery) -> int:
    """Extract user id from callback."""

    if callback.from_user:
        return callback.from_user.id
    return callback.message.chat.id


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

INCOME_DIGITS = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}
INCOME_INPUT_BUTTONS = INCOME_DIGITS | {"–û—á–∏—Å—Ç–∏—Ç—å"}


def _build_allocations(categories: List[Dict[str, Any]], amount: float) -> List[Dict[str, Any]]:
    """Build allocation list from income categories."""

    allocations: List[Dict[str, Any]] = []
    for category in categories:
        percent = float(category.get("percent", 0))
        allocated = amount * percent / 100
        allocations.append(
            {
                "label": category.get("title", ""),
                "category": category.get("code", ""),
                "amount": allocated,
            }
        )
    return allocations


def _build_income_prompt(income_sum: str) -> str:
    """Build income input prompt."""

    # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å—É–º–º—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ ": <—á–∏—Å–ª–æ>"
    return f": {income_sum}"


async def _refresh_income_message(
    message: Message, income_message_id: Optional[int], income_sum: str
) -> int:
    """Update or create income prompt message with current sum.

    –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –ø–æ —Å—É–º–º–µ.
    –ï—Å–ª–∏ id –Ω–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫) ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ.
    –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ,
    —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–∏–¥–µ–ª –∞–∫—Ç—É–∞–ª—å–Ω—É—é —Å—É–º–º—É.
    """

    text = _build_income_prompt(income_sum)

    # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –µ—â—ë –Ω–µ –±—ã–ª–æ ‚Äî —Å–æ–∑–¥–∞—ë–º –µ–≥–æ
    if income_message_id is None:
        new_message = await message.answer(text)
        return new_message.message_id

    edited = await safe_edit_message_text(
        message.bot,
        chat_id=message.chat.id,
        message_id=income_message_id,
        text=text,
        logger=LOGGER,
    )
    if edited:
        return income_message_id

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=income_message_id,
        logger=LOGGER,
    )

    new_message = await message.answer(text)
    return new_message.message_id


def _to_float(value: Any) -> float:
    """Safely convert value to float."""

    try:
        return float(value) if value is not None else 0.0
    except (TypeError, ValueError):
        return 0.0


def _format_savings_summary(
    savings: Dict[str, Dict[str, Any]],
    categories_map: Dict[str, str] | None = None,
) -> str:
    """Format savings summary for user message."""

    return format_savings_summary(savings, categories_map)


def _find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> tuple[str, Dict[str, Any]] | tuple[None, None]:
    """Find category where goal is reached."""

    return find_reached_goal(savings)


async def _ask_allocation_confirmation(
    message: Message, state: FSMContext, allocation: Dict[str, Any]
) -> None:
    """Ask user to confirm allocation for a specific category.

    Args:
        message: Aiogram message object used for sending prompts.
        allocation: Allocation details with label and amount.
    """

    text = (
        f"–ù–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—é {allocation['label']} –º–æ–∂–Ω–æ –Ω–∞–ø—Ä–∞–≤–∏—Ç—å "
        f"{allocation['amount']:.2f}. –ü–µ—Ä–µ–≤–µ—Å—Ç–∏?"
    )
    data = await state.get_data()
    existing_id: Optional[int] = data.get("allocation_question_message_id")
    if existing_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=message.chat.id,
            message_id=existing_id,
            text=text,
            reply_markup=yes_no_inline_keyboard(),
            logger=LOGGER,
        )
        if edited:
            return

    sent = await message.answer(text, reply_markup=yes_no_inline_keyboard())
    await state.update_data(allocation_question_message_id=sent.message_id)


@router.message(F.text == "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")
async def start_income_flow(message: Message, state: FSMContext) -> None:
    """Start income calculation workflow with calculator keyboard."""

    await delete_welcome_message_if_exists(message, state)
    await state.clear()
    user_id = message.from_user.id
    categories = get_db().list_active_income_categories(user_id)
    if not categories:
        sent = await message.answer(
            '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–æ—Ö–æ–¥–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã. –û—Ç–∫—Ä–æ–π "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –î–æ—Ö–æ–¥" –∏ –¥–æ–±–∞–≤—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–∞—Ç–µ–≥–æ—Ä–∏—é.',
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        try:
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
        except Exception:  # noqa: BLE001
            LOGGER.warning("Failed to delete user command message", exc_info=True)
        LOGGER.info("USER=%s ACTION=INCOME_START_NO_CATEGORIES", user_id)
        return
    await state.set_state(MoneyState.waiting_for_amount)

    income_sum = "0"
    question = await message.answer(
        "–í–≤–µ–¥–∏ —Å—É–º–º—É –¥–æ—Ö–æ–¥–∞ (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = _build_income_prompt(income_sum)
    income_message = await message.answer(prompt)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ message_id –∏ —Ç–µ–∫—É—â—É—é —Å—É–º–º—É
    await state.update_data(
        income_sum=income_sum,
        income_question_message_id=question.message_id,
        income_message_id=income_message.message_id,
    )

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥"
    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:  # noqa: BLE001
        LOGGER.warning("Failed to delete user command message", exc_info=True)

    LOGGER.info(
        "User %s started income calculation",
        message.from_user.id if message.from_user else "unknown",
    )


async def _process_income_amount_value(
    message: Message,
    state: FSMContext,
    amount: float,
) -> None:
    """Validate amount and start category confirmation workflow."""

    # –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Å—É–º–º—ã
    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–µ –±–æ–ª—å—à–µ 10 000 000. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
        return

    # –£–¥–∞–ª—è–µ–º —Å–ª—É–∂–µ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Å—É–º–º–æ–π –∏ –≤–æ–ø—Ä–æ—Å —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
    data = await state.get_data()
    income_question_message_id: Optional[int] = data.get("income_question_message_id")
    income_message_id: Optional[int] = data.get("income_message_id")

    if income_question_message_id:
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=income_question_message_id,
            logger=LOGGER,
        )

    if income_message_id:
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=income_message_id,
            logger=LOGGER,
        )

    db = get_db()
    categories = db.list_active_income_categories(message.from_user.id)
    total_percent = db.sum_income_category_percents(message.from_user.id)
    if total_percent != 100:
        sent = await message.answer(
            f"–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å 100%. –°–µ–π—á–∞—Å: {total_percent}%. –ò—Å–ø—Ä–∞–≤—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–µ—Ä–µ–∑ ‚öôÔ∏è ‚Üí üìä –î–æ—Ö–æ–¥.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    allocations: List[Dict[str, Any]] = _build_allocations(categories, amount)

    if not allocations:
        sent = await message.answer(
            "–ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ FSM
    await state.update_data(
        income_amount=amount,
        allocations=allocations,
        index=0,
        life_message_id=None,
    )

    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    await state.set_state(MoneyState.confirm_category)

    # –ó–∞–¥–∞—ë–º –≤–æ–ø—Ä–æ—Å –¢–û–õ–¨–ö–û –ø–æ –ø–µ—Ä–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    current = allocations[0]
    await _ask_allocation_confirmation(
        message=message,
        state=state,
        allocation=current,
    )

    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:
        pass


@router.message(
    MoneyState.waiting_for_amount,
    F.text.in_(INCOME_INPUT_BUTTONS),
)
async def handle_income_digit(message: Message, state: FSMContext) -> None:
    """Handle digit and clear input for income calculator."""

    data = await state.get_data()
    current_sum = str(data.get("income_sum", "0"))
    sum_message_id = data.get("income_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    income_message_id = await _refresh_income_message(
        message=message,
        income_message_id=sum_message_id,
        income_sum=new_sum,
    )

    await state.update_data(income_sum=new_sum, income_message_id=income_message_id)

    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:
        pass


@router.message(MoneyState.waiting_for_amount, F.text == "‚úÖ –ì–∞–∑")
async def handle_income_confirm(message: Message, state: FSMContext) -> None:
    """Handle confirmation of income input via calculator button."""

    data = await state.get_data()
    amount_str = str(data.get("income_sum", "0")).strip()

    if not amount_str:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–±–µ—Ä–∏ —Å—É–º–º—É —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫.")
        try:
            await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
        except Exception:
            pass
        return

    normalized = amount_str.replace(",", ".")
    try:
        amount = float(normalized)
    except ValueError:
        await message.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        try:
            await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
        except Exception:
            pass
        return

    if amount <= 0 or amount > 10_000_000:
        await message.answer(
            "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–µ –±–æ–ª—å—à–µ 10 000 000. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
        try:
            await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
        except Exception:
            pass
        return

    await _process_income_amount_value(
        message=message,
        state=state,
        amount=amount,
    )

    try:
        await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    except Exception:
        pass


@router.callback_query(MoneyState.confirm_category, F.data.in_({"confirm_yes", "confirm_no"}))
async def handle_category_confirmation(query: CallbackQuery, state: FSMContext) -> None:
    """Handle user confirmation for category allocation via inline buttons."""

    await query.answer()

    data = await state.get_data()
    allocations: List[Dict[str, Any]] = data.get("allocations", [])
    index: int = int(data.get("index", 0))
    # –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ—Ç –∏–ª–∏ –∏–Ω–¥–µ–∫—Å –≤—ã—à–µ–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã ‚Äî –≤—ã—Ö–æ–¥–∏–º –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    if not allocations or index >= len(allocations):
        sent = await query.message.answer(
            "–ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.",
            reply_markup=await build_main_menu_for_user(_callback_user_id(query)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await state.clear()
        return

    current = allocations[index]

    # --- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª "–î–∞" ---
    if query.data == "confirm_yes":
        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
        get_db().update_saving(
            user_id=query.from_user.id if query.from_user else None,
            category=current["category"],
            amount_delta=current["amount"],
        )

        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        index += 1

    # --- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª "–ù–µ—Ç" ---
    else:
        await query.answer("–¢—ã —á—Ç–æ –ø—Ä–æ –∂–∏–∑–Ω—å –∑–∞–±—ã–ª?", show_alert=True)

    # –ï—Å–ª–∏ –µ—â—ë –µ—Å—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Äî –∑–∞–¥–∞—ë–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
    if index < len(allocations):
        await state.update_data(
            index=index,
        )
        next_allocation = allocations[index]
        await _ask_allocation_confirmation(
            message=query.message,
            state=state,
            allocation=next_allocation,
        )
    else:
        try:
            await query.message.edit_reply_markup(reply_markup=None)
        except Exception:
            pass
        await _send_summary_and_goal_prompt(
            message=query.message,
            state=state,
            user_id=query.from_user.id if query.from_user else None,
        )


async def _send_summary_and_goal_prompt(
    message: Message,
    state: FSMContext,
    user_id: Optional[int],
) -> None:
    """Send savings summary and suggest purchase if goal reached."""

    # –î–æ—Å—Ç–∞—ë–º —Å—É–º–º—É, –∫–æ—Ç–æ—Ä—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª –∫–∞–∫ –¥–æ—Ö–æ–¥
    data = await state.get_data()
    income_amount = data.get("income_amount", 0)

    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º user_id, –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–ª–∏ —è–≤–Ω–æ
    if user_id is None:
        user_id = message.from_user.id if message.from_user else message.chat.id

    await state.clear()
    db = get_db()

    # –ß–∏—Ç–∞–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª—å–Ω–æ–º—É user_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    savings = db.get_user_savings(user_id)
    categories_map = db.get_income_categories_map(user_id)
    summary = _format_savings_summary(savings, categories_map)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç: —Å–Ω–∞—á–∞–ª–∞ "–ü–æ–ª—É—á–µ–Ω–æ –±–∞–±–æ–∫", –∑–∞—Ç–µ–º —Ç–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è
    lines: List[str] = []
    if income_amount:
        lines.append(f"–ü–æ–ª—É—á–µ–Ω–æ –±–∞–±–æ–∫: {income_amount:.2f}")
        lines.append("")  # –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏

    lines.append("–¢–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:")
    lines.append(summary)

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(user_id),
    )
    await ui_register_message(state, sent.chat.id, sent.message_id)

    category, goal_data = _find_reached_goal(savings)
    if category:
        goal = goal_data.get("goal", 0)
        purpose = goal_data.get("purpose", "—Ü–µ–ª—å")
        current = goal_data.get("current", 0)
        await message.answer(
            f"üéØ –¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}. "
            f"–ù–∞ —Ü–µ–ª–∏ {purpose} –Ω–∞–∫–æ–ø–ª–µ–Ω–æ {current:.2f} –∏–∑ {goal:.2f}.",
            reply_markup=purchase_confirmation_keyboard(),
        )
        await state.update_data(category=category, goal=goal)
        await state.set_state(MoneyState.waiting_for_purchase_confirmation)
        return

    # –ü–æ–¥–±–æ—Ä –∂–µ–ª–∞–Ω–∏–π –∏–∑ –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ —Ç–µ–º –∂–µ savings –∏ user_id
    await show_affordable_wishes(
        message=message,
        user_id=user_id,
        db=db,
    )


def _build_affordable_wishes_keyboard(wishes: List[Dict[str, Any]]) -> InlineKeyboardMarkup:
    """Build inline keyboard with purchase buttons for affordable wishes."""

    buttons = [
        [InlineKeyboardButton(text=f"{wish['name']}", callback_data=f"wish_buy_{wish['id']}")]
        for wish in wishes
    ]
    buttons.append([InlineKeyboardButton(text="–ü–æ—Ç–æ–º", callback_data="affordable_wishes_later")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


async def show_affordable_wishes(
    message: Message,
    user_id: int | None = None,
    db: FinanceDatabase | None = None,
) -> None:
    """Show all wishes that are affordable with current savings."""

    if message is None:
        return

    if user_id is None:
        user_id = message.from_user.id if message.from_user else None

    if user_id is None:
        return

    db = db or get_db()
    savings_map = db.get_user_savings_map(user_id)
    wishes = db.get_wishes_by_user(user_id)
    debit_category = db.get_wishlist_debit_category(user_id)
    if not debit_category:
        return
    if not db.get_income_category_by_code(user_id, debit_category):
        return

    affordable: List[Dict[str, Any]] = []
    for wish in wishes:
        if wish.get("is_purchased"):
            continue

        wishlist_category = humanize_wishlist_category(wish.get("category", ""))
        price = _to_float(wish.get("price"))
        available = _to_float(savings_map.get(debit_category))
        if price <= 0 or available < price:
            continue

        wish_copy: Dict[str, Any] = dict(wish)
        wish_copy["price"] = price
        wish_copy["wishlist_category"] = wishlist_category
        affordable.append(wish_copy)

    if not affordable:
        return

    lines = ["–¢—ã —É–∂–µ –º–æ–∂–µ—à—å –∫—É–ø–∏—Ç—å:"]
    for wish in affordable:
        lines.append(
            f"‚Ä¢ {wish['name']} ‚Äî {wish['price']:.2f} ‚ÇΩ (–∫–∞—Ç–µ–≥–æ—Ä–∏—è: {wish['wishlist_category']})"
        )
    lines.append("–ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥ –Ω—É–∂–Ω—ã–º —Ç–æ–≤–∞—Ä–æ–º, –µ—Å–ª–∏ –∫—É–ø–∏–ª.")

    keyboard = _build_affordable_wishes_keyboard(affordable)
    await message.answer("\n".join(lines), reply_markup=keyboard)


async def suggest_available_wish(message: Message) -> None:
    """Backward-compatible wrapper to show affordable wishes."""

    await show_affordable_wishes(message=message, user_id=message.from_user.id if message.from_user else None)


@router.message(MoneyState.waiting_for_purchase_confirmation, F.text.in_({"‚úÖ –ö—É–ø–∏–ª", "üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å"}))
async def handle_goal_purchase(message: Message, state: FSMContext) -> None:
    """Handle decision after reaching savings goal."""

    data = await state.get_data()
    category = data.get("category")
    goal_amount = data.get("goal", 0)
    db = get_db()

    if message.text == "‚úÖ –ö—É–ø–∏–ª" and category:
        db.update_saving(message.from_user.id, category, -goal_amount)
        db.set_goal(message.from_user.id, category, 0, "")
        sent = await message.answer(
            f"–ü–æ–∑–¥—Ä–∞–≤–ª—è—é —Å –ø–æ–∫—É–ø–∫–æ–π –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}! –°—É–º–º–∞ {goal_amount:.2f} —Å–ø–∏—Å–∞–Ω–∞.",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)
        savings = db.get_user_savings(message.from_user.id)
        categories_map = db.get_income_categories_map(message.from_user.id)
        summary = _format_savings_summary(savings, categories_map)
        await message.answer(f"–û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}")
    else:
        sent = await message.answer(
            "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∫–æ–ø–∏—Ç—å!",
            reply_markup=await build_main_menu_for_user(_message_user_id(message)),
        )
        await ui_register_message(state, sent.chat.id, sent.message_id)

    await state.clear()
    LOGGER.info("User %s handled goal decision for category %s", message.from_user.id, category)


@router.message(MoneyState.confirm_category)
async def unexpected_confirmation_input(message: Message) -> None:
    """Handle unexpected text in confirmation state."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –î–∞/–ù–µ—Ç –¥–ª—è –≤—ã–±–æ—Ä–∞.")


@router.message(MoneyState.waiting_for_purchase_confirmation)
async def unexpected_purchase_input(message: Message) -> None:
    """Handle unexpected text in purchase confirmation state."""

    await message.answer("–í—ã–±–µ—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ: –ö—É–ø–∏–ª –∏–ª–∏ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å.")

===== Bot/handlers/household_payments.py =====
"""Handlers for household payments scenario."""
from datetime import datetime, time as dt_time
import logging
import time
from typing import Dict, List

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, ReplyKeyboardRemove

from Bot.config import settings
from Bot.database.get_db import get_db
from Bot.handlers.common import build_main_menu_for_user
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.byt_utils import get_byt_source_category
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.keyboards.settings import (
    household_remove_keyboard,
    household_settings_inline_keyboard,
    settings_menu_keyboard,
)
from Bot.renderers.household import (
    build_household_question_keyboard,
    format_household_items,
    render_household_questions_text,
)
from Bot.services.household import (
    build_answers_from_status,
    build_household_questions,
    filter_unpaid_questions,
    get_current_question,
    get_next_index,
    get_previous_index,
    normalize_processed_steps,
    should_ignore_answer,
    update_flow_state,
)
from Bot.states.money_states import HouseholdPaymentsState, HouseholdSettingsState
from Bot.utils.datetime_utils import current_month_str, now_tz
from Bot.utils.savings import format_savings_summary
from Bot.utils.telegram_safe import (
    safe_answer,
    safe_callback_answer,
    safe_delete_message,
    safe_edit_message_text,
    safe_edit_message_text_with_status,
)
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_register_message,
    ui_register_user_message,
    ui_render_screen,
)

LOGGER = logging.getLogger(__name__)

router = Router(name="household_payments")


def _format_meta(meta: dict) -> str:
    if not meta:
        return "-"
    return " ".join(f"{key}={value}" for key, value in meta.items())


async def _log_state_transition(
    state: FSMContext, user_id: int, to_state: str | None
) -> None:
    from_state = await state.get_state()
    LOGGER.info(
        "USER=%s ACTION=STATE_TRANSITION STATE=%s->%s META=-",
        user_id,
        from_state,
        to_state,
    )


def _log_event(user_id: int, action: str, state: str | None, **meta: str) -> None:
    LOGGER.info(
        "USER=%s ACTION=%s STATE=%s META=%s",
        user_id,
        action,
        state,
        _format_meta(meta),
    )


async def _send_main_menu_summary(
    bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    db = get_db()
    savings = db.get_user_savings(user_id)
    categories_map = db.get_income_categories_map(user_id)
    summary = format_savings_summary(savings, categories_map)
    menu = await build_main_menu_for_user(user_id)
    await ui_render_screen(
        bot,
        state,
        chat_id,
        f"–¢–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}",
        reply_markup=menu,
    )


async def _update_household_question_message(
    bot,
    state: FSMContext,
    chat_id: int,
    ui_message_id: int | None,
    message_context: Message | None,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
) -> tuple[int | None, bool]:
    if ui_message_id:
        edited, network_failed = await safe_edit_message_text_with_status(
            bot,
            chat_id=chat_id,
            message_id=int(ui_message_id),
            text=text,
            reply_markup=reply_markup,
            parse_mode=parse_mode,
            retries=2,
            base_delay=0.4,
            logger=LOGGER,
        )
        if edited:
            return int(ui_message_id), False
        if network_failed:
            return None, True

    if message_context is None:
        return None, False

    sent_id = await safe_answer(
        message_context,
        text,
        reply_markup=reply_markup,
        parse_mode=parse_mode,
        logger=LOGGER,
    )
    if sent_id:
        await ui_register_message(state, chat_id, sent_id)
        await state.update_data(hh_ui_message_id=sent_id)
    return sent_id, False


async def _update_household_question_message_for_callback(
    *,
    callback: CallbackQuery,
    state: FSMContext,
    ui_message_id: int | None,
    text: str,
    reply_markup=None,
    parse_mode: str | None = None,
) -> bool:
    message_context = callback.message
    if message_context is None:
        return False
    _, network_failed = await _update_household_question_message(
        callback.bot,
        state,
        chat_id=message_context.chat.id,
        ui_message_id=ui_message_id,
        message_context=message_context,
        text=text,
        reply_markup=reply_markup,
        parse_mode=parse_mode,
    )
    if network_failed:
        await safe_callback_answer(
            callback,
            "–ü—Ä–æ–±–ª–µ–º–∞ —Å —Å–µ—Ç—å—é, –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑",
            show_alert=False,
            logger=LOGGER,
        )
        return False
    return True


async def reset_household_cycle_if_needed(
    user_id: int, db, now: datetime | None = None
) -> None:
    """Lazily reset household payments cycle after 6th of month at noon."""

    current = now or datetime.now(tz=settings.TIMEZONE)
    month = current_month_str(current)

    threshold = datetime(current.year, current.month, 6, 12, 0, tzinfo=settings.TIMEZONE)
    if current >= threshold:
        await db.init_household_questions_for_month(user_id, month)


def _format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    return format_household_items(items, unpaid_set)


async def _send_household_settings_overview(
    message: Message, db, user_id: int
) -> None:
    items = db.list_active_household_items(user_id)
    month = current_month_str()
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    unpaid_set: set[str] = set(unpaid_codes)
    _log_event(
        user_id,
        "HOUSEHOLD_SETTINGS_OVERVIEW",
        None,
        month=month,
        items_count=str(len(items)),
        unpaid_count=str(len(unpaid_set)),
    )
    if not items:
        _log_event(
            user_id,
            "HOUSEHOLD_SETTINGS_EMPTY",
            None,
            source="list_active_household_items",
        )
    await safe_answer(
        message,
        _format_household_items(items, unpaid_set),
        reply_markup=household_settings_inline_keyboard(),
        logger=LOGGER,
    )


@router.message(F.text == "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")
async def open_household_settings(message: Message, state: FSMContext) -> None:
    """Open household payments settings menu."""

    await ui_register_user_message(state, message.chat.id, message.message_id)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    if message.from_user.id != settings.ADMIN_ID:
        sent_id = await safe_answer(
            message,
            "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –í–µ—Ä–Ω—ë–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=await build_main_menu_for_user(message.from_user.id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, message.chat.id, sent_id)
        return

    await state.clear()
    db = get_db()
    sent_id = await safe_answer(
        message,
        "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è",
        reply_markup=settings_menu_keyboard(),
        logger=LOGGER,
    )
    if sent_id:
        await ui_register_message(state, message.chat.id, sent_id)
    await _send_household_settings_overview(message, db, message.from_user.id)


@router.callback_query(F.data == "hh_set:add")
async def household_add_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Prompt for new household payment title."""

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    await state.set_state(HouseholdSettingsState.waiting_for_title)
    if callback.message:
        await safe_answer(callback.message, "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞", logger=LOGGER)


@router.message(HouseholdSettingsState.waiting_for_title)
async def household_add_set_title(message: Message, state: FSMContext) -> None:
    """Handle title input for new household payment."""

    title = (message.text or "").strip()
    if not title:
        await safe_answer(message, "–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞.", logger=LOGGER)
        return

    await state.update_data(title=title)
    await state.set_state(HouseholdSettingsState.waiting_for_amount)

    question_id = await safe_answer(
        message,
        "–í–≤–µ–¥–∏ —Å—É–º–º—É (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
        logger=LOGGER,
    )
    prompt_id = await safe_answer(message, ": 0", logger=LOGGER)

    await state.update_data(
        amount_sum="0",
        amount_message_id=prompt_id,
        amount_question_message_id=question_id,
    )


@router.message(
    HouseholdSettingsState.waiting_for_amount,
    F.text.in_({"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "–û—á–∏—Å—Ç–∏—Ç—å", "‚úÖ –ì–∞–∑"}),
)
async def household_add_amount_calc(message: Message, state: FSMContext) -> None:
    """Handle calculator input for new household payment amount."""

    data = await state.get_data()
    current_sum = str(data.get("amount_sum", "0"))
    amount_message_id = data.get("amount_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            await safe_answer(message, "–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", logger=LOGGER)
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        try:
            amount = int(amount_str)
        except (TypeError, ValueError):
            await safe_answer(message, "–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", logger=LOGGER)
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        if amount <= 0:
            await safe_answer(
                message, "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", logger=LOGGER
            )
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        user_id = message.from_user.id
        db = get_db()
        position = db.get_next_household_position(user_id)
        title = str(data.get("title", "")).strip() or "–ü–ª–∞—Ç—ë–∂"
        code = f"custom_{time.time_ns()}"
        text = f"{title} {amount}—Ä?"
        db.add_household_payment_item(user_id, code, text, amount, position)
        await reset_household_cycle_if_needed(user_id, db)
        await state.clear()
        await safe_answer(
            message,
            "–ü–ª–∞—Ç—ë–∂ –¥–æ–±–∞–≤–ª–µ–Ω.",
            reply_markup=ReplyKeyboardRemove(),
            logger=LOGGER,
        )
        await safe_answer(
            message,
            "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è",
            reply_markup=settings_menu_keyboard(),
            logger=LOGGER,
        )
        await _send_household_settings_overview(message, db, user_id)
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if amount_message_id:
        await safe_edit_message_text(
            message.bot,
            chat_id=message.chat.id,
            message_id=amount_message_id,
            text=f": {new_sum}",
            logger=LOGGER,
        )

    await state.update_data(amount_sum=new_sum, amount_message_id=amount_message_id)

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.callback_query(F.data == "hh_set:del")
async def household_remove_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Show list of household payments for removal."""

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    db = get_db()
    db.ensure_household_items_seeded(callback.from_user.id)
    items = db.list_active_household_items(callback.from_user.id)
    if not items:
        if callback.message:
            await safe_answer(callback.message, "–°–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π –ø—É—Å—Ç.", logger=LOGGER)
        return

    if callback.message:
        await safe_answer(
            callback.message,
            "–í—ã–±–µ—Ä–∏ –ø–ª–∞—Ç–µ–∂ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
            reply_markup=household_remove_keyboard(items),
            logger=LOGGER,
        )


@router.callback_query(F.data.startswith("hh_set:remove:"))
async def household_remove_item(callback: CallbackQuery, state: FSMContext) -> None:
    """Deactivate selected household payment item."""

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.from_user.id != settings.ADMIN_ID:
        return

    parts = callback.data.split(":") if callback.data else []
    if len(parts) != 3:
        return
    code = parts[2]
    db = get_db()
    db.deactivate_household_payment_item(callback.from_user.id, code)
    await reset_household_cycle_if_needed(callback.from_user.id, db)
    await _send_household_settings_overview(callback.message, db, callback.from_user.id)


@router.message(F.text == "–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")
async def start_household_payments(message: Message, state: FSMContext) -> None:
    """Start household payments flow."""

    await ui_register_user_message(state, message.chat.id, message.message_id)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )

    user_id = message.from_user.id
    db = get_db()

    await reset_household_cycle_if_needed(user_id, db)
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)
    if not items:
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await ui_render_screen(
            message.bot,
            state,
            message.chat.id,
            "–°–ø–∏—Å–æ–∫ –±—ã—Ç–æ–≤—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        return

    month = current_month_str()
    await db.init_household_questions_for_month(user_id, month)
    status_map = await db.get_household_payment_status_map(user_id, month)
    questions = build_household_questions(items)
    answers = build_answers_from_status(status_map)
    all_paid = all(status_map.get(str(question.get("code", "")), 0) == 1 for question in questions)
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    hh_questions = filter_unpaid_questions(questions, unpaid_codes)

    if all_paid or not hh_questions:
        text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        lines = text.splitlines()
        if lines:
            lines[0] = f"‚úÖ –í—Å–µ –±—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ –æ–ø–ª–∞—á–µ–Ω—ã –∑–∞ {month}"
        text = "\n".join(lines)
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await ui_render_screen(
            message.bot,
            state,
            message.chat.id,
            text,
            reply_markup=await build_main_menu_for_user(user_id),
            parse_mode="HTML",
        )
        _log_event(
            user_id,
            "HOUSEHOLD_ALL_PAID",
            None,
            month=month,
        )
        return

    await _log_state_transition(state, user_id, HouseholdPaymentsState.waiting_for_answer.state)
    await state.set_state(HouseholdPaymentsState.waiting_for_answer)
    flow_state = update_flow_state(
        month=month,
        questions=hh_questions,
        current_step_index=0,
        answers=answers,
        processed_steps=[],
    )
    await state.update_data(
        hh_month=month,
        hh_questions=hh_questions,
        hh_index=0,
        hh_answers=answers,
        hh_ui_message_id=0,
        current_step_index=flow_state.current_step_index,
        current_question_code=flow_state.current_question_code,
        processed_steps=[],
    )
    text = render_household_questions_text(
        month, hh_questions, answers, current_index=0
    )
    sent_id = await safe_answer(
        message,
        text,
        reply_markup=build_household_question_keyboard(
            flow_state.current_question_code, show_back=False
        ),
        parse_mode="HTML",
        logger=LOGGER,
    )
    if sent_id:
        await state.update_data(hh_ui_message_id=sent_id)
        await ui_register_message(state, message.chat.id, sent_id)
    _log_event(
        user_id,
        "HOUSEHOLD_START",
        await state.get_state(),
        month=month,
    )


@router.message(F.text == "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")
async def trigger_household_notifications(message: Message, state: FSMContext) -> None:
    """Trigger BYT purchases check (household wishlist) as if timer fired."""

    user_id = message.from_user.id
    db = get_db()

    db.ensure_byt_timer_defaults(user_id)
    data = await state.get_data()
    last_ts = data.get("byt_manual_check_ts")
    current_ts = time.time()
    if last_ts is not None and current_ts - float(last_ts) < 2:
        sent_id = await safe_answer(
            message,
            "–£–∂–µ –ø—Ä–æ–≤–µ—Ä–∏–ª. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ —á–µ—Ä–µ–∑ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥.",
            reply_markup=await build_main_menu_for_user(user_id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, message.chat.id, sent_id)
        return
    await state.update_data(byt_manual_check_ts=current_ts)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )

    source_category_id, source_category_title = get_byt_source_category(db, user_id)
    if not source_category_title:
        LOGGER.info(
            "USER=%s ACTION=BYT_MANUAL_CHECK META=source_category_id=None total=0 due=0 deferred=0",
            user_id,
        )
        sent_id = await safe_answer(
            message,
            "–ö–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –Ω–µ –≤—ã–±—Ä–∞–Ω–∞. –û—Ç–∫—Ä–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ‚Üí "
            "–í—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.",
            reply_markup=await build_main_menu_for_user(user_id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, message.chat.id, sent_id)
        return

    times = db.list_active_byt_timer_times(user_id)
    simulated_time = None
    if times:
        first_time = times[0]
        try:
            simulated_time = dt_time(
                hour=int(first_time.get("hour", 0)),
                minute=int(first_time.get("minute", 0)),
            )
        except Exception:
            simulated_time = None

    now_dt = now_tz()
    total_items = db.get_active_byt_wishes(user_id, source_category_title)
    due_items = db.list_active_byt_items_for_reminder(
        user_id, now_dt, source_category_title
    )
    due_ids = {int(item.get("id")) for item in due_items if item.get("id") is not None}
    deferred_items = [
        item
        for item in total_items
        if item.get("id") is not None and int(item.get("id")) not in due_ids
    ]
    nearest_deferred = None
    for item in deferred_items:
        deferred_until = item.get("deferred_until")
        if not deferred_until:
            continue
        try:
            deferred_dt = datetime.fromisoformat(str(deferred_until))
        except ValueError:
            continue
        if nearest_deferred is None or deferred_dt < nearest_deferred:
            nearest_deferred = deferred_dt
    LOGGER.info(
        "USER=%s ACTION=BYT_MANUAL_CHECK META=source_category_id=%s total=%s due=%s deferred=%s",
        user_id,
        source_category_id,
        len(total_items),
        len(due_items),
        len(deferred_items),
    )
    if not due_items:
        text = f"–í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {source_category_title} –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π."
        if deferred_items:
            if nearest_deferred:
                nearest_label = nearest_deferred.strftime("%d.%m.%Y %H:%M")
                text = (
                    f"{text}\n–ï—Å—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏: {len(deferred_items)} —à—Ç. "
                    f"(–±–ª–∏–∂–∞–π—à–∞—è ‚Äî {nearest_label})"
                )
            else:
                text = (
                    f"{text}\n–ï—Å—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏: {len(deferred_items)} —à—Ç."
                )
        sent_id = await safe_answer(
            message,
            text,
            reply_markup=await build_main_menu_for_user(user_id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, message.chat.id, sent_id)
        return

    await run_byt_timer_check(
        message.bot, db, user_id=user_id, simulated_time=simulated_time
    )


@router.callback_query(
    HouseholdPaymentsState.waiting_for_answer,
    F.data.startswith("hh_pay:"),
)
async def handle_household_answer(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle Yes/No/Back answers for household questions."""

    data = await state.get_data()
    month = data.get("hh_month")
    questions = list(data.get("hh_questions") or [])
    index = int(data.get("current_step_index") or data.get("hh_index") or 0)
    answers = dict(data.get("hh_answers") or {})
    ui_message_id = data.get("hh_ui_message_id")
    processed_steps = normalize_processed_steps(data.get("processed_steps"))
    user_id = callback.from_user.id

    if callback.message is None or callback.message.message_id != ui_message_id:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    callback_parts = callback.data.split(":") if callback.data else []
    if len(callback_parts) < 2:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return
    action = callback_parts[1]
    callback_code = callback_parts[2] if len(callback_parts) > 2 else None

    if action == "back" and index == 0:
        await safe_callback_answer(
            callback, "–ù–∞–∑–∞–¥ –Ω–µ–ª—å–∑—è ‚Äî —ç—Ç–æ –ø–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å", show_alert=True, logger=LOGGER
        )
        return

    await safe_callback_answer(callback, logger=LOGGER)

    if not month or not questions:
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    current_question = get_current_question(questions, index)
    current_code = str(current_question.get("code")) if current_question else None
    target_code = callback_code or current_code

    if action == "back":
        index = get_previous_index(index)
        current_question = get_current_question(questions, index)
        current_code = str(current_question.get("code")) if current_question else None
        await state.update_data(
            hh_index=index,
            current_step_index=index,
            current_question_code=current_code,
        )
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        updated = await _update_household_question_message_for_callback(
            callback=callback,
            state=state,
            ui_message_id=ui_message_id,
            text=text,
            reply_markup=build_household_question_keyboard(
                current_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        if not updated:
            return
        _log_event(
            user_id,
            "HOUSEHOLD_BACK",
            await state.get_state(),
            month=str(month),
            index=str(index),
            question_code=str(current_code),
        )
        return

    if index >= len(questions):
        final_text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        updated = await _update_household_question_message_for_callback(
            callback=callback,
            state=state,
            ui_message_id=ui_message_id,
            text=final_text,
            reply_markup=None,
            parse_mode="HTML",
        )
        if not updated:
            return
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    if target_code and target_code != current_code:
        if target_code in processed_steps:
            await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
            return
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    question = current_question
    if not question:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    code = str(question.get("code", ""))
    amount = question.get("amount")
    amount_value = float(amount) if amount is not None else 0.0
    db = get_db()

    if action not in {"yes", "no"}:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    if code in processed_steps:
        await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
        return

    if should_ignore_answer(answers, processed_steps, code, action):
        await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
        return

    debit_category, _ = db.resolve_household_debit_category(user_id)
    changed = db.apply_household_payment_answer(
        user_id=user_id,
        month=str(month),
        question_code=code,
        amount=amount_value if amount is not None else None,
        answer=action,
        debit_category=debit_category,
    )
    if not changed and action == "yes":
        await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
        return
    answers[code] = "yes" if action == "yes" else "no"
    processed_steps.add(code)

    _log_event(
        user_id,
        "HOUSEHOLD_ANSWER",
        await state.get_state(),
        month=str(month),
        question_code=code,
        answer=action,
    )
    if action == "yes" and amount is not None:
        _log_event(
            user_id,
            "HOUSEHOLD_DEBIT",
            await state.get_state(),
            debit_category=debit_category,
        )

    index = get_next_index(index, questions)
    next_question = get_current_question(questions, index)
    next_code = str(next_question.get("code")) if next_question else None
    await state.update_data(
        hh_answers=answers,
        hh_index=index,
        current_step_index=index,
        current_question_code=next_code,
        processed_steps=list(processed_steps),
    )
    if index < len(questions):
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        updated = await _update_household_question_message_for_callback(
            callback=callback,
            state=state,
            ui_message_id=ui_message_id,
            text=text,
            reply_markup=build_household_question_keyboard(
                next_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        if not updated:
            return
        return

    final_text = render_household_questions_text(
        month, questions, answers, current_index=None
    )
    updated = await _update_household_question_message_for_callback(
        callback=callback,
        state=state,
        ui_message_id=ui_message_id,
        text=final_text,
        reply_markup=None,
        parse_mode="HTML",
    )
    if not updated:
        return
    await ui_cleanup_messages(callback.bot, state)
    await _log_state_transition(state, user_id, None)
    await state.clear()
    await _send_main_menu_summary(callback.bot, state, callback.message.chat.id, user_id)


