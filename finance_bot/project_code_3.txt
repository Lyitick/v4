                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        if amount <= 0:
            await safe_answer(
                message, "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", logger=LOGGER
            )
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        user_id = message.from_user.id
        db = get_db()
        position = db.get_next_household_position(user_id)
        title = str(data.get("title", "")).strip() or "–ü–ª–∞—Ç—ë–∂"
        code = f"custom_{time.time_ns()}"
        text = f"{title} {amount}—Ä?"
        db.add_household_payment_item(user_id, code, text, amount, position)
        await reset_household_cycle_if_needed(user_id, db)
        await state.clear()
        await safe_answer(
            message,
            "–ü–ª–∞—Ç—ë–∂ –¥–æ–±–∞–≤–ª–µ–Ω.",
            reply_markup=ReplyKeyboardRemove(),
            logger=LOGGER,
        )
        await safe_answer(
            message,
            "‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è",
            reply_markup=settings_menu_keyboard(),
            logger=LOGGER,
        )
        await _send_household_settings_overview(message, db, user_id)
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if amount_message_id:
        await safe_edit_message_text(
            message.bot,
            chat_id=message.chat.id,
            message_id=amount_message_id,
            text=f": {new_sum}",
            logger=LOGGER,
        )

    await state.update_data(amount_sum=new_sum, amount_message_id=amount_message_id)

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.callback_query(F.data == "hh_set:del")
async def household_remove_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    """Show list of household payments for removal."""

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.from_user.id != settings.ADMIN_ID:
        return

    await state.clear()
    db = get_db()
    db.ensure_household_items_seeded(callback.from_user.id)
    items = db.list_active_household_items(callback.from_user.id)
    if not items:
        if callback.message:
            await safe_answer(callback.message, "–°–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π –ø—É—Å—Ç.", logger=LOGGER)
        return

    if callback.message:
        await safe_answer(
            callback.message,
            "–í—ã–±–µ—Ä–∏ –ø–ª–∞—Ç–µ–∂ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
            reply_markup=household_remove_keyboard(items),
            logger=LOGGER,
        )


@router.callback_query(F.data.startswith("hh_set:remove:"))
async def household_remove_item(callback: CallbackQuery, state: FSMContext) -> None:
    """Deactivate selected household payment item."""

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.from_user.id != settings.ADMIN_ID:
        return

    parts = callback.data.split(":") if callback.data else []
    if len(parts) != 3:
        return
    code = parts[2]
    db = get_db()
    db.deactivate_household_payment_item(callback.from_user.id, code)
    await reset_household_cycle_if_needed(callback.from_user.id, db)
    await _send_household_settings_overview(callback.message, db, callback.from_user.id)


@router.message(F.text == "–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")
async def start_household_payments(message: Message, state: FSMContext) -> None:
    """Start household payments flow."""

    await ui_register_user_message(state, message.chat.id, message.message_id)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )

    user_id = message.from_user.id
    db = get_db()

    await reset_household_cycle_if_needed(user_id, db)
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)
    if not items:
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await ui_render_screen(
            message.bot,
            state,
            message.chat.id,
            "–°–ø–∏—Å–æ–∫ –±—ã—Ç–æ–≤—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.",
            reply_markup=await build_main_menu_for_user(user_id),
        )
        return

    month = current_month_str()
    await db.init_household_questions_for_month(user_id, month)
    status_map = await db.get_household_payment_status_map(user_id, month)
    questions = build_household_questions(items)
    answers = build_answers_from_status(status_map)
    all_paid = all(status_map.get(str(question.get("code", "")), 0) == 1 for question in questions)
    unpaid_codes = await db.get_unpaid_household_questions(user_id, month)
    hh_questions = filter_unpaid_questions(questions, unpaid_codes)

    if all_paid or not hh_questions:
        text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        lines = text.splitlines()
        if lines:
            lines[0] = f"‚úÖ –í—Å–µ –±—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ –æ–ø–ª–∞—á–µ–Ω—ã –∑–∞ {month}"
        text = "\n".join(lines)
        await ui_cleanup_messages(message.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await ui_render_screen(
            message.bot,
            state,
            message.chat.id,
            text,
            reply_markup=await build_main_menu_for_user(user_id),
            parse_mode="HTML",
        )
        _log_event(
            user_id,
            "HOUSEHOLD_ALL_PAID",
            None,
            month=month,
        )
        return

    await _log_state_transition(state, user_id, HouseholdPaymentsState.waiting_for_answer.state)
    await state.set_state(HouseholdPaymentsState.waiting_for_answer)
    flow_state = update_flow_state(
        month=month,
        questions=hh_questions,
        current_step_index=0,
        answers=answers,
        processed_steps=[],
    )
    await state.update_data(
        hh_month=month,
        hh_questions=hh_questions,
        hh_index=0,
        hh_answers=answers,
        hh_ui_message_id=0,
        current_step_index=flow_state.current_step_index,
        current_question_code=flow_state.current_question_code,
        processed_steps=[],
    )
    text = render_household_questions_text(
        month, hh_questions, answers, current_index=0
    )
    sent_id = await safe_answer(
        message,
        text,
        reply_markup=build_household_question_keyboard(
            flow_state.current_question_code, show_back=False
        ),
        parse_mode="HTML",
        logger=LOGGER,
    )
    if sent_id:
        await state.update_data(hh_ui_message_id=sent_id)
        await ui_register_message(state, message.chat.id, sent_id)
    _log_event(
        user_id,
        "HOUSEHOLD_START",
        await state.get_state(),
        month=month,
    )


@router.message(F.text == "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")
async def trigger_household_notifications(message: Message, state: FSMContext) -> None:
    """Trigger BYT purchases check (household wishlist) as if timer fired."""

    user_id = message.from_user.id
    db = get_db()
    _log_event(user_id, "BYT_MANUAL_CHECK", await state.get_state())

    db.ensure_byt_timer_defaults(user_id)
    data = await state.get_data()
    last_ts = data.get("byt_manual_check_ts")
    current_ts = time.time()
    if last_ts is not None and current_ts - float(last_ts) < 2:
        sent_id = await safe_answer(
            message,
            "–£–∂–µ –ø—Ä–æ–≤–µ—Ä–∏–ª. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ —á–µ—Ä–µ–∑ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥.",
            reply_markup=await build_main_menu_for_user(user_id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, message.chat.id, sent_id)
        return
    await state.update_data(byt_manual_check_ts=current_ts)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )

    times = db.list_active_byt_timer_times(user_id)
    simulated_time = None
    if times:
        first_time = times[0]
        try:
            simulated_time = dt_time(
                hour=int(first_time.get("hour", 0)),
                minute=int(first_time.get("minute", 0)),
            )
        except Exception:
            simulated_time = None

    now_dt = now_tz()
    total_items = db.get_active_byt_wishes(user_id)
    due_items = db.list_active_byt_items_for_reminder(user_id, now_dt)
    due_ids = {int(item.get("id")) for item in due_items if item.get("id") is not None}
    deferred_items = [
        item
        for item in total_items
        if item.get("id") is not None and int(item.get("id")) not in due_ids
    ]
    nearest_deferred = None
    for item in deferred_items:
        deferred_until = item.get("deferred_until")
        if not deferred_until:
            continue
        try:
            deferred_dt = datetime.fromisoformat(str(deferred_until))
        except ValueError:
            continue
        if nearest_deferred is None or deferred_dt < nearest_deferred:
            nearest_deferred = deferred_dt
    _log_event(
        user_id,
        "BYT_MANUAL_CHECK_SUMMARY",
        None,
        total_items=str(len(total_items)),
        due_items=str(len(due_items)),
        deferred_items=str(len(deferred_items)),
        nearest_deferred=nearest_deferred.isoformat() if nearest_deferred else "None",
    )
    if not due_items:
        text = "‚úÖ –°–µ–π—á–∞—Å –ø–æ–∫—É–ø–∞—Ç—å –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ. –°–ø–∏—Å–æ–∫ –ø—É—Å—Ç –∏–ª–∏ –≤—Å—ë –æ—Ç–ª–æ–∂–µ–Ω–æ."
        if deferred_items:
            if nearest_deferred:
                nearest_label = nearest_deferred.strftime("%d.%m.%Y %H:%M")
                text = (
                    f"{text}\n–ï—Å—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏: {len(deferred_items)} —à—Ç. "
                    f"(–±–ª–∏–∂–∞–π—à–∞—è ‚Äî {nearest_label})"
                )
            else:
                text = (
                    f"{text}\n–ï—Å—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏: {len(deferred_items)} —à—Ç."
                )
        sent_id = await safe_answer(
            message,
            text,
            reply_markup=await build_main_menu_for_user(user_id),
            logger=LOGGER,
        )
        if sent_id:
            await ui_register_message(state, message.chat.id, sent_id)
        return

    await run_byt_timer_check(
        message.bot, db, user_id=user_id, simulated_time=simulated_time
    )


@router.callback_query(
    HouseholdPaymentsState.waiting_for_answer,
    F.data.startswith("hh_pay:"),
)
async def handle_household_answer(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle Yes/No/Back answers for household questions."""

    data = await state.get_data()
    month = data.get("hh_month")
    questions = list(data.get("hh_questions") or [])
    index = int(data.get("current_step_index") or data.get("hh_index") or 0)
    answers = dict(data.get("hh_answers") or {})
    ui_message_id = data.get("hh_ui_message_id")
    processed_steps = normalize_processed_steps(data.get("processed_steps"))
    user_id = callback.from_user.id

    if callback.message is None or callback.message.message_id != ui_message_id:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    callback_parts = callback.data.split(":") if callback.data else []
    if len(callback_parts) < 2:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return
    action = callback_parts[1]
    callback_code = callback_parts[2] if len(callback_parts) > 2 else None

    if action == "back" and index == 0:
        await safe_callback_answer(
            callback, "–ù–∞–∑–∞–¥ –Ω–µ–ª—å–∑—è ‚Äî —ç—Ç–æ –ø–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å", show_alert=True, logger=LOGGER
        )
        return

    await safe_callback_answer(callback, logger=LOGGER)

    if not month or not questions:
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    current_question = get_current_question(questions, index)
    current_code = str(current_question.get("code")) if current_question else None
    target_code = callback_code or current_code

    if action == "back":
        index = get_previous_index(index)
        current_question = get_current_question(questions, index)
        current_code = str(current_question.get("code")) if current_question else None
        await state.update_data(
            hh_index=index,
            current_step_index=index,
            current_question_code=current_code,
        )
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        updated = await _update_household_question_message_for_callback(
            callback=callback,
            state=state,
            ui_message_id=ui_message_id,
            text=text,
            reply_markup=build_household_question_keyboard(
                current_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        if not updated:
            return
        _log_event(
            user_id,
            "HOUSEHOLD_BACK",
            await state.get_state(),
            month=str(month),
            index=str(index),
            question_code=str(current_code),
        )
        return

    if index >= len(questions):
        final_text = render_household_questions_text(
            month, questions, answers, current_index=None
        )
        updated = await _update_household_question_message_for_callback(
            callback=callback,
            state=state,
            ui_message_id=ui_message_id,
            text=final_text,
            reply_markup=None,
            parse_mode="HTML",
        )
        if not updated:
            return
        await ui_cleanup_messages(callback.bot, state)
        await _log_state_transition(state, user_id, None)
        await state.clear()
        await _send_main_menu_summary(
            callback.bot, state, callback.message.chat.id, user_id
        )
        return

    if target_code and target_code != current_code:
        if target_code in processed_steps:
            await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
            return
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    question = current_question
    if not question:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    code = str(question.get("code", ""))
    amount = question.get("amount")
    amount_value = float(amount) if amount is not None else 0.0
    db = get_db()

    if action not in {"yes", "no"}:
        await safe_callback_answer(callback, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ", logger=LOGGER)
        return

    if code in processed_steps:
        await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
        return

    if should_ignore_answer(answers, processed_steps, code, action):
        await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
        return

    debit_category, _ = db.resolve_household_debit_category(user_id)
    changed = db.apply_household_payment_answer(
        user_id=user_id,
        month=str(month),
        question_code=code,
        amount=amount_value if amount is not None else None,
        answer=action,
        debit_category=debit_category,
    )
    if not changed and action == "yes":
        await safe_callback_answer(callback, "–£–∂–µ —É—á—Ç–µ–Ω–æ", logger=LOGGER)
        return
    answers[code] = "yes" if action == "yes" else "no"
    processed_steps.add(code)

    _log_event(
        user_id,
        "HOUSEHOLD_ANSWER",
        await state.get_state(),
        month=str(month),
        question_code=code,
        answer=action,
    )
    if action == "yes" and amount is not None:
        _log_event(
            user_id,
            "HOUSEHOLD_DEBIT",
            await state.get_state(),
            debit_category=debit_category,
        )

    index = get_next_index(index, questions)
    next_question = get_current_question(questions, index)
    next_code = str(next_question.get("code")) if next_question else None
    await state.update_data(
        hh_answers=answers,
        hh_index=index,
        current_step_index=index,
        current_question_code=next_code,
        processed_steps=list(processed_steps),
    )
    if index < len(questions):
        text = render_household_questions_text(
            month, questions, answers, current_index=index
        )
        updated = await _update_household_question_message_for_callback(
            callback=callback,
            state=state,
            ui_message_id=ui_message_id,
            text=text,
            reply_markup=build_household_question_keyboard(
                next_code, show_back=index > 0
            ),
            parse_mode="HTML",
        )
        if not updated:
            return
        return

    final_text = render_household_questions_text(
        month, questions, answers, current_index=None
    )
    updated = await _update_household_question_message_for_callback(
        callback=callback,
        state=state,
        ui_message_id=ui_message_id,
        text=final_text,
        reply_markup=None,
        parse_mode="HTML",
    )
    if not updated:
        return
    await ui_cleanup_messages(callback.bot, state)
    await _log_state_transition(state, user_id, None)
    await state.clear()
    await _send_main_menu_summary(callback.bot, state, callback.message.chat.id, user_id)


===== Bot/handlers/settings.py =====

"""Inline settings handlers for a single-page experience."""
import logging
import time

from aiogram import F, Router
from aiogram.filters import BaseFilter
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, ReplyKeyboardMarkup, ReplyKeyboardRemove

from Bot.constants.ui_labels import (
    WISHLIST_DEBIT_CATEGORY_BACK,
    WISHLIST_DEBIT_CATEGORY_BUTTON,
    WISHLIST_DEBIT_CATEGORY_NONE,
)
from Bot.database.get_db import get_db
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import back_only_keyboard
from Bot.keyboards.settings import (
    byt_rules_reply_keyboard,
    byt_timer_reply_keyboard,
    byt_timer_times_select_reply_keyboard,
    household_debit_category_select_reply_keyboard,
    household_payments_remove_reply_keyboard,
    household_settings_reply_keyboard,
    income_categories_select_reply_keyboard,
    income_settings_reply_keyboard,
    settings_back_reply_keyboard,
    settings_home_reply_keyboard,
    wishlist_categories_select_reply_keyboard,
    wishlist_debit_category_select_reply_keyboard,
    wishlist_purchased_mode_reply_keyboard,
    wishlist_settings_reply_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.states.money_states import HouseholdSettingsState, IncomeSettingsState
from Bot.states.wishlist_states import (
    BytSettingsState,
    BytTimerState,
    WishlistSettingsState,
)
from Bot.utils.datetime_utils import current_month_str
from Bot.utils.savings import format_savings_summary
from Bot.utils.telegram_safe import (
    safe_delete_message,
    safe_edit_message_text,
    safe_send_message,
)
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_cleanup_to_context,
    ui_register_message,
    ui_render_screen,
    ui_set_screen_message,
    ui_track_message,
)

router = Router()
LOGGER = logging.getLogger(__name__)
PERCENT_DIGITS = {str(i) for i in range(10)}
PERCENT_INPUT_BUTTONS = PERCENT_DIGITS | {"–û—á–∏—Å—Ç–∏—Ç—å", "‚úÖ –ì–∞–∑"}


class InSettingsFilter(BaseFilter):
    async def __call__(self, message: Message, state: FSMContext) -> bool:
        data = await state.get_data()
        return bool(data.get("in_settings"))


async def _register_user_message(state: FSMContext, message: Message) -> None:
    await ui_track_message(state, message.chat.id, message.message_id)


async def _safe_edit(bot, **kwargs) -> None:
    edited = await safe_edit_message_text(bot, logger=LOGGER, **kwargs)
    if not edited:
        raise TelegramBadRequest(method="editMessageText", message="edit-failed")


async def _delete_message_safely(bot, chat_id: int | None, message_id: int | None) -> None:
    if chat_id is None or message_id is None:
        return
    await safe_delete_message(
        bot,
        chat_id=chat_id,
        message_id=int(message_id),
        logger=LOGGER,
    )


async def _delete_user_message(message: Message) -> None:
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


async def _remove_calculator_keyboard(message: Message) -> None:
    temp = await safe_send_message(
        message.bot,
        chat_id=message.chat.id,
        text=" ",
        reply_markup=ReplyKeyboardRemove(),
        logger=LOGGER,
    )
    if temp:
        await safe_delete_message(
            message.bot,
            chat_id=temp.chat.id,
            message_id=temp.message_id,
            logger=LOGGER,
        )


async def _apply_reply_keyboard(message: Message, reply_markup: ReplyKeyboardMarkup) -> None:
    temp = await safe_send_message(
        message.bot,
        chat_id=message.chat.id,
        text=" ",
        reply_markup=reply_markup,
        logger=LOGGER,
    )
    if temp:
        await safe_delete_message(
            message.bot,
            chat_id=temp.chat.id,
            message_id=temp.message_id,
            logger=LOGGER,
        )


def _parse_time_text(raw: str) -> tuple[int, int] | None:
    value = raw.strip()
    if ":" not in value:
        return None
    parts = value.split(":")
    if len(parts) != 2:
        return None
    try:
        hour = int(parts[0])
        minute = int(parts[1])
    except ValueError:
        return None
    if hour < 0 or hour > 23 or minute < 0 or minute > 59:
        return None
    return hour, minute


async def _cleanup_input_ui(
    bot,
    data: dict,
    *,
    display_chat_key: str | None = None,
    display_message_key: str | None = None,
    prompt_chat_key: str | None = None,
    prompt_message_key: str | None = None,
) -> None:
    if display_chat_key and display_message_key:
        await _delete_message_safely(
            bot, data.get(display_chat_key), data.get(display_message_key)
        )
    if prompt_chat_key and prompt_message_key:
        await _delete_message_safely(
            bot, data.get(prompt_chat_key), data.get(prompt_message_key)
        )


async def _store_settings_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    await state.update_data(
        settings_chat_id=chat_id, settings_message_id=message_id, in_settings=True
    )


async def _set_current_screen(state: FSMContext, screen_id: str) -> None:
    await state.update_data(settings_current_screen=screen_id, in_settings=True)


async def _reset_navigation(state: FSMContext, current_screen: str = "st:home") -> None:
    await state.update_data(settings_nav_stack=[], settings_current_screen=current_screen)


async def _push_current_screen(state: FSMContext, next_screen: str) -> None:
    data = await state.get_data()
    current_screen = data.get("settings_current_screen")
    stack = list(data.get("settings_nav_stack") or [])
    if current_screen and current_screen != next_screen:
        if not stack or stack[-1] != current_screen:
            stack.append(current_screen)
    await state.update_data(settings_nav_stack=stack, settings_current_screen=next_screen)


async def _pop_previous_screen(state: FSMContext) -> str | None:
    data = await state.get_data()
    stack = list(data.get("settings_nav_stack") or [])
    if not stack:
        return None
    previous = stack.pop()
    await state.update_data(settings_nav_stack=stack, settings_current_screen=previous)
    return previous


async def _send_and_register(
    *, message: Message, state: FSMContext, text: str, reply_markup=None
) -> Message:
    sent = await message.answer(text, reply_markup=reply_markup)
    await ui_register_message(state, sent.chat.id, sent.message_id)
    return sent


async def _send_main_menu_summary(
    *, bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    db = get_db()
    savings = db.get_user_savings(user_id)
    categories_map = db.get_income_categories_map(user_id)
    summary = format_savings_summary(savings, categories_map)
    text = f"–¢–µ–∫—É—â–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è:\n{summary}"
    menu = await build_main_menu_for_user(user_id)
    sent = await safe_send_message(bot, chat_id=chat_id, text=text, reply_markup=menu)
    if sent:
        await ui_register_message(state, sent.chat.id, sent.message_id)


async def _exit_settings_to_main(
    *, bot, state: FSMContext, chat_id: int, user_id: int
) -> None:
    await ui_cleanup_messages(bot, state, chat_id=chat_id)
    await state.clear()
    await ui_render_screen(
        bot,
        state,
        chat_id,
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(user_id),
    )


async def _get_settings_message_ids(
    state: FSMContext, fallback_message: Message
) -> tuple[int, int]:
    data = await state.get_data()
    chat_id = data.get("settings_chat_id") or fallback_message.chat.id
    message_id = data.get("settings_message_id") or fallback_message.message_id
    return int(chat_id), int(message_id)


async def _edit_settings_page(
    *,
    bot,
    state: FSMContext,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup,
) -> int:
    try:
        data = await state.get_data()
        if data.get("settings_current_screen") in {"st:income", "st:wishlist", "st:byt_rules"}:
            raise TelegramBadRequest(method="editMessageText", message="reply-only")
        await _safe_edit(
            bot,
            chat_id=chat_id,
            message_id=message_id,
            text=text,
            reply_markup=reply_markup,
        )
        new_message_id = message_id
    except TelegramBadRequest:
        new_message = await safe_send_message(
            bot,
            chat_id=chat_id,
            text=text,
            reply_markup=reply_markup,
            logger=LOGGER,
        )
        new_message_id = new_message.message_id if new_message else message_id
        await ui_register_message(state, chat_id, new_message_id)
    await ui_set_screen_message(state, chat_id, new_message_id)
    await _store_settings_message(state, chat_id, new_message_id)
    return new_message_id


async def _render_reply_settings_page(
    *,
    message: Message,
    state: FSMContext,
    text: str,
    reply_markup: ReplyKeyboardMarkup,
    screen_id: str,
    force_new: bool = False,
) -> None:
    data = await state.get_data()
    chat_id = data.get("settings_chat_id")
    message_id = data.get("settings_message_id")
    current_screen = data.get("settings_current_screen")

    deleted_count = 0
    if force_new or not chat_id or not message_id or current_screen != screen_id:
        await _delete_message_safely(message.bot, chat_id, message_id)
        if message_id:
            deleted_count = 1
    sent = await safe_send_message(
        message.bot,
        chat_id=message.chat.id,
        text=text,
        reply_markup=reply_markup,
    )
    new_message_id = sent.message_id if sent else 0
    if sent:
        await ui_register_message(state, sent.chat.id, sent.message_id)
        await ui_set_screen_message(state, sent.chat.id, sent.message_id)
        await _store_settings_message(state, sent.chat.id, sent.message_id)
    await _set_current_screen(state, screen_id)
    if deleted_count:
        LOGGER.info(
            "Settings reply screen cleanup: deleted %s messages (screen_id=%s)",
            deleted_count,
            screen_id,
        )


async def _render_settings_home(message: Message, state: FSMContext) -> None:
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò",
        reply_markup=settings_home_reply_keyboard(),
        screen_id="st:home",
        force_new=True,
    )


def _format_household_payments_text(
    items: list[dict],
    *,
    unpaid_set: set[str],
    debit_category: str,
    error_message: str | None = None,
) -> str:
    lines: list[str] = [
        "–†–ï–ñ–ò–ú –ù–ê–°–¢–†–û–ï–ö",
        "",
        "–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏",
        f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è: {debit_category}",
        "",
    ]
    if not items:
        lines.append("–ü–ª–∞—Ç–µ–∂–µ–π –ø–æ–∫–∞ –Ω–µ—Ç. –ù–∞–∂–º–∏ ‚ûï –î–æ–±–∞–≤–∏—Ç—å")
    else:
        for item in items:
            title = str(item.get("text", "")).rstrip("?")
            amount = item.get("amount")
            prefix = "‚ùå" if item.get("code") in unpaid_set else "‚úÖ"
            if amount not in (None, 0):
                lines.append(f"{prefix} {title} ‚Äî {amount}")
            else:
                lines.append(f"{prefix} {title}")
    if error_message:
        lines.extend(["", error_message])
    return "\n".join(lines)


async def _render_household_payments_settings(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    error_message: str | None = None,
    force_new_keyboard: bool = False,
) -> None:
    items = db.list_active_household_items(user_id)
    month = current_month_str()
    await db.init_household_questions_for_month(user_id, month)
    unpaid = await db.get_unpaid_household_questions(user_id, month)
    unpaid_set: set[str] = set(unpaid)
    debit_code, debit_title = db.resolve_household_debit_category(user_id)
    LOGGER.info(
        "Open household payments settings (user_id=%s, month=%s, items_count=%s, unpaid_count=%s)",
        user_id,
        month,
        len(items),
        len(unpaid_set),
    )
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_household_payments_text(
            items,
            unpaid_set=unpaid_set,
            debit_category=debit_title or debit_code,
            error_message=error_message,
        ),
        reply_markup=household_settings_reply_keyboard(),
        screen_id="st:household_payments",
        force_new=True,
    )


async def _render_household_delete_menu(
    *, state: FSMContext, message: Message, db, user_id: int
) -> None:
    items = db.list_active_household_items(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="–ß—Ç–æ —É–¥–∞–ª–∏—Ç—å?" if items else "–ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ—Ç.",
        reply_markup=household_payments_remove_reply_keyboard(items)
        if items
        else household_settings_reply_keyboard(),
        screen_id="hp:del_payment_menu",
        force_new=True,
    )
    await state.update_data(
        hp_delete_map={
            (f"{str(item.get('text', ''))}".rstrip("?")
             + (f" ‚Äî {item.get('amount')}" if item.get("amount") is not None else "")
            ): item.get("code")
            for item in items
        }
    )
    if items:
        await state.set_state(HouseholdSettingsState.waiting_for_removal)


async def _render_household_debit_category_menu(
    *, state: FSMContext, message: Message, db, user_id: int, error_message: str | None = None
) -> None:
    categories = db.list_active_income_categories(user_id)
    if categories:
        text = "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–ø–∏—Å–∞–Ω–∏—è"
        if error_message:
            text = f"{error_message}\n\n{text}"
    else:
        text = "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –¥–æ—Ö–æ–¥–∞ –ø–æ–∫–∞ –Ω–µ—Ç."
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=text,
        reply_markup=household_debit_category_select_reply_keyboard(categories)
        if categories
        else household_settings_reply_keyboard(),
        screen_id="hp:debit_category_menu",
        force_new=True,
    )
    await state.update_data(
        hp_debit_map={category.get("title", ""): category.get("code") for category in categories}
    )
    if categories:
        await state.set_state(HouseholdSettingsState.waiting_for_debit_category)


async def _render_wishlist_debit_category_menu(
    *, state: FSMContext, message: Message, db, user_id: int, error_message: str | None = None
) -> None:
    categories = db.list_active_income_categories(user_id)
    selected = db.get_wishlist_debit_category(user_id)
    selected_title = "–ù–µ –≤—ã–±—Ä–∞–Ω–æ"
    if selected:
        income_category = db.get_income_category_by_code(user_id, selected)
        selected_title = income_category.get("title", selected) if income_category else "–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É–¥–∞–ª–µ–Ω–∞"
    if categories:
        text = (
            "–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –ø–æ–∫—É–ø–æ–∫ (Wishlist)\n"
            f"–¢–µ–∫—É—â–∞—è: {selected_title}\n\n"
            "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–ø–∏—Å–∞–Ω–∏—è"
        )
        if error_message:
            text = f"{error_message}\n\n{text}"
    else:
        text = "–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–æ—Ö–æ–¥–æ–≤/–Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π."
    LOGGER.info("USER=%s ACTION=WISHLIST_DEBIT_CATEGORY_MENU_OPEN", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=text,
        reply_markup=wishlist_debit_category_select_reply_keyboard(categories)
        if categories
        else back_only_keyboard(),
        screen_id="wl:debit_category_menu",
        force_new=True,
    )
    await state.update_data(
        wl_debit_map={category.get("title", ""): category.get("code") for category in categories}
    )
    if categories:
        await state.set_state(WishlistSettingsState.waiting_for_debit_category)


def _format_category_text(
    title: str, categories: list[dict], error_message: str | None = None
) -> str:
    lines: list[str] = [title, ""]
    for category in categories:
        lines.append(f"{category['title']} ‚Äî {category['percent']}%")
    total = sum(category.get("percent", 0) for category in categories)
    lines.append("")
    lines.append(f"–°—É–º–º–∞: {total}%")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


def _format_wishlist_text(
    categories: list[dict],
    debit_category_title: str,
    error_message: str | None = None,
) -> str:
    lines: list[str] = ["üßæ –í–ò–®–õ–ò–°–¢ ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏", "", "–ö–∞—Ç–µ–≥–æ—Ä–∏–∏:", ""]
    if categories:
        for category in categories:
            mode = str(category.get("purchased_mode") or "days")
            days = int(category.get("purchased_days") or 30)
            if mode == "always":
                display = "–í—Å–µ–≥–¥–∞"
            else:
                display = f"{days} –¥–Ω–µ–π"
            lines.append(f"{category.get('title', '')} ‚Äî –ö—É–ø–ª–µ–Ω–Ω–æ–µ: {display}")
    lines.extend(["", f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è: {debit_category_title}"])
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


def _format_byt_rules_text(
    settings: dict, times: list[dict], error_message: str | None = None
) -> str:
    on_off = {True: "–î–ê", False: "–ù–ï–¢", 1: "–î–ê", 0: "–ù–ï–¢"}
    lines = [
        "üß∫ –ë–´–¢ ‚Äî —É—Å–ª–æ–≤–∏—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π",
        "",
        f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã: {on_off.get(settings.get('byt_reminders_enabled', 1), '–ù–ï–¢')}",
        "–°–ª–∞—Ç—å –µ—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç: –ù–ï–¢",
        '–§–æ—Ä–º–∞—Ç: "–ß—Ç–æ —Ç—ã –∫—É–ø–∏–ª?" (–∫–Ω–æ–ø–∫–∏-—Ç–æ–≤–∞—Ä—ã)',
        f"–û–¢–õ–û–ñ–ò–¢–¨: {on_off.get(settings.get('byt_defer_enabled', 1), '–ù–ï–¢')}",
        f"–ú–∞–∫—Å. –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∏—Ç—å: {settings.get('byt_defer_max_days', 365)}",
        "",
        "–¢–∞–π–º–µ—Ä:",
        "",
    ]
    if times:
        for timer in times:
            lines.append(
                f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
            )
    else:
        lines.append("(–ø—É—Å—Ç–æ)")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


def _format_byt_timer_text(times: list[dict], error_message: str | None = None) -> str:
    lines = ["‚è∞ –ë–´–¢ ‚Äî —Ç–∞–π–º–µ—Ä –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π", "–¢–µ–∫—É—â–∏–µ –≤—Ä–µ–º–µ–Ω–∞:", ""]
    if times:
        for timer in times:
            lines.append(f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}")
    else:
        lines.append("(–ø—É—Å—Ç–æ)")
    if error_message:
        lines.append("")
        lines.append(error_message)
    return "\n".join(lines)


async def _render_income_settings(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    error_message: str | None = None,
) -> list[dict]:
    categories = db.list_active_income_categories(user_id)
    LOGGER.info("Open income settings (reply mode) user_id=%s", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_category_text(
            "üìä –î–û–•–û–î ‚Äî –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –ø—Ä–æ—Ü–µ–Ω—Ç—ã", categories, error_message
        ),
        reply_markup=income_settings_reply_keyboard(),
        screen_id="st:income",
    )
    return categories


async def _render_wishlist_settings(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    error_message: str | None = None,
) -> list[dict]:
    categories = db.list_active_wishlist_categories(user_id)
    debit_category = db.get_wishlist_debit_category(user_id)
    debit_title = "–ù–µ –≤—ã–±—Ä–∞–Ω–æ"
    if debit_category:
        income_category = db.get_income_category_by_code(user_id, debit_category)
        debit_title = income_category.get("title", debit_category) if income_category else "–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É–¥–∞–ª–µ–Ω–∞"
    LOGGER.info("Open wishlist settings (reply mode) user_id=%s", user_id)
    LOGGER.info("USER=%s ACTION=WISHLIST_SETTINGS_OPEN", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_wishlist_text(categories, debit_title, error_message),
        reply_markup=wishlist_settings_reply_keyboard(),
        screen_id="st:wishlist",
    )
    return categories


async def _render_byt_rules_settings(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    error_message: str | None = None,
) -> dict:
    db.ensure_user_settings(user_id)
    settings_row = db.get_user_settings(user_id)
    db.ensure_byt_timer_defaults(user_id)
    times = db.list_active_byt_timer_times(user_id)
    LOGGER.info("Open byt conditions settings (reply mode) user_id=%s", user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_byt_rules_text(settings_row, times, error_message),
        reply_markup=byt_rules_reply_keyboard(),
        screen_id="st:byt_rules",
    )
    return settings_row


async def _render_byt_timer_settings(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    error_message: str | None = None,
) -> list[dict]:
    db.ensure_byt_timer_defaults(user_id)
    times = db.list_active_byt_timer_times(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=_format_byt_timer_text(times, error_message),
        reply_markup=byt_timer_reply_keyboard(),
        screen_id="byt:timer_menu",
    )
    return times


async def _render_income_delete_menu(
    *, state: FSMContext, message: Message, db, user_id: int
) -> None:
    categories = db.list_active_income_categories(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="–ß—Ç–æ —É–¥–∞–ª–∏—Ç—å?" if categories else "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ–∫–∞ –Ω–µ—Ç.",
        reply_markup=income_categories_select_reply_keyboard(categories)
        if categories
        else income_settings_reply_keyboard(),
        screen_id="inc:del_menu",
        force_new=True,
    )
    await state.update_data(
        inc_delete_map={
            f"{category.get('title', '')} ‚Äî {category.get('percent', 0)}%": category.get(
                "id"
            )
            for category in categories
        }
    )
    if categories:
        await state.set_state(IncomeSettingsState.waiting_for_removal)


async def _render_income_percent_menu(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    error_message: str | None = None,
) -> None:
    categories = db.list_active_income_categories(user_id)
    if categories:
        text = "–ö–∞–∫–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –º–µ–Ω—è–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç?"
        if error_message:
            text = f"{error_message}\n\n{text}"
    else:
        text = "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ–∫–∞ –Ω–µ—Ç."
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=text,
        reply_markup=income_categories_select_reply_keyboard(categories)
        if categories
        else income_settings_reply_keyboard(),
        screen_id="inc:pct_menu",
        force_new=True,
    )
    await state.update_data(
        inc_percent_map={
            f"{category.get('title', '')} ‚Äî {category.get('percent', 0)}%": category.get(
                "id"
            )
            for category in categories
        }
    )
    if categories:
        await state.set_state(IncomeSettingsState.waiting_for_percent_category)


async def _render_wishlist_delete_menu(
    *, state: FSMContext, message: Message, db, user_id: int
) -> None:
    categories = db.list_active_wishlist_categories(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="–ß—Ç–æ —É–¥–∞–ª–∏—Ç—å?" if categories else "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ–∫–∞ –Ω–µ—Ç.",
        reply_markup=wishlist_categories_select_reply_keyboard(categories)
        if categories
        else wishlist_settings_reply_keyboard(),
        screen_id="wl:del_cat_menu",
        force_new=True,
    )
    await state.update_data(
        wl_delete_map={category.get("title", ""): category.get("id") for category in categories}
    )
    if categories:
        await state.set_state(WishlistSettingsState.waiting_for_removal)


async def _render_wishlist_purchased_select_menu(
    *, state: FSMContext, message: Message, db, user_id: int
) -> None:
    categories = db.list_active_wishlist_categories(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ä–æ–∫–∞ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ"
        if categories
        else "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ–∫–∞ –Ω–µ—Ç.",
        reply_markup=wishlist_categories_select_reply_keyboard(categories)
        if categories
        else wishlist_settings_reply_keyboard(),
        screen_id="wl:purchased_select_category",
        force_new=True,
    )
    await state.update_data(
        wl_purchased_map={
            category.get("title", ""): category.get("id") for category in categories
        }
    )
    if categories:
        await state.set_state(WishlistSettingsState.waiting_for_purchased_category)


async def _render_wishlist_purchased_mode(
    *,
    state: FSMContext,
    message: Message,
    db,
    user_id: int,
    category_id: int,
) -> None:
    category = db.get_wishlist_category_by_id(user_id, category_id)
    await state.set_state(WishlistSettingsState.waiting_for_purchased_mode)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text=(
            f'‚è≥ –ö—É–ø–ª–µ–Ω–Ω–æ–µ ‚Äî "{category.get("title", "")}"\n–ö–∞–∫ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ?'
        ),
        reply_markup=wishlist_purchased_mode_reply_keyboard(),
        screen_id="wl:purchased_mode",
        force_new=True,
    )


async def _render_byt_timer_delete_menu(
    *, state: FSMContext, message: Message, db, user_id: int
) -> None:
    times = db.list_active_byt_timer_times(user_id)
    await _render_reply_settings_page(
        message=message,
        state=state,
        text="–ß—Ç–æ —É–¥–∞–ª–∏—Ç—å?" if times else "–í—Ä–µ–º–µ–Ω–∞ –ø–æ–∫–∞ –Ω–µ –∑–∞–¥–∞–Ω—ã.",
        reply_markup=byt_timer_times_select_reply_keyboard(times)
        if times
        else byt_timer_reply_keyboard(),
        screen_id="bt:del_time_menu",
        force_new=True,
    )
    await state.update_data(
        bt_delete_map={
            f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}": timer.get(
                "id"
            )
            for timer in times
        }
    )
    if times:
        await state.set_state(BytTimerState.waiting_for_removal)


async def render_settings_screen(
    screen_id: str,
    *,
    message: Message,
    state: FSMContext,
    error_message: str | None = None,
    force_new: bool = False,
) -> None:
    db = get_db()
    data = await state.get_data()
    user_id = message.from_user.id
    if message.from_user.id == message.bot.id:
        user_id = data.get("settings_user_id") or message.from_user.id
    if screen_id == "st:home":
        await _render_settings_home(message, state)
    elif screen_id == "st:income":
        await _render_income_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "inc:del_menu":
        await _render_income_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "inc:pct_menu":
        await _render_income_percent_menu(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "st:wishlist":
        await _render_wishlist_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "st:household_payments":
        await _render_household_payments_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
            force_new_keyboard=force_new,
        )
    elif screen_id == "wl:del_cat_menu":
        await _render_wishlist_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "wl:purchased_select_category":
        await _render_wishlist_purchased_select_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "wl:purchased_mode":
        data = await state.get_data()
        category_id = data.get("editing_wl_category_id")
        if category_id is not None:
            await _render_wishlist_purchased_mode(
                state=state,
                message=message,
                db=db,
                user_id=user_id,
                category_id=int(category_id),
            )
        else:
            await _render_wishlist_settings(
                state=state,
                message=message,
                db=db,
                user_id=user_id,
            )
    elif screen_id == "wl:debit_category_menu":
        await _render_wishlist_debit_category_menu(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "st:byt_rules":
        await _render_byt_rules_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "byt:timer_menu":
        await _render_byt_timer_settings(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    elif screen_id == "bt:del_time_menu":
        await _render_byt_timer_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "hp:del_payment_menu":
        await _render_household_delete_menu(
            state=state, message=message, db=db, user_id=user_id
        )
    elif screen_id == "hp:debit_category_menu":
        await _render_household_debit_category_menu(
            state=state,
            message=message,
            db=db,
            user_id=user_id,
            error_message=error_message,
        )
    else:
        await _render_settings_home(message, state)
    await _set_current_screen(state, screen_id)


async def _navigate_to_screen(
    screen_id: str,
    *,
    message: Message,
    state: FSMContext,
    error_message: str | None = None,
    force_new: bool = False,
) -> None:
    await _push_current_screen(state, screen_id)
    await render_settings_screen(
        screen_id,
        message=message,
        state=state,
        error_message=error_message,
        force_new=force_new,
    )


async def _render_previous_screen_or_exit(
    message: Message, state: FSMContext
) -> None:
    previous = await _pop_previous_screen(state)
    if previous:
        await render_settings_screen(previous, message=message, state=state)
    else:
        await _exit_settings_to_main(
            bot=message.bot,
            state=state,
            chat_id=message.chat.id,
            user_id=message.from_user.id,
        )


async def handle_settings_back_action(message: Message, state: FSMContext) -> None:
    current_state = await state.get_state()
    data = await state.get_data()

    await _register_user_message(state, message)
    await _delete_user_message(message)

    numeric_cleanup_map = {
        IncomeSettingsState.waiting_for_percent.state: {
            "display_chat_key": "percent_display_chat_id",
            "display_message_key": "percent_display_message_id",
        },
        IncomeSettingsState.waiting_for_new_category_percent.state: {
            "display_chat_key": "new_income_display_chat_id",
            "display_message_key": "new_income_display_message_id",
        },
        WishlistSettingsState.waiting_for_purchased_days.state: {
            "display_chat_key": "purchased_display_chat_id",
            "display_message_key": "purchased_display_message_id",
        },
        HouseholdSettingsState.waiting_for_amount.state: {
            "display_chat_key": "hp_amount_display_chat_id",
            "display_message_key": "hp_amount_display_message_id",
        },
        BytSettingsState.waiting_for_max_defer_days.state: {
            "display_chat_key": "byt_max_display_chat_id",
            "display_message_key": "byt_max_display_message_id",
        },
        BytTimerState.waiting_for_hour.state: {
            "display_chat_key": "bt_hour_display_chat_id",
            "display_message_key": "bt_hour_display_message_id",
        },
        BytTimerState.waiting_for_minute.state: {
            "display_chat_key": "bt_min_display_chat_id",
            "display_message_key": "bt_min_display_message_id",
            "prompt_chat_key": "bt_min_prompt_chat_id",
            "prompt_message_key": "bt_min_prompt_message_id",
        },
    }

    cleanup_params = numeric_cleanup_map.get(current_state)
    if cleanup_params:
        await _cleanup_input_ui(message.bot, data, **cleanup_params)
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    await state.set_state(None)
    await _render_previous_screen_or_exit(message, state)


@router.message(F.text == "‚öôÔ∏è")
async def open_settings(message: Message, state: FSMContext) -> None:
    """Open settings entry point with inline navigation."""

    await ui_track_message(state, message.chat.id, message.message_id)
    await _delete_user_message(message)
    await ui_cleanup_to_context(message.bot, state, message.chat.id, "SETTINGS_MENU")
    await state.update_data(settings_user_id=message.from_user.id)
    screen_id = await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò",
        reply_markup=settings_home_reply_keyboard(),
    )
    await _store_settings_message(state, message.chat.id, screen_id)
    await _set_current_screen(state, "st:home")
    await _reset_navigation(state)


@router.callback_query(F.data == "st:home")
async def back_to_settings_home(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _reset_navigation(state)
    await render_settings_screen("st:home", message=callback.message, state=state)


@router.message(F.text == "‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò")
async def back_to_settings_home_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _reset_navigation(state)
    await render_settings_screen("st:home", message=message, state=state)


@router.callback_query(F.data == "st:income")
async def open_income_settings(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:income", message=callback.message, state=state)


@router.message(F.text == "üìä –î–æ—Ö–æ–¥")
async def open_income_settings_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("st:income", message=message, state=state)


@router.message(F.text.in_({"–ù–∞–∑–∞–¥", "‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥"}))
async def settings_exit_via_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await handle_settings_back_action(message, state)


@router.callback_query(F.data == "st:wishlist")
async def open_wishlist(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:wishlist", message=callback.message, state=state)


@router.message(F.text == "üßæ –í–∏—à–ª–∏—Å—Ç")
async def open_wishlist_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("st:wishlist", message=message, state=state)


@router.callback_query(F.data == "st:household_payments")
async def open_household_payments(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen(
        "st:household_payments", message=callback.message, state=state, force_new=True
    )


@router.message(F.text == "üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")
async def open_household_payments_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "st:household_payments", message=message, state=state, force_new=True
    )


@router.message(F.text == "üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è")
async def open_byt_rules_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å")
async def household_payment_add_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "hp:add_payment")
    await state.set_state(HouseholdSettingsState.waiting_for_title)
    await state.update_data(hp_amount_str="0", hp_new_title=None)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ù–∞–ø–∏—à–∏ –ø–ª–∞—Ç—ë–∂",
        reply_markup=back_only_keyboard(),
    )


@router.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å")
async def household_payment_delete_menu_reply(
    message: Message, state: FSMContext
) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "hp:del_payment_menu", message=message, state=state, force_new=True
    )


@router.message(F.text == "üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è")
async def household_debit_category_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "hp:debit_category_menu", message=message, state=state, force_new=True
    )


@router.message(F.text == "üßπ –û–±–Ω—É–ª–∏—Ç—å")
async def household_reset_questions_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    db = get_db()
    month = current_month_str()
    await db.reset_household_questions_for_month(message.from_user.id, month)
    LOGGER.info(
        "Reset household payment statuses (user_id=%s, month=%s)",
        message.from_user.id,
        month,
    )
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=False
    )


@router.message(F.text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å")
async def household_refresh_questions_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:household_payments":
        return
    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _send_and_register(
        message=message,
        state=state,
        text="–≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞. –û—Ç–∫—Ä–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–Ω–æ–≤–æ.",
    )
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=False
    )


@router.message(
    InSettingsFilter(),
    F.text.in_(
        {
            "‚ûï",
            "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞",
            "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞",
            "‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è",
        }
    ),
)
async def settings_add_action_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    screen = data.get("settings_current_screen")
    if screen not in {"st:income", "st:wishlist", "st:byt_rules"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)

    if screen == "st:income":
        await _push_current_screen(state, "inc:add_category")
        await state.set_state(IncomeSettingsState.waiting_for_category_title)
        prompt = "–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–æ—Ö–æ–¥–∞?"
        next_screen = "inc:add_category"
    elif screen == "st:wishlist":
        await _push_current_screen(state, "wl:add_category")
        await state.set_state(WishlistSettingsState.waiting_for_category_title)
        prompt = "–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∏—à–ª–∏—Å—Ç–∞?"
        next_screen = "wl:add_category"
    else:
        await _push_current_screen(state, "bt:add_time_text")
        await state.set_state(BytTimerState.waiting_for_time_add)
        prompt = "–í–≤–µ–¥–∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä 12:00)"
        next_screen = "bt:add_time_text"

    await _render_reply_settings_page(
        message=message,
        state=state,
        text=prompt,
        reply_markup=back_only_keyboard(),
        screen_id=next_screen,
        force_new=True,
    )


@router.message(
    InSettingsFilter(),
    F.text.in_(
        {
            "‚ûñ",
            "‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞",
            "‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞",
            "‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è",
        }
    ),
)
async def settings_delete_action_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    screen = data.get("settings_current_screen")
    if screen not in {"st:income", "st:wishlist", "st:byt_rules"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)

    if screen == "st:income":
        await _navigate_to_screen("inc:del_menu", message=message, state=state, force_new=True)
        return
    if screen == "st:wishlist":
        await _navigate_to_screen("wl:del_cat_menu", message=message, state=state, force_new=True)
        return
    await _navigate_to_screen("bt:del_time_menu", message=message, state=state, force_new=True)


@router.message(F.text.in_({"%", "‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤"}))
async def income_percent_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    if data.get("settings_current_screen") != "st:income":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)

    db = get_db()
    total = db.sum_income_category_percents(message.from_user.id)
    if total == 100:
        await render_settings_screen(
            "st:income",
            message=message,
            state=state,
            error_message="–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ 100%. –û–ö.",
        )
        return

    await _navigate_to_screen(
        "inc:pct_menu",
        message=message,
        state=state,
        force_new=True,
        error_message=f"–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ —Å–µ–π—á–∞—Å {total}%. –ù—É–∂–Ω–æ 100%.",
    )


@router.message(F.text == "üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")
async def wishlist_purchased_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if not data.get("in_settings"):
        return
    if data.get("settings_current_screen") != "st:wishlist":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "wl:purchased_select_category", message=message, state=state, force_new=True
    )


@router.message(F.text == WISHLIST_DEBIT_CATEGORY_BUTTON)
async def wishlist_debit_category_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    current_state = await state.get_state()
    LOGGER.info(
        "USER=%s ACTION=WISHLIST_DEBIT_CATEGORY_MENU_CLICK STATE=%s META=current_screen=%s in_settings=%s",
        message.from_user.id,
        current_state,
        data.get("settings_current_screen"),
        data.get("in_settings"),
    )
    if not data.get("in_settings"):
        return
    if data.get("settings_current_screen") != "st:wishlist":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen(
        "wl:debit_category_menu", message=message, state=state, force_new=True
    )


@router.message(F.text == "üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è")
async def byt_toggle_enabled_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    db = get_db()
    settings_row = db.get_user_settings(message.from_user.id)
    current = bool(settings_row.get("byt_reminders_enabled", 1))
    db.set_byt_reminders_enabled(message.from_user.id, not current)
    await render_settings_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª")
async def byt_toggle_defer_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    db = get_db()
    settings_row = db.get_user_settings(message.from_user.id)
    current = bool(settings_row.get("byt_defer_enabled", 1))
    db.set_byt_defer_enabled(message.from_user.id, not current)
    await render_settings_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")
async def edit_byt_max_defer_days_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "byt:edit_max_defer_days")
    await state.set_state(BytSettingsState.waiting_for_max_defer_days)
    db = get_db()
    settings_row = db.get_user_settings(message.from_user.id)
    await state.update_data(
        byt_max_days_str="0",
        previous_byt_max_days=settings_row.get("byt_defer_max_days", 365),
    )
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ú–∞–∫—Å–∏–º—É–º –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∫–∏?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        byt_max_display_chat_id=prompt.chat.id,
        byt_max_display_message_id=prompt.message_id,
    )


@router.message(F.text.in_({"‚è∞ –¢–∞–π–º–µ—Ä", "‚è± –¢–∞–π–º–µ—Ä"}))
async def open_byt_timer_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "st:byt_rules":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("byt:timer_menu", message=message, state=state)


@router.message(F.text == "‚öô –£—Å–ª–æ–≤–∏—è")
async def open_byt_rules_reply(message: Message, state: FSMContext) -> None:
