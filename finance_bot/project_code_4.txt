    data = await state.get_data()
    if data.get("settings_current_screen") not in {"st:byt_rules", "byt:timer_menu"}:
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    if data.get("settings_current_screen") == "st:byt_rules":
        await render_settings_screen("st:byt_rules", message=message, state=state)
        return
    await _navigate_to_screen("st:byt_rules", message=message, state=state)


@router.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è")
async def byt_timer_add_hour_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await _push_current_screen(state, "bt:add_time_hour")
    await state.set_state(BytTimerState.waiting_for_hour)
    await state.update_data(bt_hour_str="0")
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –ß–ê–° (0‚Äì23)",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        bt_hour_display_chat_id=prompt.chat.id,
        bt_hour_display_message_id=prompt.message_id,
    )


@router.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è")
async def byt_timer_delete_menu_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    await state.set_state(None)
    await _navigate_to_screen("bt:del_time_menu", message=message, state=state, force_new=True)


@router.message(F.text == "üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
async def byt_timer_reset_reply(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    if data.get("settings_current_screen") != "byt:timer_menu":
        return

    await _register_user_message(state, message)
    await _delete_user_message(message)
    db = get_db()
    db.reset_byt_timer_times(message.from_user.id)
    await render_settings_screen("byt:timer_menu", message=message, state=state)

@router.callback_query(F.data == "st:byt_rules")
async def open_byt_rules(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("st:byt_rules", message=callback.message, state=state)


@router.callback_query(F.data == "byt:toggle_enabled")
async def toggle_byt_enabled(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    db = get_db()
    settings_row = db.get_user_settings(callback.from_user.id)
    current = bool(settings_row.get("byt_reminders_enabled", 1))
    db.set_byt_reminders_enabled(callback.from_user.id, not current)
    await render_settings_screen(
        "st:byt_rules", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:toggle_defer")
async def toggle_byt_defer(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    db = get_db()
    settings_row = db.get_user_settings(callback.from_user.id)
    current = bool(settings_row.get("byt_defer_enabled", 1))
    db.set_byt_defer_enabled(callback.from_user.id, not current)
    await render_settings_screen(
        "st:byt_rules", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:edit_max_defer_days")
async def edit_byt_max_defer_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "byt:edit_max_defer_days")
    await state.set_state(BytSettingsState.waiting_for_max_defer_days)
    db = get_db()
    settings_row = db.get_user_settings(callback.from_user.id)
    await state.update_data(
        byt_max_days_str="0", previous_byt_max_days=settings_row.get("byt_defer_max_days", 365)
    )
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ú–∞–∫—Å–∏–º—É–º –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∫–∏?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        byt_max_display_chat_id=prompt.chat.id,
        byt_max_display_message_id=prompt.message_id,
    )


@router.callback_query(F.data == "bt:add_time_hour")
async def byt_timer_add_hour(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "bt:add_time_hour")
    await state.set_state(BytTimerState.waiting_for_hour)
    await state.update_data(bt_hour_str="0")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –ß–ê–° (0‚Äì23)",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        bt_hour_display_chat_id=prompt.chat.id,
        bt_hour_display_message_id=prompt.message_id,
    )


@router.callback_query(F.data == "bt:del_time_menu")
async def byt_timer_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("bt:del_time_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("bt:del_time:"))
async def byt_timer_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        timer_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = get_db()
    times = db.list_active_byt_timer_times(callback.from_user.id)
    if len(times) <= 1:
        await _render_byt_timer_settings(
            state=state,
            message=callback.message,
            db=db,
            user_id=callback.from_user.id,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è.",
        )
        return

    db.deactivate_byt_timer_time(callback.from_user.id, timer_id)
    await _render_byt_timer_settings(
        state=state, message=callback.message, db=db, user_id=callback.from_user.id
    )


@router.callback_query(F.data == "bt:reset_default")
async def byt_timer_reset(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    db = get_db()
    db.reset_byt_timer_times(callback.from_user.id)
    await render_settings_screen(
        "byt:timer_menu", message=callback.message, state=state
    )


@router.callback_query(F.data == "byt:timer_menu")
async def open_byt_timer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("byt:timer_menu", message=callback.message, state=state)


@router.message(HouseholdSettingsState.waiting_for_removal)
async def household_payment_delete_choice(
    message: Message, state: FSMContext
) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    mapping: dict[str, str] = data.get("hp_delete_map") or {}
    choice = (message.text or "").strip()
    if choice in {"‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥"}:
        await state.set_state(None)
        await render_settings_screen(
            "st:household_payments", message=message, state=state, force_new=False
        )
        return

    code = mapping.get(choice)
    if not code:
        await _send_and_register(
            message=message,
            state=state,
            text="–í—ã–±–µ—Ä–∏ –ø–ª–∞—Ç–µ–∂ –∏–∑ —Å–ø–∏—Å–∫–∞.",
        )
        return

    db = get_db()
    db.deactivate_household_payment_item(message.from_user.id, code)
    await db.init_household_questions_for_month(
        message.from_user.id, current_month_str()
    )
    LOGGER.info(
        "Deleted household payment item (user_id=%s, code=%s)",
        message.from_user.id,
        code,
    )
    await state.set_state(None)
    await render_settings_screen(
        "st:household_payments", message=message, state=state, force_new=False
    )


@router.message(HouseholdSettingsState.waiting_for_debit_category)
async def household_debit_category_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice in {"‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥"}:
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:household_payments"
        await render_settings_screen(previous_screen, message=message, state=state)
        return

    mapping: dict[str, str] = data.get("hp_debit_map") or {}
    category_code = mapping.get(choice)
    if not category_code:
        await render_settings_screen(
            "hp:debit_category_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    db.set_household_debit_category(message.from_user.id, str(category_code))
    LOGGER.info(
        "USER=%s ACTION=HOUSEHOLD_DEBIT_CATEGORY_SET META=category=%s",
        message.from_user.id,
        category_code,
    )
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:household_payments"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_debit_category)
async def wishlist_debit_category_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice in {WISHLIST_DEBIT_CATEGORY_BACK, "‚¨Ö –ù–∞–∑–∞–¥"}:
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:wishlist"
        await render_settings_screen(previous_screen, message=message, state=state)
        return

    if choice == WISHLIST_DEBIT_CATEGORY_NONE:
        db = get_db()
        db.set_wishlist_debit_category(message.from_user.id, None)
        LOGGER.info(
            "USER=%s ACTION=WISHLIST_DEBIT_CATEGORY_SET META=category=None",
            message.from_user.id,
        )
        await _send_and_register(
            message=message,
            state=state,
            text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞.",
        )
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:wishlist"
        await render_settings_screen(previous_screen, message=message, state=state)
        return

    mapping: dict[str, str] = data.get("wl_debit_map") or {}
    category_code = mapping.get(choice)
    if not category_code:
        await render_settings_screen(
            "wl:debit_category_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    db.set_wishlist_debit_category(message.from_user.id, str(category_code))
    LOGGER.info(
        "USER=%s ACTION=WISHLIST_DEBIT_CATEGORY_SET META=category=%s",
        message.from_user.id,
        category_code,
    )
    await _send_and_register(
        message=message,
        state=state,
        text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞.",
    )
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(IncomeSettingsState.waiting_for_removal)
async def income_category_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("inc_delete_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "inc:del_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    categories = db.list_active_income_categories(message.from_user.id)
    if len([cat for cat in categories if cat.get("is_active", 1)]) <= 1:
        await state.set_state(None)
        await render_settings_screen(
            "st:income",
            message=message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_income_category(message.from_user.id, category_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:income"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(IncomeSettingsState.waiting_for_percent_category)
async def income_category_percent_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("inc_percent_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "inc:pct_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    category = db.get_income_category_by_id(message.from_user.id, category_id)
    if not category:
        await state.set_state(None)
        await render_settings_screen("st:income", message=message, state=state)
        return

    await _push_current_screen(state, "inc:pct_input")
    await state.update_data(
        edit_scope="income",
        editing_category_id=category_id,
        previous_percent=category.get("percent", 0),
        percent_str="0",
    )
    await state.set_state(IncomeSettingsState.waiting_for_percent)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f"–í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç (0‚Äì100) –¥–ª—è: {category['title']}",
        reply_markup=None,
    )
    percent_message = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        percent_display_chat_id=percent_message.chat.id,
        percent_display_message_id=percent_message.message_id,
    )
    LOGGER.info(
        "Percent edit start: user=%s scope=%s category_id=%s",
        message.from_user.id,
        "income",
        category_id,
    )


@router.message(WishlistSettingsState.waiting_for_removal)
async def wishlist_category_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("wl_delete_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "wl:del_cat_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    categories = db.list_active_wishlist_categories(message.from_user.id)
    if len(categories) <= 1:
        await state.set_state(None)
        await render_settings_screen(
            "st:wishlist",
            message=message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_wishlist_category(message.from_user.id, category_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_category)
async def wishlist_purchased_category_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("wl_purchased_map") or {}
    category_id = mapping.get(choice)
    if not category_id:
        await render_settings_screen(
            "wl:purchased_select_category",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    category = db.get_wishlist_category_by_id(message.from_user.id, category_id)
    if not category or not category.get("is_active", 1):
        await state.set_state(None)
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    await _push_current_screen(state, "wl:purchased_mode")
    await state.update_data(editing_wl_category_id=category_id)
    await state.set_state(WishlistSettingsState.waiting_for_purchased_mode)
    await _navigate_to_screen(
        "wl:purchased_mode", message=message, state=state, force_new=True
    )


@router.message(WishlistSettingsState.waiting_for_purchased_mode)
async def wishlist_purchased_mode_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await state.set_state(None)
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    db = get_db()
    if choice == "–í—Å–µ–≥–¥–∞":
        db.update_wishlist_category_purchased_mode(
            message.from_user.id, int(category_id), "always"
        )
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=message, state=state)
        return
    if choice != "–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏":
        await render_settings_screen(
            "wl:purchased_mode",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    category = db.get_wishlist_category_by_id(message.from_user.id, int(category_id))
    if not category:
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=message, state=state)
        return

    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(
        message.from_user.id, int(category_id), "days"
    )
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ –¥–ª—è "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(BytTimerState.waiting_for_removal)
async def byt_timer_delete_choice(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    await _register_user_message(state, message)
    await _delete_user_message(message)

    choice = (message.text or "").strip()
    if choice == "‚¨Ö –ù–∞–∑–∞–¥":
        await state.set_state(None)
        await _render_previous_screen_or_exit(message, state)
        return

    mapping: dict[str, int] = data.get("bt_delete_map") or {}
    timer_id = mapping.get(choice)
    if not timer_id:
        await render_settings_screen(
            "bt:del_time_menu",
            message=message,
            state=state,
            error_message="–í—ã–±–µ—Ä–∏ –≤—Ä–µ–º—è –∏–∑ —Å–ø–∏—Å–∫–∞.",
            force_new=True,
        )
        return

    db = get_db()
    times = db.list_active_byt_timer_times(message.from_user.id)
    if len(times) <= 1:
        await state.set_state(None)
        await _render_byt_timer_settings(
            state=state,
            message=message,
            db=db,
            user_id=message.from_user.id,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è.",
        )
        return

    db.deactivate_byt_timer_time(message.from_user.id, timer_id)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(BytTimerState.waiting_for_time_add)
async def byt_timer_add_time_value(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    text = (message.text or "").strip()
    parsed = _parse_time_text(text)
    if not parsed:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú.",
            reply_markup=None,
        )
        return

    hour, minute = parsed
    db = get_db()
    db.add_byt_timer_time(message.from_user.id, hour, minute)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
    await render_settings_screen(previous_screen, message=message, state=state)

@router.callback_query(F.data == "inc:add")
async def category_add(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "inc:add_category")
    await state.set_state(IncomeSettingsState.waiting_for_category_title)
    await state.update_data(category_scope="income")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        reply_markup=None,
    )


@router.callback_query(F.data == "wl:add_cat")
async def wishlist_category_add(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await _push_current_screen(state, "wl:add_category")
    await state.set_state(WishlistSettingsState.waiting_for_category_title)
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        reply_markup=None,
    )


@router.message(IncomeSettingsState.waiting_for_category_title)
async def income_add_category_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    title = (message.text or "").strip()
    if not title or len(title) > 32:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 32 —Å–∏–º–≤–æ–ª–æ–≤.",
            reply_markup=None,
        )
        return

    await state.update_data(new_income_category_title=title, new_income_percent_str="0")
    await state.set_state(IncomeSettingsState.waiting_for_new_category_percent)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text="–ü—Ä–æ—Ü–µ–Ω—Ç –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏?",
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        new_income_display_chat_id=prompt.chat.id,
        new_income_display_message_id=prompt.message_id,
    )


@router.message(WishlistSettingsState.waiting_for_category_title)
async def wishlist_add_category_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    await _delete_user_message(message)
    title = (message.text or "").strip()
    if not title or len(title) > 32:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 32 —Å–∏–º–≤–æ–ª–æ–≤.",
            reply_markup=None,
        )
        return

    db = get_db()
    db.create_wishlist_category(message.from_user.id, title)
    await state.set_state(None)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=message, state=state)


@router.message(
    IncomeSettingsState.waiting_for_new_category_percent, F.text.in_(PERCENT_INPUT_BUTTONS)
)
async def income_new_category_percent(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    percent_str = data.get("new_income_percent_str", "0")
    display_chat_id = data.get("new_income_display_chat_id", message.chat.id)
    display_message_id = data.get("new_income_display_message_id")

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {percent_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            new_income_percent_str=percent_str,
            new_income_display_chat_id=display_chat_id,
            new_income_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        percent_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            new_income_percent_str=percent_str,
            new_income_display_chat_id=display_chat_id,
            new_income_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º."
            percent = 0
        else:
            if percent < 0 or percent > 100:
                error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 0‚Äì100."

        title = (data.get("new_income_category_title") or "").strip()
        if not title:
            error_message = error_message or "–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ –∑–∞–¥–∞–Ω–æ."

        if error_message is None:
            db = get_db()
            category_id = db.create_income_category(message.from_user.id, title)
            if category_id is not None:
                db.update_income_category_percent(
                    message.from_user.id, category_id, percent
                )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="new_income_display_chat_id",
            display_message_key="new_income_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(
            previous_screen, message=message, state=state, error_message=error_message
        )


@router.message(HouseholdSettingsState.waiting_for_title)
async def household_payment_title(message: Message, state: FSMContext) -> None:
    await _register_user_message(state, message)
    title = (message.text or "").strip()
    if not title:
        await _send_and_register(
            message=message,
            state=state,
            text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞.",
        )
        return

    await state.update_data(hp_new_title=title, hp_amount_str="0")
    await state.set_state(HouseholdSettingsState.waiting_for_amount)
    chat_id, message_id = await _get_settings_message_ids(state, message)
    await _edit_settings_page(
        bot=message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f'–°–∫–æ–ª—å–∫–æ –ø–ª–∞—Ç–∏—Ç—å –∑–∞ "{title}"?',
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        hp_amount_display_chat_id=prompt.chat.id,
        hp_amount_display_message_id=prompt.message_id,
    )


@router.message(
    HouseholdSettingsState.waiting_for_amount, F.text.in_(PERCENT_INPUT_BUTTONS)
)
async def household_payment_amount(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    amount_str = data.get("hp_amount_str", "0")
    display_chat_id = data.get("hp_amount_display_chat_id", message.chat.id)
    display_message_id = data.get("hp_amount_display_message_id")

    if text in PERCENT_DIGITS:
        amount_str = amount_str.lstrip("0") if amount_str != "0" else ""
        amount_str = f"{amount_str}{text}" or "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {amount_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {amount_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            hp_amount_str=amount_str,
            hp_amount_display_chat_id=display_chat_id,
            hp_amount_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        amount_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            hp_amount_str=amount_str,
            hp_amount_display_chat_id=display_chat_id,
            hp_amount_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            amount = int(amount_str or "0")
        except ValueError:
            error_message = "–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ."
            amount = 0
        else:
            if amount <= 0:
                error_message = "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è."

        title = (data.get("hp_new_title") or "").strip()
        db = get_db()

        if not title:
            error_message = error_message or "–ù–∞–∑–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –∑–∞–¥–∞–Ω–æ."

        if error_message is None:
            position = db.get_next_household_position(message.from_user.id)
            code = f"custom_{time.time_ns()}"
            text_value = f"{title} {amount}—Ä?"
            db.add_household_payment_item(
                message.from_user.id, code, text_value, amount, position
            )
            await db.init_household_questions_for_month(
                message.from_user.id, current_month_str()
            )
            LOGGER.info(
                "Added household payment item (user_id=%s, code=%s, amount=%s, title=%s)",
                message.from_user.id,
                code,
                amount,
                title,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="hp_amount_display_chat_id",
            display_message_key="hp_amount_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:household_payments"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
            error_message=error_message,
        )


@router.callback_query(F.data == "inc:del_menu")
async def category_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("inc:del_menu", message=callback.message, state=state)


@router.callback_query(F.data == "wl:del_cat_menu")
async def wishlist_delete_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("wl:del_cat_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("inc:del:"))
async def category_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = get_db()
    scope = "income"
    categories = db.list_active_income_categories(callback.from_user.id)
    if len([cat for cat in categories if cat.get("is_active", 1)]) <= 1:
        await render_settings_screen(
            "st:income",
            message=callback.message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_income_category(callback.from_user.id, category_id)
    previous_screen = await _pop_previous_screen(state) or "st:income"
    await render_settings_screen(previous_screen, message=callback.message, state=state)


@router.callback_query(F.data.startswith("wl:del_cat:"))
async def wishlist_category_delete(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = get_db()
    categories = db.list_active_wishlist_categories(callback.from_user.id)
    if len(categories) <= 1:
        await render_settings_screen(
            "st:wishlist",
            message=callback.message,
            state=state,
            error_message="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
        )
        return

    db.deactivate_wishlist_category(callback.from_user.id, category_id)
    previous_screen = await _pop_previous_screen(state) or "st:wishlist"
    await render_settings_screen(previous_screen, message=callback.message, state=state)


@router.callback_query(F.data == "inc:pct_menu")
async def category_percent_menu(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen("inc:pct_menu", message=callback.message, state=state)


@router.callback_query(F.data.startswith("inc:pct:"))
async def category_percent_prompt(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = get_db()
    scope = "income"
    category = db.get_income_category_by_id(callback.from_user.id, category_id)
    if not category:
        await _render_income_settings(
            state=state, message=callback.message, db=db, user_id=callback.from_user.id
        )
        return

    await _push_current_screen(state, "inc:pct_input")
    await state.update_data(
        edit_scope=scope,
        editing_category_id=category_id,
        previous_percent=category.get("percent", 0),
        percent_str="0",
    )
    await state.set_state(IncomeSettingsState.waiting_for_percent)
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=f"–í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç (0‚Äì100) –¥–ª—è: {category['title']}",
        reply_markup=None,
    )

    percent_message = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        percent_display_chat_id=percent_message.chat.id,
        percent_display_message_id=percent_message.message_id,
    )
    LOGGER.info(
        "Percent edit start: user=%s scope=%s category_id=%s",
        callback.from_user.id,
        scope,
        category_id,
    )


@router.callback_query(F.data == "wl:purchased_select_category")
async def wishlist_purchased_select_category(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.set_state(None)
    await _navigate_to_screen(
        "wl:purchased_select_category", message=callback.message, state=state
    )


@router.callback_query(F.data.startswith("wl:purchased_cat:"))
async def wishlist_purchased_category(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    try:
        category_id = int(callback.data.split(":")[2])
    except (IndexError, ValueError):
        return

    db = get_db()
    category = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
    if not category or not category.get("is_active", 1):
        await render_settings_screen(
            "st:wishlist", message=callback.message, state=state
        )
        return

    await _push_current_screen(state, "wl:purchased_mode")
    await state.update_data(editing_wl_category_id=category_id)
    await _navigate_to_screen(
        "wl:purchased_mode", message=callback.message, state=state
    )


@router.callback_query(F.data == "wl:purchased_mode:always")
async def wishlist_set_purchased_always(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = get_db()
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "always")
    await state.set_state(None)
    await _reset_navigation(state, "st:wishlist")
    await render_settings_screen("st:wishlist", message=callback.message, state=state)


@router.callback_query(F.data == "wl:purchased_mode:days")
async def wishlist_set_purchased_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = get_db()
    category = db.get_wishlist_category_by_id(callback.from_user.id, int(category_id))
    if not category:
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "days")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ –¥–ª—è "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(IncomeSettingsState.waiting_for_percent)
async def income_percent_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    percent_str = data.get("percent_str", "0")
    display_chat_id = data.get("percent_display_chat_id", message.chat.id)
    display_message_id = data.get("percent_display_message_id")

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        LOGGER.info(
            "Percent input: user=%s scope=%s value=%s",
            message.from_user.id,
            data.get("edit_scope", "income"),
            percent_str,
        )
        try:
            await _safe_edit(message.bot, 
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await safe_send_message(message.bot, 
                chat_id=display_chat_id, text=f": {percent_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        percent_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º."
        else:
            if percent < 0 or percent > 100:
                error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 0‚Äì100."

        category_id = data.get("editing_category_id")
        if category_id is None:
            await state.set_state(None)
            await _cleanup_input_ui(
                message.bot,
                data,
                display_chat_key="percent_display_chat_id",
                display_message_key="percent_display_message_id",
            )
            await _remove_calculator_keyboard(message)
            await _render_previous_screen_or_exit(message, state)
            return

        if error_message is None:
            db = get_db()
            db.update_income_category_percent(message.from_user.id, category_id, percent)
            total = db.sum_income_category_percents(message.from_user.id)

            if total == 100:
                LOGGER.info(
                    "Percent saved: user=%s scope=%s category_id=%s value=%s",
                    message.from_user.id,
                    "income",
                    category_id,
                    percent,
                )
            else:
                error_message = f"–°—É–º–º–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ —Å–µ–π—á–∞—Å {total}%. –ù—É–∂–Ω–æ 100%."

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="percent_display_chat_id",
            display_message_key="percent_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        if error_message:
            await state.set_state(IncomeSettingsState.waiting_for_percent_category)
            await _render_income_percent_menu(
                state=state,
                message=message,
                db=get_db(),
                user_id=message.from_user.id,
                error_message=error_message,
            )
            return

        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_days)
async def wishlist_purchased_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    days_str = data.get("purchased_days_str", "0")
    display_chat_id = data.get("purchased_display_chat_id", message.chat.id)
    display_message_id = data.get("purchased_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {days_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        days_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 3650.",
                reply_markup=None,
            )
            return

        db = get_db()
        category_id = data.get("editing_wl_category_id")
        if category_id is not None:
            db.update_wishlist_category_purchased_days(
                message.from_user.id, int(category_id), days
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="purchased_display_chat_id",
            display_message_key="purchased_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen(
            "st:wishlist", message=message, state=state
        )


@router.message(BytSettingsState.waiting_for_max_defer_days)
async def byt_max_defer_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    days_str = data.get("byt_max_days_str", "0")
    display_chat_id = data.get("byt_max_display_chat_id", message.chat.id)
    display_message_id = data.get("byt_max_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {days_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        days_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 3650.",
                reply_markup=None,
            )
            return

        db = get_db()
        settings_row = db.get_user_settings(message.from_user.id)
        previous_days = settings_row.get("byt_defer_max_days")
        db.set_byt_defer_max_days(message.from_user.id, days)
        LOGGER.info(
            "Updated BYT defer max days for user %s: %s", message.from_user.id, days
        )
        previous_max = data.get("previous_byt_max_days")
        if previous_max is not None and previous_max != days:
            LOGGER.info(
                "Max defer days changed: user=%s from=%s to=%s",
                message.from_user.id,
                previous_max,
                days,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="byt_max_display_chat_id",
            display_message_key="byt_max_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
        )

@router.message(BytTimerState.waiting_for_hour, F.text.in_(PERCENT_INPUT_BUTTONS))
async def byt_timer_hour_input(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    hour_str = data.get("bt_hour_str", "0")
    display_chat_id = data.get("bt_hour_display_chat_id", message.chat.id)
    display_message_id = data.get("bt_hour_display_message_id")

    if text in PERCENT_DIGITS:
        hour_str = hour_str.lstrip("0") if hour_str != "0" else ""
        hour_str = f"{hour_str}{text}" or "0"
        try:
            await _safe_edit(message.bot, 
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {hour_str}",
            )
        except Exception:
            prompt = await safe_send_message(message.bot, chat_id=display_chat_id, text=f": {hour_str}")
            if prompt:
                display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_hour_str=hour_str,
            bt_hour_display_chat_id=display_chat_id,
            bt_hour_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        hour_str = "0"
        try:
            await _safe_edit(message.bot, 
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            prompt = await safe_send_message(message.bot, chat_id=display_chat_id, text=": 0")
            if prompt:
                display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_hour_str=hour_str,
            bt_hour_display_chat_id=display_chat_id,
            bt_hour_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            hour = int(hour_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        if hour < 0 or hour > 23:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ß–∞—Å—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å 0‚Äì23.",
                reply_markup=None,
            )
            return
        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="bt_hour_display_chat_id",
            display_message_key="bt_hour_display_message_id",
        )
        await state.set_state(BytTimerState.waiting_for_minute)
        await state.update_data(selected_hour=hour, bt_minute_str="0")
        await _set_current_screen(state, "bt:add_time_minute")
        prompt_message = await _send_and_register(
            message=message,
            state=state,
            text="–í–≤–µ–¥–∏ –ú–ò–ù–£–¢–´ (0‚Äì59)",
        )
        prompt = await _send_and_register(
            message=message,
            state=state,
            text=": 0",
            reply_markup=income_calculator_keyboard(),
        )
        await state.update_data(
            bt_min_prompt_chat_id=prompt_message.chat.id,
            bt_min_prompt_message_id=prompt_message.message_id,
            bt_min_display_chat_id=prompt.chat.id,
            bt_min_display_message_id=prompt.message_id,
        )

@router.message(BytTimerState.waiting_for_minute, F.text.in_(PERCENT_INPUT_BUTTONS))
async def byt_timer_minute_input(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    minute_str = data.get("bt_minute_str", "0")
    display_chat_id = data.get("bt_min_display_chat_id", message.chat.id)
    display_message_id = data.get("bt_min_display_message_id")

    if text in PERCENT_DIGITS:
        minute_str = minute_str.lstrip("0") if minute_str != "0" else ""
        minute_str = f"{minute_str}{text}" or "0"
        try:
            await _safe_edit(message.bot, 
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {minute_str}",
            )
        except Exception:
            prompt = await safe_send_message(message.bot, chat_id=display_chat_id, text=f": {minute_str}")
            if prompt:
                display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_minute_str=minute_str,
            bt_min_display_chat_id=display_chat_id,
            bt_min_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        minute_str = "0"
        try:
            await _safe_edit(message.bot, 
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            prompt = await safe_send_message(message.bot, chat_id=display_chat_id, text=": 0")
            if prompt:
                display_message_id = prompt.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            bt_minute_str=minute_str,
            bt_min_display_chat_id=display_chat_id,
            bt_min_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            minute = int(minute_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        if minute < 0 or minute > 59:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ú–∏–Ω—É—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å 0‚Äì59.",
                reply_markup=None,
            )
            return
        db = get_db()
        selected_hour = int(data.get("selected_hour", 0))
        db.add_byt_timer_time(message.from_user.id, selected_hour, minute)
        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="bt_min_display_chat_id",
            display_message_key="bt_min_display_message_id",
            prompt_chat_key="bt_min_prompt_chat_id",
            prompt_message_key="bt_min_prompt_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "byt:timer_menu"
        await render_settings_screen(previous_screen, message=message, state=state)


===== Bot/handlers/start.py =====

"""Handlers for start and cancel commands."""
import logging

from aiogram import F, Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from Bot.constants.ui import WELCOME_TEXT
from Bot.handlers.common import build_main_menu_for_user
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_cleanup_to_context,
    ui_render_screen,
    ui_safe_delete_message,
    ui_set_welcome_message,
)

LOGGER = logging.getLogger(__name__)

router = Router()


async def _handle_start_common(message: Message, state: FSMContext) -> None:
    """Shared start logic for /start and "–ü–æ–µ—Ö–∞–ª–∏–∏–∏" commands."""

    # –ü–†–ò–í–ï–¢–°–¢–í–ò–ï (PROTECTED)
    # –≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞—â–∏—â–µ–Ω–æ –∏ –ù–ï –¥–æ–ª–∂–Ω–æ —É–¥–∞–ª—è—Ç—å—Å—è –º–∞—Å—Å–æ–≤—ã–º–∏ —á–∏—Å—Ç–∫–∞–º–∏.
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–µ—â–µ–Ω–æ. –£–¥–∞–ª–µ–Ω–∏–µ –¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
    # –ø–æ—Å–ª–µ —è–≤–Ω–æ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    # DO_NOT_DELETE_WELCOME_WITHOUT_USER_CONFIRMATION
    await ui_set_welcome_message(message.bot, state, message.chat.id, WELCOME_TEXT)
    await ui_cleanup_to_context(
        message.bot,
        state,
        message.chat.id,
        "MAIN_MENU",
    )
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "USER=%s ACTION=START STATE=%s META=-",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
    )


@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext) -> None:
    """Handle /start command."""

    await ui_safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        log_context="cmd_start",
        state=state,
    )
    await _handle_start_common(message, state)


@router.message(F.text == "–ü–æ–µ—Ö–∞–ª–∏–∏–∏")
async def handle_poehali(message: Message, state: FSMContext) -> None:
    """Handle alternative start phrase."""

    await _handle_start_common(message, state)


@router.message(Command("cancel"))
async def cmd_cancel(message: Message, state: FSMContext) -> None:
    """Handle /cancel command."""

    await ui_cleanup_messages(message.bot, state, chat_id=message.chat.id)
    await state.clear()
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞. –í—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "USER=%s ACTION=CANCEL STATE=%s META=-",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
    )


@router.message(F.text == "‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")
async def back_to_main(message: Message, state: FSMContext) -> None:
    """Return user to main menu."""

    deleted = await ui_safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        log_context="back_to_main_user_msg",
        state=state,
    )
    LOGGER.info(
        "USER=%s ACTION=BACK_TO_MAIN_DELETE STATE=%s META=user_msg_deleted=%s",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
        str(deleted).lower(),
    )
    await ui_cleanup_to_context(
        message.bot,
        state,
        message.chat.id,
        "MAIN_MENU",
    )
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "USER=%s ACTION=BACK_TO_MAIN STATE=%s META=-",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
    )


===== Bot/handlers/wishlist.py =====

"""Handlers for wishlist flow."""

import asyncio
import logging
from collections import defaultdict
from datetime import datetime, time, timedelta
from typing import Optional

from aiogram import Bot, F, Router
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
    ReplyKeyboardRemove,
)

from Bot.database.crud import FinanceDatabase
from Bot.database.get_db import get_db
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import (
    back_only_keyboard,
    wishlist_categories_keyboard,
    wishlist_reply_keyboard,
    wishlist_url_keyboard,
)
