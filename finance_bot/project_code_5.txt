        return

    try:
        item_id = int(data[1])
    except ValueError:
        await safe_callback_answer(callback, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.", show_alert=True, logger=LOGGER)
        return

    db = get_db()
    wish = db.get_wish(item_id)
    if not wish or humanize_wishlist_category(wish.get("category", "")) != "–ë–´–¢":
        await safe_callback_answer(callback, "–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True, logger=LOGGER)
        return

    price = float(wish.get("price", 0) or 0)
    purchase_time = now_tz()
    db.decrease_savings(callback.from_user.id, "–±—ã—Ç", price)
    db.mark_wish_purchased(item_id, purchased_at=purchase_time)
    db.add_purchase(
        callback.from_user.id,
        wish.get("name", ""),
        price,
        humanize_wishlist_category(wish.get("category", "")),
        purchased_at=purchase_time,
    )

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.message:
        await _refresh_byt_reminder_message(
            callback.bot,
            callback.message.chat.id,
            callback.message.message_id,
            callback.from_user.id,
        )


@router.callback_query(F.data.startswith("byt_defer_menu"))
async def handle_byt_defer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    """Show BYT items to choose which to defer."""

    wish_id: int | None = None
    if callback.data and ":" in callback.data:
        parts = callback.data.split(":", maxsplit=1)
        if len(parts) == 2:
            try:
                wish_id = int(parts[1])
            except ValueError:
                wish_id = None
    if wish_id is None:
        data = await state.get_data()
        stored_id = data.get("current_byt_item_id")
        try:
            wish_id = int(stored_id) if stored_id is not None else None
        except (TypeError, ValueError):
            wish_id = None

    db = get_db()
    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await safe_callback_answer(callback, "–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö", show_alert=True, logger=LOGGER)
        return
    now_dt = now_tz()
    items = db.list_active_byt_items_for_reminder(callback.from_user.id, now_dt)
    if wish_id is not None:
        await state.update_data(current_byt_item_id=wish_id)
        started = await _start_byt_defer_flow(callback, state, wish_id)
        if not started:
            await state.clear()
        return
    if not items:
        await state.clear()
        if callback.message:
            await safe_answer(callback.message, "–ù–µ—Ç –±—ã—Ç–æ–≤—ã—Ö –ø–æ–∫—É–ø–æ–∫ –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏.", logger=LOGGER)
        else:
            await safe_send_message(
                callback.bot,
                chat_id=callback.from_user.id,
                text="–ù–µ—Ç –±—ã—Ç–æ–≤—ã—Ö –ø–æ–∫—É–ø–æ–∫ –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏.",
                logger=LOGGER,
            )
        await safe_callback_answer(callback, logger=LOGGER)
        return

    keyboard = _build_byt_defer_keyboard(items)
    await state.clear()
    if callback.message:
        edited = await safe_edit_message_text(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            text="–ß–¢–û?",
            reply_markup=keyboard,
            logger=LOGGER,
        )
        if not edited:
            await safe_answer(callback.message, "–ß–¢–û?", reply_markup=keyboard, logger=LOGGER)
    else:
        await safe_send_message(
            callback.bot,
            chat_id=callback.from_user.id,
            text="–ß–¢–û?",
            reply_markup=keyboard,
            logger=LOGGER,
        )
    await safe_callback_answer(callback, logger=LOGGER)


@router.callback_query(F.data.startswith("byt_defer_pick:"))
async def handle_byt_defer_pick(callback: CallbackQuery, state: FSMContext) -> None:
    """Start deferring selected BYT item."""

    data = callback.data.split(":", maxsplit=1)
    wish_id: int | None = None
    if len(data) == 2:
        try:
            wish_id = int(data[1])
        except ValueError:
            wish_id = None
    if wish_id is None:
        state_data = await state.get_data()
        try:
            wish_id = (
                int(state_data.get("defer_item_id"))
                if state_data.get("defer_item_id") is not None
                else None
            )
        except (TypeError, ValueError):
            wish_id = None
    if wish_id is None:
        await safe_callback_answer(callback, "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω item_id", show_alert=True, logger=LOGGER)
        return

    started = await _start_byt_defer_flow(callback, state, wish_id)
    if not started:
        await state.clear()


@router.message(
    BytDeferState.waiting_for_days,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "–û—á–∏—Å—Ç–∏—Ç—å",
            "‚úÖ –ì–∞–∑",
        }
    ),
)
async def handle_byt_defer_days(message: Message, state: FSMContext) -> None:
    """Handle calculator input for BYT defer days."""

    data = await state.get_data()
    current_sum = str(data.get("defer_days_str", "0"))
    display_chat_id = data.get("defer_display_chat_id", message.chat.id)
    display_message_id = data.get("defer_display_message_id")
    db = get_db()

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            LOGGER.warning(
                "BYT defer submit missing entered_days user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return
        try:
            days = int(amount_str)
        except (TypeError, ValueError):
            LOGGER.warning(
                "BYT defer submit invalid days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                amount_str,
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        if days <= 0:
            LOGGER.warning(
                "BYT defer submit non-positive days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                days,
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        try:
            settings_row = db.get_user_settings(message.from_user.id)
        except Exception as exc:
            LOGGER.error(
                "Failed to load user settings for BYT defer user_id=%s",
                message.from_user.id if message.from_user else "unknown",
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return
        max_days = int(settings_row.get("byt_defer_max_days", 365) or 365)
        if days < 1 or days > max_days:
            await message.answer(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ {max_days}.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        raw_defer_item_id = data.get("defer_item_id")
        try:
            defer_item_id = int(raw_defer_item_id) if raw_defer_item_id is not None else None
        except (TypeError, ValueError):
            defer_item_id = None
        if defer_item_id is None:
            LOGGER.warning(
                "BYT defer submit missing item_id user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("–ù–µ –≤—ã–±—Ä–∞–Ω —Ç–æ–≤–∞—Ä –¥–ª—è –æ—Ç—Å—Ä–æ—á–∫–∏.")
            await state.clear()
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return
        reminder_message_id = data.get("reminder_message_id")
        deferred_until = now_tz() + timedelta(days=days)

        try:
            db.set_wishlist_item_deferred_until(
                message.from_user.id, defer_item_id, deferred_until.isoformat()
            )
        except Exception as exc:
            LOGGER.error(
                "Failed to set BYT defer days user_id=%s item_id=%s days=%s",
                message.from_user.id if message.from_user else "unknown",
                defer_item_id,
                days,
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        await message.answer(
            f"–û—Ç–ª–æ–∂–µ–Ω–æ –Ω–∞ {days} –¥–Ω.", reply_markup=ReplyKeyboardRemove()
        )

        if reminder_message_id:
            await _refresh_byt_reminder_message(
                message.bot,
                message.chat.id,
                int(reminder_message_id),
                message.from_user.id,
            )

        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        new_display_message_id = prompt.message_id
        new_display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(BytDeferState.waiting_for_days)
async def handle_byt_defer_days_invalid(message: Message) -> None:
    """Prompt to use calculator buttons for defer days."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞ –Ω–∏–∂–µ.")


===== Bot/keyboards/__init__.py =====



===== Bot/keyboards/calculator.py =====

"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """–û–±—â–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Å—É–º–º."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å"),
            KeyboardButton(text="0"),
            KeyboardButton(text="‚úÖ –ì–∞–∑"),
        ],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


===== Bot/keyboards/household.py =====

"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="‚úÖ –î–∞"),
            KeyboardButton(text="‚ùå –ù–µ—Ç"),
            KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)


===== Bot/keyboards/main.py =====

"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")], [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


===== Bot/keyboards/settings.py =====

"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting household debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household payments settings."""

    inline_keyboard = [
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:add_payment")],
        [InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:del_payment_menu")],
        [InlineKeyboardButton(text="üîÑ –û–±–Ω—É–ª–∏—Ç—å", callback_data="hp:reset_questions")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_payments_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household payments in settings."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hp:del_payment:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for settings home screen."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="üìä –î–æ—Ö–æ–¥", callback_data="st:income"),
            InlineKeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç", callback_data="st:wishlist"),
        ],
        [InlineKeyboardButton(text="üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è", callback_data="st:byt_rules")],
        [InlineKeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏", callback_data="st:household_payments")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings home screen."""

    buttons = [
        [KeyboardButton(text="üìä –î–æ—Ö–æ–¥"), KeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç")],
        [KeyboardButton(text="üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è"), KeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:add_cat"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:del_cat_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –°—Ä–æ–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ", callback_data="wl:purchased_select_category"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for wishlist settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
        ],
        [KeyboardButton(text="üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_reply_keyboard(categories: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_purchased_mode_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist purchased mode."""

    buttons = [
        [KeyboardButton(text="–í—Å–µ–≥–¥–∞")],
        [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=category.get("title", ""),
            callback_data=f"{action_prefix}:{category.get('id')}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_purchased_mode_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist purchased mode."""

    inline_keyboard = [
        [InlineKeyboardButton(text="–í—Å–µ–≥–¥–∞", callback_data="wl:purchased_mode:always")],
        [InlineKeyboardButton(text="–ù–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π", callback_data="wl:purchased_mode:days")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT rules settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(
                text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="byt:toggle_enabled"
            ),
            InlineKeyboardButton(
                text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª", callback_data="byt:toggle_defer"
            ),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å", callback_data="byt:edit_max_defer_days"),
            InlineKeyboardButton(text="‚è∞ –¢–∞–π–º–µ—Ä", callback_data="byt:timer_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT rules settings."""

    buttons = [
        [
            KeyboardButton(text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª"),
        ],
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        ],
        [KeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT timer settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:add_time_hour"),
            InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:del_time_menu"),
        ],
        [
            InlineKeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é", callback_data="bt:reset_default"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT timer settings."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è"),
        ],
        [KeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_times_select_reply_keyboard(times: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT timer time."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_timer_times_select_keyboard(times: list[dict], action_prefix: str) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer time."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(
            InlineKeyboardButton(text=label, callback_data=f"{action_prefix}:{timer.get('id')}")
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_back_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with a single back button for settings mode."""

    buttons = [[KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for income settings actions."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:add"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:del_menu"),
        ],
        [
            InlineKeyboardButton(text="‚úèÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã", callback_data="inc:pct_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def income_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for income settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
        ],
        [KeyboardButton(text="‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_categories_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting income category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        title = category.get("title", "")
        percent = category.get("percent", 0)
        row.append(KeyboardButton(text=f"{title} ‚Äî {percent}%"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def income_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting an income category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=f"{category['title']} ({category['percent']}%)",
            callback_data=f"{action_prefix}:{category['id']}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_stub_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for stub sections with back button."""

    return InlineKeyboardMarkup(inline_keyboard=[])


===== Bot/main.py =====

"""Entry point for finance bot."""
import asyncio
import contextlib
import logging
import sys
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramUnauthorizedError

from Bot.config.settings import get_settings
from Bot.database.get_db import get_db
from Bot.handlers import (
    callbacks,
    common,
    finances,
    household_payments,
    settings,
    start,
    wishlist,
)
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.logging import init_logging


def register_routers(dispatcher: Dispatcher) -> None:
    """Register all routers to dispatcher."""

    dispatcher.include_router(start.router)
    dispatcher.include_router(finances.router)
    dispatcher.include_router(household_payments.router)
    dispatcher.include_router(settings.router)
    dispatcher.include_router(wishlist.router)
    dispatcher.include_router(callbacks.router)
    dispatcher.include_router(common.router)


def _token_fingerprint(token: str) -> str:
    if not token:
        return "empty"
    if len(token) <= 8:
        return f"{token[:2]}‚Ä¶{token[-2:]}"
    return f"{token[:4]}‚Ä¶{token[-4:]}"


def _validate_token(token: str) -> list[str]:
    if not token.strip():
        return ["BOT_TOKEN –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω"]

    errors = []
    if ":" not in token:
        errors.append("BOT_TOKEN –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ —Ç–æ–∫–µ–Ω (–Ω–µ—Ç ':')")
    if len(token) < 20:
        errors.append("BOT_TOKEN —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–æ–∂–∏–¥–∞–µ—Ç—Å—è > 20 —Å–∏–º–≤–æ–ª–æ–≤)")
    return errors


def _format_token_context(token_source: str, fingerprint: str, env_path: Path) -> str:
    if token_source == ".env":
        return f"token_source={token_source}, fingerprint={fingerprint}, env_path={env_path}"
    return f"token_source={token_source}, fingerprint={fingerprint}"


async def _run_byt_scheduler(bot: Bot, db, timezone: ZoneInfo) -> None:
    """Background scheduler for BYT reminders."""

    while True:
        now = datetime.now(tz=timezone)
        user_ids = set(db.get_users_with_byt_timer_times()) | set(
            db.get_users_with_active_byt_wishes()
        )
        for uid in user_ids:
            await run_byt_timer_check(bot, db, user_id=uid, run_time=now)
        sleep_for = 60 - now.second - now.microsecond / 1_000_000
        await asyncio.sleep(max(sleep_for, 1))


async def main() -> None:
    """Run bot polling."""

    init_logging()
    settings = get_settings()
    logger = logging.getLogger(__name__)
    token = (settings.bot_token or "").strip()
    token_source = settings.bot_token_source
    fingerprint = _token_fingerprint(token)
    token_context = _format_token_context(token_source, fingerprint, project_root / ".env")

    errors = _validate_token(token)
    for error in errors:
        logger.error("%s (%s)", error, token_context)
    if errors:
        return

    bot = Bot(
        token=token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher()

    db = get_db()
    register_routers(dp)

    try:
        await bot.me()
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
        await bot.session.close()
        return

    reminder_task = asyncio.create_task(
        _run_byt_scheduler(bot, db, settings.timezone)
    )
    try:
        logger.info(
            "Starting bot polling (%s)",
            token_context,
        )
        await dp.start_polling(bot)
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
    except Exception as error:  # noqa: BLE001
        logger.exception("Bot stopped due to error: %s", error)
    finally:
        reminder_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await reminder_task
        await bot.session.close()
        logger.info("Bot shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())


===== Bot/renderers/__init__.py =====

"""Renderer layer package."""


===== Bot/renderers/household.py =====

"""Renderers for household payments UI."""
from __future__ import annotations

import html
from typing import Dict, List

from aiogram.types import InlineKeyboardMarkup

from Bot.keyboards.household import household_payments_inline_keyboard


def render_household_questions_text(
    month: str,
    questions: list[dict],
    answers: dict[str, str],
    current_index: int | None,
) -> str:
    header = f"<b>–ë–´–¢–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò ‚Äî {html.escape(month)}</b>"
    lines = [header]
    for index, question in enumerate(questions, start=1):
        code = str(question.get("code", ""))
        text = html.escape(str(question.get("text", "")).strip())
        text = text.rstrip("?").strip()
        suffix = ""
        answer = answers.get(code)
        if answer == "yes":
            suffix = " ‚úÖ"
        elif answer == "no":
            suffix = " ‚ùå"
        display = text
        if current_index is not None and index - 1 == current_index:
            display = f"<b>{display.upper()}</b>"
        lines.append(f"{index}) {display}{suffix}")
    return "\n".join(lines)


def format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    if not items:
        return "–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π: (–ø—É—Å—Ç–æ)"

    lines = ["–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π:"]
    for index, item in enumerate(items, start=1):
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        code = str(item.get("code", ""))
        status = "‚ùå" if code in unpaid_set else "‚úÖ"
        if amount is not None:
            lines.append(f"{index}) {status} {title} ‚Äî {amount}")
        else:
            lines.append(f"{index}) {status} {title}")
    return "\n".join(lines)


def build_household_question_keyboard(
    question_code: str | None, show_back: bool
) -> InlineKeyboardMarkup:
    return household_payments_inline_keyboard(
        show_back=show_back, question_code=question_code
    )


===== Bot/services/__init__.py =====

"""Service layer package."""


===== Bot/services/household.py =====

"""Business logic for household payments flow."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable


@dataclass
class HouseholdFlowState:
    """Container for household flow state."""

    month: str
    questions: list[dict]
    current_step_index: int
    current_question_code: str | None
    answers: dict[str, str]
    processed_steps: set[str]


def build_household_questions(items: Iterable[dict]) -> list[dict]:
    return [
        {
            "code": str(item.get("code", "")),
            "text": str(item.get("text", "")),
            "amount": item.get("amount"),
        }
        for item in items
        if item.get("code") is not None
    ]


def build_answers_from_status(status_map: dict[str, int]) -> dict[str, str]:
    return {
        str(code): "yes"
        for code, value in status_map.items()
        if int(value) == 1
    }


def filter_unpaid_questions(
    questions: Iterable[dict], unpaid_codes: Iterable[str]
) -> list[dict]:
    unpaid_set = {str(code) for code in unpaid_codes}
    return [question for question in questions if question.get("code") in unpaid_set]


def get_current_question(questions: list[dict], index: int) -> dict | None:
    if index < 0 or index >= len(questions):
        return None
    return questions[index]


def get_next_index(index: int, questions: list[dict]) -> int:
    return min(index + 1, len(questions))


def get_previous_index(index: int) -> int:
    return max(index - 1, 0)


def should_ignore_answer(
    answers: dict[str, str],
    processed_steps: set[str],
    question_code: str,
    action: str,
) -> bool:
    return question_code in processed_steps and answers.get(question_code) == action


def normalize_processed_steps(value: Iterable[str] | None) -> set[str]:
    if not value:
        return set()
    return {str(item) for item in value}


def update_flow_state(
    month: str,
    questions: list[dict],
    current_step_index: int,
    answers: dict[str, str] | None,
    processed_steps: Iterable[str] | None,
) -> HouseholdFlowState:
    current_question = get_current_question(questions, current_step_index)
    return HouseholdFlowState(
        month=month,
        questions=questions,
        current_step_index=current_step_index,
        current_question_code=str(current_question.get("code"))
        if current_question
        else None,
        answers=dict(answers or {}),
        processed_steps=normalize_processed_steps(processed_steps),
    )


===== Bot/states/__init__.py =====



===== Bot/states/money_states.py =====

"""FSM states for money flow."""
from aiogram.fsm.state import State, StatesGroup


class MoneyState(StatesGroup):
    """State machine for income distribution."""

    waiting_for_amount = State()
    confirm_category = State()
    waiting_for_purchase_confirmation = State()


class HouseholdPaymentsState(StatesGroup):
    """State machine for household payments flow."""

    waiting_for_answer = State()


class HouseholdSettingsState(StatesGroup):
    """State machine for household payments settings."""

    waiting_for_title = State()
    waiting_for_amount = State()
    waiting_for_removal = State()
    waiting_for_debit_category = State()


class IncomeSettingsState(StatesGroup):
    """State machine for income settings."""

    waiting_for_category_title = State()
    waiting_for_new_category_percent = State()
    waiting_for_removal = State()
    waiting_for_percent_category = State()
    waiting_for_percent = State()


===== Bot/states/wishlist_states.py =====

"""FSM states for wishlist."""
from aiogram.fsm.state import State, StatesGroup


class WishlistState(StatesGroup):
    """State machine for wishlist management."""

    waiting_for_name = State()
    waiting_for_price = State()
    waiting_for_url = State()
    waiting_for_category = State()


class WishlistBytReminderState(StatesGroup):
    """State machine for BYT reminder flow."""

    waiting_answer = State()


class BytDeferState(StatesGroup):
    """State machine for deferring BYT wishlist items."""

    waiting_for_days = State()


class WishlistSettingsState(StatesGroup):
    """States for wishlist settings inputs."""

    waiting_for_category_title = State()
    waiting_for_removal = State()
    waiting_for_purchased_category = State()
    waiting_for_purchased_mode = State()
    waiting_for_purchased_days = State()


class BytSettingsState(StatesGroup):
    """States for BYT settings inputs."""

    waiting_for_max_defer_days = State()


class BytTimerState(StatesGroup):
    """States for BYT timer settings inputs."""

    waiting_for_removal = State()
    waiting_for_time_add = State()
    waiting_for_hour = State()
    waiting_for_minute = State()


===== Bot/utils/__init__.py =====



===== Bot/utils/datetime_utils.py =====

"""Datetime utilities for the bot."""
from datetime import datetime, timedelta

from Bot.config import settings


def now_tz() -> datetime:
    """Return current datetime in configured timezone."""

    return datetime.now(tz=settings.TIMEZONE)


def current_month_str(now: datetime | None = None) -> str:
    """Return current month label as YYYY-MM using configured timezone."""

    current = now or now_tz()
    return f"{current.year:04d}-{current.month:02d}"


def add_one_month(source: datetime) -> datetime:
    """Add one calendar month to datetime without external dependencies."""

    year = source.year + (source.month // 12)
    month = 1 if source.month == 12 else source.month + 1
    last_day = (
        (source.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    ).day
    day = min(source.day, last_day)
    return source.replace(year=year, month=month, day=day)


===== Bot/utils/logging.py =====

"""Logging utilities."""
import logging

from Bot.config.logging_config import setup_logging


def init_logging() -> logging.Logger:
    """Initialize logging and return module logger.

    Returns:
        logging.Logger: Configured logger instance.
    """

    setup_logging()
    return logging.getLogger(__name__)


===== Bot/utils/savings.py =====

"""Savings utility helpers."""
from typing import Any, Dict, List, Tuple


def _fallback_humanize_category(category: str) -> str:
    name = str(category)
    if name.startswith("savings_"):
        name = name[len("savings_") :]
    name = name.replace("_", " ").strip()
    return name or str(category)


def format_savings_summary(
    savings: Dict[str, Dict[str, Any]],
    categories_map: Dict[str, str] | None = None,
) -> str:
    """Format savings summary for user message."""

    if not savings:
        return "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π."

    lines: List[str] = []
    for category, data in savings.items():
        display_name = None
        if categories_map is not None:
            display_name = categories_map.get(str(category))
        if not display_name:
            display_name = _fallback_humanize_category(str(category))
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        purpose = data.get("purpose", "")
        line = f"{display_name}: {current:.2f}"
        if goal and goal > 0:
            progress = min(current / goal * 100, 100)
            extra = f" (—Ü–µ–ª—å {goal:.2f} –¥–ª—è '{purpose}', –ø—Ä–æ–≥—Ä–µ—Å—Å {progress:.1f}%)"
            line = f"{line}{extra}"
        lines.append(line)
    return "\n".join(lines)


def find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> Tuple[str, Dict[str, Any]] | Tuple[None, None]:
    """Find first saving goal that has been reached."""

    for category, data in savings.items():
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        if goal and current >= goal:
            return category, data
    return None, None


===== Bot/utils/telegram_safe.py =====

"""Safe wrappers for Telegram API operations."""
from __future__ import annotations

import asyncio
import logging

from aiohttp import ClientConnectionError, ClientOSError
from aiogram.exceptions import TelegramBadRequest, TelegramNetworkError
from aiogram.types import ReplyKeyboardMarkup, ReplyKeyboardRemove

LOGGER = logging.getLogger(__name__)

DEFAULT_REQUEST_TIMEOUT = 30


def _get_logger(logger: logging.Logger | None) -> logging.Logger:
    return logger or LOGGER


def _is_network_error(exc: Exception) -> bool:
    return isinstance(
        exc,
        (
            TelegramNetworkError,
            ClientOSError,
            ClientConnectionError,
            asyncio.TimeoutError,
            TimeoutError,
        ),
    )


def _log_network_error(
    logger: logging.Logger,
    action: str,
    exc: Exception,
    attempt: int,
    retries: int,
) -> None:
    logger.warning(
        "NETWORK_RETRY action=%s attempt=%s/%s error=%s",
        action,
        attempt,
        retries + 1,
        exc,
    )
    if logger.isEnabledFor(logging.DEBUG):
        logger.debug("Network error details for %s", action, exc_info=True)


async def safe_delete_message(
    bot,
    chat_id: int,
    message_id: int,
    *,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> bool:
    """Safely delete a message without raising exceptions."""

    log = _get_logger(logger)
    for attempt in range(retries + 1):
        try:
            await bot.delete_message(
                chat_id=chat_id,
                message_id=message_id,
                request_timeout=request_timeout,
            )
            return True
        except TelegramBadRequest as exc:
            text = str(exc).lower()
            if (
                "message to delete not found" in text
                or "message can't be deleted" in text
                or "message can‚Äôt be deleted" in text
            ):
                log.debug(
                    "Safe delete skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False
            log.warning(
                "Safe delete failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe delete failure details", exc_info=True)
            return False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "delete_message", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False
            log.warning(
                "Safe delete unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe delete unexpected error details", exc_info=True)
            return False
    return False


async def safe_edit_message_text(
    bot,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> bool:
    """Safely edit a message text without raising exceptions."""

    log = _get_logger(logger)
    if isinstance(reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)):
        log.warning("Safe edit skipped due to reply keyboard markup")
        return False

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False
            log.warning(
                "Safe edit unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit unexpected error details", exc_info=True)
            return False
    return False


async def safe_edit_message_text_with_status(
    bot,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> tuple[bool, bool]:
    """Safely edit a message text, reporting network failures."""

    log = _get_logger(logger)
    if isinstance(reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)):
        log.warning("Safe edit skipped due to reply keyboard markup")
        return False, False

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True, False
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True, False
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False, False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False, False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False, True
            log.warning(
                "Safe edit unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit unexpected error details", exc_info=True)
            return False, False
    return False, False


async def safe_send_message(
    bot,
    chat_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
):
    """Safely send a message using bot.send_message without raising exceptions."""

    log = _get_logger(logger)
    for attempt in range(retries + 1):
        try:
            return await bot.send_message(
                chat_id=chat_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
        except TelegramBadRequest as exc:
            log.warning("Safe send failed: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe send failure details", exc_info=True)
            return None
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "send_message", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return None
            log.warning("Safe send unexpected error: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe send unexpected error details", exc_info=True)
            return None
    return None


async def safe_answer(
    message_or_callback,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> int | None:
    """Safely send a message using .answer without raising exceptions."""

    log = _get_logger(logger)
    for attempt in range(retries + 1):
        try:
            sent = await message_or_callback.answer(
                text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return int(sent.message_id)
        except TelegramBadRequest as exc:
            log.warning("Safe answer failed: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe answer failure details", exc_info=True)
            return None
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "answer", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return None
            log.warning("Safe answer unexpected error: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe answer unexpected error details", exc_info=True)
            return None
    return None


async def safe_callback_answer(
    callback,
    text: str | None = None,
    *,
    show_alert: bool | None = None,
    logger: logging.Logger | None = None,
) -> None:
    """Safely answer a callback query without raising exceptions."""

    log = _get_logger(logger)
    try:
        await callback.answer(text=text, show_alert=show_alert)
    except Exception as exc:  # noqa: BLE001
        if _is_network_error(exc):
            log.warning("Safe callback answer failed due to network error: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe callback answer network details", exc_info=True)
            return
        log.warning("Safe callback answer unexpected error: %s", exc)
        if log.isEnabledFor(logging.DEBUG):
            log.debug("Safe callback answer unexpected error details", exc_info=True)


===== Bot/utils/text_sanitizer.py =====

"""Text sanitizers for user-facing labels."""
from __future__ import annotations

import re


_TAIL_PATTERNS = [
    r"–Ω–∞\s+—Ç–∏–Ω—å–∫",
    r"–Ω–∞\s+–∞–ª—å—Ñ—É",
    r"–Ω–∞\s+—Å–±–µ—Ä",
    r"–Ω–∞\s+—è–Ω–¥–µ–∫—Å",
]


def sanitize_income_title(text: str) -> str:
    value = str(text or "")
    for pattern in _TAIL_PATTERNS:
        value = re.sub(rf"\s*(?:‚Äî|-|:)?\s*{pattern}", "", value, flags=re.IGNORECASE)
    value = re.sub(r"\s*\(\s*–æ–∑–æ–Ω\s*\)", "", value, flags=re.IGNORECASE)
    value = re.sub(r"\(\s*\)", "", value)
    value = re.sub(r"\s{2,}", " ", value)
    return value.strip(" -‚Äî:\t\n")


===== Bot/utils/ui_cleanup.py =====

import logging
from typing import List

from aiogram import Bot
from aiogram.types import ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.fsm.context import FSMContext

from Bot.database.get_db import get_db
from Bot.utils.telegram_safe import (
    safe_delete_message,
    safe_edit_message_text,
    safe_send_message,
)

LOGGER = logging.getLogger(__name__)


async def ui_register_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Track a UI message id for later cleanup."""

    data = await state.get_data()
    ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    if message_id not in ids:
        ids.append(int(message_id))
    if len(ids) > 300:
        ids = ids[-300:]
    current_chat_id = data.get("ui_chat_id")
    await state.update_data(
        ui_chat_id=current_chat_id if current_chat_id is not None else chat_id,
        ui_tracked_message_ids=ids,
    )


async def ui_register_protected_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    """Track a UI message id that should never be deleted."""

    data = await state.get_data()
    ids: List[int] = list(data.get("ui_protected_message_ids") or [])
    if message_id not in ids:
        ids.append(int(message_id))
    if len(ids) > 300:
        ids = ids[-300:]
    current_chat_id = data.get("ui_chat_id")
    await state.update_data(
        ui_chat_id=current_chat_id if current_chat_id is not None else chat_id,
        ui_protected_message_ids=ids,
    )


async def ui_register_user_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Do not track user messages for later cleanup."""

    data = await state.get_data()
    if data.get("ui_chat_id") is None:
        await state.update_data(ui_chat_id=chat_id)


async def ui_safe_delete_message(
    bot: Bot,
    chat_id: int,
    message_id: int,
    log_context: str | None = None,
) -> bool:
    return await safe_delete_message(
        bot,
        chat_id=chat_id,
        message_id=message_id,
        logger=LOGGER,
    )


async def ui_get_welcome_id(state: FSMContext) -> int | None:
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    return int(welcome_id) if welcome_id is not None else None


async def ui_set_welcome_id(
    state: FSMContext, message_id: int, chat_id: int | None = None
) -> None:
    update = {"ui_welcome_message_id": int(message_id)}
    if chat_id is not None:
        update["ui_chat_id"] = int(chat_id)
    await state.update_data(**update)


async def ui_set_welcome_message(
    bot: Bot, state: FSMContext, chat_id: int, text: str
) -> int:
    welcome_id = await ui_get_welcome_id(state)
    if welcome_id is not None:
        edited = await safe_edit_message_text(
            bot,
            chat_id=chat_id,
            message_id=int(welcome_id),
            text=text,
            logger=LOGGER,
        )
        if edited:
            LOGGER.info("WELCOME reused (chat_id=%s, message_id=%s)", chat_id, welcome_id)
            return int(welcome_id)

    if welcome_id is None:
        db = get_db()
        persisted = db.get_welcome_message_id(chat_id)
        if persisted is not None:
            await ui_set_welcome_id(state, int(persisted), chat_id=chat_id)
            LOGGER.info("WELCOME reused (chat_id=%s, message_id=%s)", chat_id, persisted)
            return int(persisted)

    sent = await safe_send_message(bot, chat_id=chat_id, text=text, logger=LOGGER)
    if sent:
        await ui_set_welcome_id(state, int(sent.message_id), chat_id=chat_id)
        get_db().set_welcome_message_id(chat_id, int(sent.message_id))
        LOGGER.info("WELCOME created (chat_id=%s, message_id=%s)", chat_id, sent.message_id)
        return int(sent.message_id)
    return 0


async def ui_set_settings_mode_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_set_screen_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)
    await state.update_data(ui_screen_message_id=int(message_id), ui_chat_id=chat_id)


async def ui_track_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_cleanup_to_context(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    context_name: str,
    keep_ids: List[int] | None = None,
