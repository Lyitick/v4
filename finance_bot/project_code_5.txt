        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 3650.",
                reply_markup=None,
            )
            return

        db = get_db()
        category_id = data.get("editing_wl_category_id")
        if category_id is not None:
            db.update_wishlist_category_purchased_days(
                message.from_user.id, int(category_id), days
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="purchased_display_chat_id",
            display_message_key="purchased_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen(
            "st:wishlist", message=message, state=state
        )


@router.message(BytSettingsState.waiting_for_max_defer_days)
async def byt_max_defer_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text not in PERCENT_INPUT_BUTTONS:
        chat_id, message_id = await _get_settings_message_ids(state, message)
        await _edit_settings_page(
            bot=message.bot,
            state=state,
            chat_id=chat_id,
            message_id=message_id,
            text="–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞.",
            reply_markup=None,
        )
        return

    days_str = data.get("byt_max_days_str", "0")
    display_chat_id = data.get("byt_max_display_chat_id", message.chat.id)
    display_message_id = data.get("byt_max_display_message_id")

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {days_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        days_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        try:
            days = int(days_str or "0")
        except ValueError:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π.",
                reply_markup=None,
            )
            return
        if days < 1 or days > 3650:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 3650.",
                reply_markup=None,
            )
            return

        db = get_db()
        settings_row = db.get_user_settings(message.from_user.id)
        previous_days = settings_row.get("byt_defer_max_days")
        db.set_byt_defer_max_days(message.from_user.id, days)
        LOGGER.info(
            "Updated BYT defer max days for user %s: %s", message.from_user.id, days
        )
        previous_max = data.get("previous_byt_max_days")
        if previous_max is not None and previous_max != days:
            LOGGER.info(
                "Max defer days changed: user=%s from=%s to=%s",
                message.from_user.id,
                previous_max,
                days,
            )

        await _cleanup_input_ui(
            message.bot,
            data,
            display_chat_key="byt_max_display_chat_id",
            display_message_key="byt_max_display_message_id",
        )
        await _remove_calculator_keyboard(message)
        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:byt_rules"
        await render_settings_screen(
            previous_screen,
            message=message,
            state=state,
        )

===== Bot/handlers/start.py =====

"""Handlers for start and cancel commands."""
import logging

from aiogram import F, Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from Bot.constants.ui import WELCOME_TEXT
from Bot.handlers.common import build_main_menu_for_user
from Bot.utils.ui_cleanup import (
    ui_cleanup_messages,
    ui_cleanup_to_context,
    ui_render_screen,
    ui_safe_delete_message,
    ui_set_welcome_message,
)

LOGGER = logging.getLogger(__name__)

router = Router()


async def _handle_start_common(message: Message, state: FSMContext) -> None:
    """Shared start logic for /start and "–ü–æ–µ—Ö–∞–ª–∏–∏–∏" commands."""

    # –ü–†–ò–í–ï–¢–°–¢–í–ò–ï (PROTECTED)
    # –≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞—â–∏—â–µ–Ω–æ –∏ –ù–ï –¥–æ–ª–∂–Ω–æ —É–¥–∞–ª—è—Ç—å—Å—è –º–∞—Å—Å–æ–≤—ã–º–∏ —á–∏—Å—Ç–∫–∞–º–∏.
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–µ—â–µ–Ω–æ. –£–¥–∞–ª–µ–Ω–∏–µ –¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
    # –ø–æ—Å–ª–µ —è–≤–Ω–æ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    # DO_NOT_DELETE_WELCOME_WITHOUT_USER_CONFIRMATION
    await ui_set_welcome_message(message.bot, state, message.chat.id, WELCOME_TEXT)
    await ui_cleanup_to_context(
        message.bot,
        state,
        message.chat.id,
        "MAIN_MENU",
    )
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "USER=%s ACTION=START STATE=%s META=-",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
    )


@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext) -> None:
    """Handle /start command."""

    await ui_safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        log_context="cmd_start",
        state=state,
    )
    await _handle_start_common(message, state)


@router.message(F.text == "–ü–æ–µ—Ö–∞–ª–∏–∏–∏")
async def handle_poehali(message: Message, state: FSMContext) -> None:
    """Handle alternative start phrase."""

    await _handle_start_common(message, state)


@router.message(Command("cancel"))
async def cmd_cancel(message: Message, state: FSMContext) -> None:
    """Handle /cancel command."""

    await ui_cleanup_messages(message.bot, state, chat_id=message.chat.id)
    await state.clear()
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞. –í—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é.",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "USER=%s ACTION=CANCEL STATE=%s META=-",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
    )


@router.message(F.text.in_({"‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é", "üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é"}))
async def back_to_main(message: Message, state: FSMContext) -> None:
    """Return user to main menu."""

    deleted = await ui_safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        log_context="back_to_main_user_msg",
        state=state,
    )
    LOGGER.info(
        "USER=%s ACTION=BACK_TO_MAIN_DELETE STATE=%s META=user_msg_deleted=%s",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
        str(deleted).lower(),
    )
    await ui_cleanup_to_context(
        message.bot,
        state,
        message.chat.id,
        "MAIN_MENU",
    )
    await ui_render_screen(
        message.bot,
        state,
        message.chat.id,
        "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    LOGGER.info(
        "USER=%s ACTION=BACK_TO_MAIN STATE=%s META=-",
        message.from_user.id if message.from_user else "unknown",
        await state.get_state(),
    )

===== Bot/handlers/wishlist.py =====

"""Handlers for wishlist flow."""

import asyncio
import logging
from collections import defaultdict
from datetime import datetime, time, timedelta
from typing import Optional

from aiogram import Bot, F, Router
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
    ReplyKeyboardRemove,
)

from Bot.database.crud import FinanceDatabase
from Bot.database.get_db import get_db
from Bot.handlers.common import build_main_menu_for_user
from Bot.keyboards.main import (
    back_only_keyboard,
    wishlist_categories_keyboard,
    wishlist_reply_keyboard,
    wishlist_url_keyboard,
)
from Bot.keyboards.calculator import income_calculator_keyboard
from Bot.states.wishlist_states import BytDeferState, WishlistState
from Bot.utils.datetime_utils import get_next_reminder_dt, now_tz, resolve_deferred_until
from Bot.utils.byt_render import (
    format_byt_category_checklist_text,
    format_byt_defer_confirmation_text,
    get_byt_category_items,
    parse_deferred_until,
)
from Bot.utils.telegram_safe import (
    safe_answer,
    safe_callback_answer,
    safe_delete_message,
    safe_edit_message_text,
    safe_send_message,
)
from Bot.utils.ui_cleanup import ui_register_message, ui_register_user_message

LOGGER = logging.getLogger(__name__)

router = Router()


async def _push_wl_step(state: FSMContext, step: str) -> None:
    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    if not stack or stack[-1] != step:
        stack.append(step)
    await state.update_data(wl_add_step_stack=stack)


async def _set_wl_steps(state: FSMContext, steps: list[str]) -> None:
    await state.update_data(wl_add_step_stack=steps)


async def delete_welcome_message_if_exists(message: Message, state: FSMContext) -> None:
    """Legacy no-op to keep compatibility when welcome cleanup is referenced."""

    return None

def humanize_wishlist_category(category: str) -> str:
    """Return user-facing category name supporting legacy BYT values."""

    if category == "byt":
        return "–ë–´–¢"
    return category


def _get_user_wishlist_categories(db: FinanceDatabase, user_id: int) -> list[dict]:
    """Return active wishlist categories."""

    return db.list_active_wishlist_categories(user_id)


def _resolve_wish_category(
    db: FinanceDatabase, user_id: int, wish: dict
) -> tuple[int | None, str]:
    category_title = str(wish.get("category", "")).strip()
    if not category_title:
        return None, "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    category_row = db.get_wishlist_category_by_title(user_id, category_title)
    if category_row:
        return int(category_row.get("id")), str(category_row.get("title", category_title))
    return None, category_title


@router.message(F.text == "üìã –í–∏—à–ª–∏—Å—Ç")
async def open_wishlist(message: Message, state: FSMContext) -> None:
    """Open wishlist menu."""

    await delete_welcome_message_if_exists(message, state)
    await ui_register_user_message(state, message.chat.id, message.message_id)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )
    await state.clear()
    db = get_db()
    wishes = db.get_wishes_by_user(message.from_user.id)
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    has_active_wishes = any(not wish.get("is_purchased") for wish in wishes)

    if not categories:
        await message.answer(
            "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ–∫–∞ –Ω–µ—Ç. –î–æ–±–∞–≤—å –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
            reply_markup=wishlist_reply_keyboard(),
        )
        LOGGER.info(
            "User %s opened wishlist without categories",
            message.from_user.id if message.from_user else "unknown",
        )
        return

    if not has_active_wishes:
        await message.answer(
            "–í —Ç–≤–æ—ë–º –≤–∏—à–ª–∏—Å—Ç–µ –ø–æ–∫–∞ –ø—É—Å—Ç–æ.\n–î–∞–≤–∞–π –¥–æ–±–∞–≤–∏–º —á—Ç–æ-—Ç–æ –Ω–æ–≤–æ–µ –≤ –Ω–∞—à–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚ú®",
            reply_markup=wishlist_reply_keyboard(),
        )
        LOGGER.info("User %s opened empty wishlist", message.from_user.id if message.from_user else "unknown")
        return

    await message.answer("–†–∞–∑–¥–µ–ª –≤–∏—à–ª–∏—Å—Ç–∞.", reply_markup=wishlist_reply_keyboard())
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–ª–∏ –¥–æ–±–∞–≤—å –Ω–æ–≤–æ–µ –∂–µ–ª–∞–Ω–∏–µ.",
        reply_markup=wishlist_categories_keyboard(categories),
    )
    LOGGER.info("User %s opened wishlist", message.from_user.id if message.from_user else "unknown")


@router.message(F.text.in_({"‚ûï", "+"}))
async def add_wish_start(message: Message, state: FSMContext) -> None:
    """Start adding wish."""

    await state.set_state(WishlistState.waiting_for_name)
    await _set_wl_steps(state, ["name"])
    await message.answer(
        "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–µ–ª–∞–Ω–∏—è.",
        reply_markup=back_only_keyboard(),
    )

@router.message(WishlistState.waiting_for_name, F.text != "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_name(message: Message, state: FSMContext) -> None:
    """Save wish name and request price."""

    await state.update_data(name=message.text)
    await state.set_state(WishlistState.waiting_for_price)
    await _push_wl_step(state, "amount")

    question = await message.answer(
        "–í–≤–µ–¥–∏ —Ü–µ–Ω—É (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
        reply_markup=income_calculator_keyboard(),
    )
    prompt = await message.answer(": 0")

    await state.update_data(
        price_sum="0",
        price_question_message_id=question.message_id,
        price_message_id=prompt.message_id,
    )


@router.message(
    WishlistState.waiting_for_price,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "–û—á–∏—Å—Ç–∏—Ç—å",
            "‚úÖ –ì–∞–∑",
        }
    ),
)
async def add_wish_price_calc(message: Message, state: FSMContext) -> None:
    """Handle price input via calculator buttons."""

    data = await state.get_data()
    current_sum = str(data.get("price_sum", "0"))
    price_message_id = data.get("price_message_id")

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        normalized = amount_str.replace(",", ".")
        try:
            price = float(normalized)
        except (TypeError, ValueError):
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        if price <= 0:
            await message.answer("–¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        await state.update_data(price=price)
        await state.set_state(WishlistState.waiting_for_url)
        await _push_wl_step(state, "pre_url")
        await message.answer("–¥–∞–π", reply_markup=back_only_keyboard())
        await _push_wl_step(state, "url")
        await message.answer("—Å—Å—ã–ª–æ—á–∫—É", reply_markup=wishlist_url_keyboard())

        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    if price_message_id:
        await safe_edit_message_text(
            message.bot,
            chat_id=message.chat.id,
            message_id=price_message_id,
            text=f": {new_sum}",
            logger=LOGGER,
        )

    await state.update_data(price_sum=new_sum, price_message_id=price_message_id)

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(WishlistState.waiting_for_url, F.text != "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_url(message: Message, state: FSMContext) -> None:
    """Save URL and request category selection."""

    text = message.text.strip() if message.text else ""
    url: Optional[str] = None if text in {"-", ""} else text
    await state.update_data(url=url)
    await state.set_state(WishlistState.waiting_for_category)
    await _push_wl_step(state, "category")
    db = get_db()
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    if not categories:
        await message.answer(
            "–ö–∞—Ç–µ–≥–æ—Ä–∏–π –≤–∏—à–ª–∏—Å—Ç–∞ –ø–æ–∫–∞ –Ω–µ—Ç. –î–æ–±–∞–≤—å –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
            reply_markup=wishlist_reply_keyboard(),
        )
        await state.clear()
        return
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∂–µ–ª–∞–Ω–∏—è.", reply_markup=wishlist_categories_keyboard(categories)
    )
    await message.answer("–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.", reply_markup=back_only_keyboard())


@router.message(F.text == "–ö—É–ø–ª–µ–Ω–Ω–æ–µ")
async def show_purchases(message: Message, state: FSMContext | None = None) -> None:
    """Show purchased items grouped by category with pretty headers."""

    db = get_db()
    purchases = db.get_purchases_by_user(message.from_user.id)

    # –ï—Å–ª–∏ –ø–æ–∫—É–ø–æ–∫ –Ω–µ—Ç ‚Äî —Å—Ä–∞–∑—É –≤—ã—Ö–æ–¥–∏–º
    if not purchases:
        sent = await message.answer(
            "–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫ –ø—É—Å—Ç.",
            reply_markup=await build_main_menu_for_user(message.from_user.id),
        )
        if state:
            await ui_register_message(state, sent.chat.id, sent.message_id)
        return

    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ–∫—É–ø–∫–∏ –ø–æ "–æ—á–µ–ª–æ–≤–µ—á–µ–Ω–Ω—ã–º" –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    groups: dict[str, list[dict]] = defaultdict(list)
    for purchase in purchases:
        category_key = humanize_wishlist_category(purchase.get("category", ""))
        groups[category_key].append(purchase)

    lines: list[str] = ["–ö—É–ø–ª–µ–Ω–Ω—ã–µ –∂–µ–ª–∞–Ω–∏—è:"]
    for category, items in groups.items():
        lines.append(f"\nüí° {category}:")
        for purchase in items:
            lines.append(
                f"‚Ä¢ {purchase['wish_name']} ‚Äî {purchase['price']:.2f} ‚ÇΩ "
                f"(–∫—É–ø–ª–µ–Ω–æ {purchase['purchased_at']})"
            )

    sent = await message.answer(
        "\n".join(lines),
        reply_markup=await build_main_menu_for_user(message.from_user.id),
    )
    if state:
        await ui_register_message(state, sent.chat.id, sent.message_id)


@router.message(
    F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
    StateFilter(
        WishlistState.waiting_for_name,
        WishlistState.waiting_for_price,
        WishlistState.waiting_for_url,
        WishlistState.waiting_for_category,
    ),
)
async def wishlist_add_back(message: Message, state: FSMContext) -> None:
    """Handle back navigation in wishlist add flow."""

    data = await state.get_data()
    stack = list(data.get("wl_add_step_stack") or [])
    current = stack[-1] if stack else None

    if current == "name":
        await state.clear()
        await open_wishlist(message, state)
        return

    if current == "amount":
        await state.update_data(
            price=None,
            price_sum=None,
            price_question_message_id=None,
            price_message_id=None,
        )
        await state.set_state(WishlistState.waiting_for_name)
        await _set_wl_steps(state, ["name"])
        await message.answer(
            "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–µ–ª–∞–Ω–∏—è.",
            reply_markup=back_only_keyboard(),
        )
        return

    if current == "url":
        stack.pop()
        await state.update_data(url=None, wl_add_step_stack=stack)
        await message.answer("–¥–∞–π", reply_markup=back_only_keyboard())
        await message.answer("—Å—Å—ã–ª–æ—á–∫—É", reply_markup=wishlist_url_keyboard())
        return

    if current == "pre_url":
        stack.pop()
        await state.update_data(
            price=None,
            price_sum=None,
            price_question_message_id=None,
            price_message_id=None,
            wl_add_step_stack=stack,
        )
        await state.set_state(WishlistState.waiting_for_price)
        question = await message.answer(
            "–í–≤–µ–¥–∏ —Ü–µ–Ω—É (–∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ).",
            reply_markup=income_calculator_keyboard(),
        )
        prompt = await message.answer(": 0")
        await state.update_data(
            price_sum="0",
            price_question_message_id=question.message_id,
            price_message_id=prompt.message_id,
        )
        await _push_wl_step(state, "amount")
        return

    if current == "category":
        stack.pop()
        await state.update_data(wl_add_step_stack=stack)
        await state.set_state(WishlistState.waiting_for_url)
        await message.answer("–¥–∞–π", reply_markup=back_only_keyboard())
        await message.answer("—Å—Å—ã–ª–æ—á–∫—É", reply_markup=wishlist_url_keyboard())
        return


@router.message(WishlistState.waiting_for_price)
async def invalid_price(message: Message) -> None:
    """Handle invalid price input."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞ –Ω–∏–∂–µ –¥–ª—è –≤–≤–æ–¥–∞ —Ü–µ–Ω—ã.")


@router.message(WishlistState.waiting_for_category, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_back_from_category(message: Message, state: FSMContext) -> None:
    """Return to name step from category selection."""

    await state.update_data(name=None, price=None, price_sum=None, url=None)
    await state.set_state(WishlistState.waiting_for_name)
    await message.answer(
        "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–µ–ª–∞–Ω–∏—è.",
        reply_markup=back_only_keyboard(),
    )


@router.message(WishlistState.waiting_for_category)
async def waiting_category_text(message: Message) -> None:
    """Prompt to use inline keyboard for category."""

    db = get_db()
    categories = _get_user_wishlist_categories(db, message.from_user.id)
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ.",
        reply_markup=wishlist_categories_keyboard(categories),
    )
    await message.answer("–ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–∞–∂–º–∏ ‚¨ÖÔ∏è –ù–∞–∑–∞–¥.", reply_markup=back_only_keyboard())


def _build_byt_items_keyboard(
    items: list[dict],
    allow_defer: bool = True,
    category_id: int | None = None,
) -> InlineKeyboardMarkup:
    """Build inline keyboard for BYT items with optional two-column layout."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""), callback_data=f"byt_buy:{item.get('id')}"
                )
            )
        rows.append(row)
    if allow_defer:
        defer_callback = "byt_defer_menu"
        defer_next_callback = "byt:defer_next_menu"
        if len(items) == 1:
            try:
                defer_id = int(items[0].get("id"))
            except (TypeError, ValueError):
                defer_id = None
            else:
                defer_callback = f"byt_defer_menu:item:{defer_id}"
                defer_next_callback = f"byt:defer_next:{defer_id}"
        elif category_id is not None:
            defer_callback = f"byt_defer_menu:cat:{category_id}"
            defer_next_callback = f"byt:defer_next_menu:{category_id}"
        rows.append(
            [
                InlineKeyboardButton(text="‚è≠ –û—Ç–ª–æ–∂–∏—Ç—å", callback_data=defer_next_callback),
                InlineKeyboardButton(text="üìÖ –û—Ç–ª–æ–∂–∏—Ç—å –Ω–∞ ‚Ä¶", callback_data=defer_callback),
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=rows)


def _build_byt_defer_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Build inline keyboard for selecting BYT item to defer."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""),
                    callback_data=f"byt_defer_pick:{item.get('id')}",
                )
            )
        rows.append(row)
    return InlineKeyboardMarkup(inline_keyboard=rows)


def _build_byt_defer_select_keyboard(
    items: list[dict], callback_prefix: str
) -> InlineKeyboardMarkup:
    """Build inline keyboard for selecting BYT item for defer action."""

    rows: list[list[InlineKeyboardButton]] = []
    per_row = 2 if len(items) > 3 else 1
    for index in range(0, len(items), per_row):
        row_items = items[index : index + per_row]
        row: list[InlineKeyboardButton] = []
        for item in row_items:
            row.append(
                InlineKeyboardButton(
                    text=item.get("name", ""),
                    callback_data=f"{callback_prefix}:{item.get('id')}",
                )
            )
        rows.append(row)
    return InlineKeyboardMarkup(inline_keyboard=rows)


def _build_byt_defer_actions_keyboard(item_id: int) -> InlineKeyboardMarkup:
    """Build inline keyboard for BYT defer actions for a single item."""

    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="‚è≠ –û—Ç–ª–æ–∂–∏—Ç—å", callback_data=f"byt:defer_next:{item_id}"
                ),
                InlineKeyboardButton(
                    text="üìÖ –û—Ç–ª–æ–∂–∏—Ç—å –Ω–∞ ‚Ä¶", callback_data=f"byt_defer_menu:item:{item_id}"
                ),
            ]
        ]
    )


async def _refresh_byt_reminder_message(
    bot: Bot,
    chat_id: int,
    message_id: int,
    user_id: int,
    category_title: str,
    *,
    state: FSMContext | None = None,
) -> None:
    """Refresh reminder message with current BYT items."""

    db = get_db()
    if not category_title:
        await safe_edit_message_text(
            bot,
            chat_id=chat_id,
            message_id=message_id,
            text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –Ω–µ –≤—ã–±—Ä–∞–Ω–∞. –û—Ç–∫—Ä–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ‚Üí "
            "–í—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.",
            logger=LOGGER,
        )
        return

    now_dt = now_tz()
    due_items, deferred_items = get_byt_category_items(db, user_id, category_title, now_dt)
    settings_row = db.get_user_settings(user_id)
    allow_defer = bool(settings_row.get("byt_defer_enabled", 1))
    category_row = db.get_wishlist_category_by_title(user_id, category_title)
    category_id = int(category_row["id"]) if category_row else None
    text = format_byt_category_checklist_text(
        category_title, due_items, deferred_items
    )
    keyboard = (
        _build_byt_items_keyboard(due_items, allow_defer=allow_defer, category_id=category_id)
        if due_items
        else None
    )
    edited = await safe_edit_message_text(
        bot,
        chat_id=chat_id,
        message_id=message_id,
        text=text,
        reply_markup=keyboard,
        logger=LOGGER,
    )
    if edited:
        return
    sent = await safe_send_message(
        bot,
        chat_id=chat_id,
        text=text,
        reply_markup=keyboard,
        logger=LOGGER,
    )
    if sent and state:
        await ui_register_message(state, sent.chat.id, sent.message_id)


async def _start_byt_defer_flow(
    callback: CallbackQuery, state: FSMContext, wish_id: int
) -> bool:
    """Validate and start BYT defer input flow for specific item."""

    db = get_db()
    wish = db.get_wish(wish_id)
    if not wish:
        await safe_callback_answer(callback, "–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True, logger=LOGGER)
        return False
    category_id, category_title = _resolve_wish_category(db, callback.from_user.id, wish)
    if category_id is not None and not db.get_byt_reminder_category_enabled(
        callback.from_user.id, category_id
    ):
        await safe_callback_answer(
            callback,
            "–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã.",
            show_alert=True,
            logger=LOGGER,
        )
        return False

    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await safe_callback_answer(callback, "–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö", show_alert=True, logger=LOGGER)
        await state.clear()
        return False

    await state.set_state(BytDeferState.waiting_for_days)
    await state.update_data(
        defer_item_id=wish_id,
        defer_days_str="0",
        reminder_message_id=callback.message.message_id if callback.message else None,
    )

    await safe_callback_answer(callback, logger=LOGGER)
    target_chat_id = callback.message.chat.id if callback.message else callback.from_user.id
    question_message = await safe_send_message(
        callback.bot,
        chat_id=target_chat_id,
        text="–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –æ—Ç–ª–æ–∂–∏—Ç—å?",
        logger=LOGGER,
    )
    prompt = await safe_send_message(
        callback.bot,
        chat_id=target_chat_id,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
        logger=LOGGER,
    )
    await state.update_data(
        defer_display_chat_id=question_message.chat.id if question_message else target_chat_id,
        defer_display_message_id=prompt.message_id if prompt else None,
    )
    return True

    keyboard = _build_byt_items_keyboard(items, allow_defer=allow_defer)
    await safe_edit_message_text(
        bot,
        chat_id=chat_id,
        message_id=message_id,
        text="–ß—Ç–æ —Ç—ã –∫—É–ø–∏–ª?",
        reply_markup=keyboard,
        logger=LOGGER,
    )


async def run_byt_timer_check(
    bot: Bot,
    db: FinanceDatabase,
    user_id: int | None = None,
    simulated_time: time | None = None,
    run_time: datetime | None = None,
) -> None:
    """Run BYT reminders using timer configuration for the user."""

    await asyncio.sleep(0)
    trigger_dt = run_time or now_tz()
    if simulated_time:
        trigger_dt = trigger_dt.replace(
            hour=simulated_time.hour,
            minute=simulated_time.minute,
            second=0,
            microsecond=0,
        )

    user_ids = (
        [user_id]
        if user_id is not None
        else list(
            set(db.get_users_with_active_byt_wishes())
            | set(db.get_users_with_byt_timer_times())
        )
    )
    if not user_ids:
        return

    for uid in user_ids:
        db.ensure_byt_reminder_migration(uid)
        settings_row = db.get_user_settings(uid)
        if not bool(settings_row.get("byt_reminders_enabled", 1)):
            continue

        simulated = simulated_time is not None
        trigger_label = trigger_dt.strftime("%H:%M")
        LOGGER.info(
            "BYT timer check triggered (user_id=%s, simulated=%s, time=%s)",
            uid,
            simulated,
            trigger_label,
        )
        categories = db.list_enabled_byt_reminder_categories(uid)
        if not categories:
            LOGGER.info(
                "BYT timer: no enabled categories configured, skip (user_id=%s)", uid
            )
            continue

        for category in categories:
            category_id = int(category.get("id"))
            category_title = str(category.get("title", ""))
            times = db.list_byt_reminder_times(uid, category_id)
            times_hhmm = [str(item.get("time_hhmm", "")) for item in times if item.get("time_hhmm")]
            if not times_hhmm:
                times_hhmm = ["12:00"]
            should_run = trigger_label in times_hhmm
            if not should_run:
                continue

            db.cleanup_old_byt_purchases(uid, category_title, trigger_dt)
            total_items = db.get_active_byt_wishes(uid, category_title)
            due_items, deferred_items = get_byt_category_items(
                db, uid, category_title, trigger_dt
            )
            if not total_items:
                LOGGER.info(
                    "BYT timer: category_id=%s items=%s due=%s deferred=%s user_id=%s",
                    category_id,
                    0,
                    0,
                    0,
                    uid,
                )
                continue
            if not due_items:
                LOGGER.info(
                    "BYT timer: category_id=%s items=%s due=%s deferred=%s user_id=%s",
                    category_id,
                    len(total_items),
                    0,
                    len(deferred_items),
                    uid,
                )
                continue

            allow_defer = bool(settings_row.get("byt_defer_enabled", 1))
            text = format_byt_category_checklist_text(
                category_title, due_items, deferred_items
            )
            keyboard = _build_byt_items_keyboard(
                due_items, allow_defer=allow_defer, category_id=category_id
            )
            await bot.send_message(uid, text, reply_markup=keyboard)
            LOGGER.info(
                "BYT timer: category_id=%s items=%s due=%s deferred=%s user_id=%s",
                category_id,
                len(total_items),
                len(due_items),
                len(deferred_items),
                uid,
            )


async def run_byt_wishlist_reminders(
    bot: Bot,
    db: FinanceDatabase,
    user_id: int | None = None,
    forced: bool = False,
    run_time=None,
) -> None:
    """Backward-compatible wrapper for BYT reminders."""

    await run_byt_timer_check(
        bot,
        db,
        user_id=user_id,
        simulated_time=None,
        run_time=run_time,
    )


@router.callback_query(F.data.startswith("byt_buy:"))
async def handle_byt_buy(callback: CallbackQuery, state: FSMContext) -> None:
    """Handle purchase confirmation from BYT reminder list."""

    data = callback.data.split(":", maxsplit=1)
    if len(data) != 2:
        await safe_callback_answer(callback, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.", show_alert=True, logger=LOGGER)
        return

    try:
        item_id = int(data[1])
    except ValueError:
        await safe_callback_answer(callback, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.", show_alert=True, logger=LOGGER)
        return

    db = get_db()
    wish = db.get_wish(item_id)
    if not wish:
        await safe_callback_answer(callback, "–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True, logger=LOGGER)
        return
    _, category_title = _resolve_wish_category(db, callback.from_user.id, wish)

    price = float(wish.get("price", 0) or 0)
    purchase_time = now_tz()
    db.decrease_savings(callback.from_user.id, "–±—ã—Ç", price)
    db.mark_wish_purchased(item_id, purchased_at=purchase_time)
    db.add_purchase(
        callback.from_user.id,
        wish.get("name", ""),
        price,
        humanize_wishlist_category(wish.get("category", "")),
        purchased_at=purchase_time,
    )

    await safe_callback_answer(callback, logger=LOGGER)
    if callback.message:
        await _refresh_byt_reminder_message(
            callback.bot,
            callback.message.chat.id,
            callback.message.message_id,
            callback.from_user.id,
            category_title,
            state=state,
        )


@router.callback_query(F.data.startswith("byt_defer_menu"))
async def handle_byt_defer_menu(callback: CallbackQuery, state: FSMContext) -> None:
    """Show BYT items to choose which to defer."""

    wish_id: int | None = None
    category_id: int | None = None
    if callback.data and ":" in callback.data:
        parts = callback.data.split(":")
        if len(parts) >= 3 and parts[1] == "item":
            try:
                wish_id = int(parts[2])
            except ValueError:
                wish_id = None
        elif len(parts) >= 3 and parts[1] == "cat":
            try:
                category_id = int(parts[2])
            except ValueError:
                category_id = None
        elif len(parts) == 2:
            try:
                wish_id = int(parts[1])
            except ValueError:
                wish_id = None
    if wish_id is None:
        data = await state.get_data()
        stored_id = data.get("current_byt_item_id")
        try:
            wish_id = int(stored_id) if stored_id is not None else None
        except (TypeError, ValueError):
            wish_id = None

    db = get_db()
    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        await safe_callback_answer(callback, "–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö", show_alert=True, logger=LOGGER)
        return
    now_dt = now_tz()
    category_title = None
    if category_id is not None:
        category_row = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
        category_title = category_row.get("title") if category_row else None
    if wish_id is not None:
        await state.update_data(current_byt_item_id=wish_id)
        started = await _start_byt_defer_flow(callback, state, wish_id)
        if not started:
            await state.clear()
        return
    if category_title:
        items = db.list_active_byt_items_for_reminder(
            callback.from_user.id, now_dt, category_title
        )
    else:
        items = []

    if not items:
        await state.clear()
        if callback.message:
            await safe_answer(
                callback.message,
                f"–ù–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category_title or '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}.",
                logger=LOGGER,
            )
        else:
            await safe_send_message(
                callback.bot,
                chat_id=callback.from_user.id,
                text=f"–ù–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category_title or '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}.",
                logger=LOGGER,
            )
        await safe_callback_answer(callback, logger=LOGGER)
        return

    keyboard = _build_byt_defer_keyboard(items)
    await state.clear()
    if callback.message:
        edited = await safe_edit_message_text(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            text="–ß–¢–û?",
            reply_markup=keyboard,
            logger=LOGGER,
        )
        if not edited:
            await safe_answer(callback.message, "–ß–¢–û?", reply_markup=keyboard, logger=LOGGER)
    else:
        await safe_send_message(
            callback.bot,
            chat_id=callback.from_user.id,
            text="–ß–¢–û?",
            reply_markup=keyboard,
            logger=LOGGER,
        )
    await safe_callback_answer(callback, logger=LOGGER)


@router.callback_query(F.data.startswith("byt:defer_next_menu"))
async def handle_byt_defer_next_menu(callback: CallbackQuery, state: FSMContext) -> None:
    """Show BYT items to choose which to defer to next reminder."""

    await safe_callback_answer(callback, logger=LOGGER)
    db = get_db()
    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        if callback.message:
            await safe_answer(
                callback.message,
                "–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö",
                logger=LOGGER,
            )
        else:
            await safe_send_message(
                callback.bot,
                chat_id=callback.from_user.id,
                text="–û—Ç–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö",
                logger=LOGGER,
            )
        return

    category_id: int | None = None
    if callback.data and ":" in callback.data:
        parts = callback.data.split(":")
        if len(parts) >= 3:
            try:
                category_id = int(parts[2])
            except ValueError:
                category_id = None
    category_title = None
    if category_id is not None:
        category_row = db.get_wishlist_category_by_id(callback.from_user.id, category_id)
        category_title = category_row.get("title") if category_row else None
    now_dt = now_tz()
    items = (
        db.list_active_byt_items_for_reminder(
            callback.from_user.id, now_dt, category_title
        )
        if category_title
        else []
    )
    if not items:
        if callback.message:
            await safe_answer(
                callback.message,
                f"–ù–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category_title or '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}.",
                logger=LOGGER,
            )
        else:
            await safe_send_message(
                callback.bot,
                chat_id=callback.from_user.id,
                text=f"–ù–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –¥–ª—è –æ—Ç–ª–æ–∂–∫–∏ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category_title or '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}.",
                logger=LOGGER,
            )
        return

    keyboard = _build_byt_defer_select_keyboard(items, "byt:defer_next")
    if callback.message:
        edited = await safe_edit_message_text(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            text="–ß–¢–û?",
            reply_markup=keyboard,
            logger=LOGGER,
        )
        if not edited:
            await safe_answer(
                callback.message,
                "–ß–¢–û?",
                reply_markup=keyboard,
                logger=LOGGER,
            )
    else:
        await safe_send_message(
            callback.bot,
            chat_id=callback.from_user.id,
            text="–ß–¢–û?",
            reply_markup=keyboard,
            logger=LOGGER,
        )


@router.callback_query(F.data.startswith("byt:defer_next:"))
async def handle_byt_defer_next(callback: CallbackQuery, state: FSMContext) -> None:
    """Defer BYT item until the next scheduled reminder time."""

    await safe_callback_answer(callback, logger=LOGGER)
    data = callback.data.split(":", maxsplit=2)
    if len(data) != 3:
        return

    try:
        item_id = int(data[2])
    except ValueError:
        return

    db = get_db()
    wish = db.get_wish(item_id)
    if not wish:
        return
    category_id, category_title = _resolve_wish_category(db, callback.from_user.id, wish)

    settings_row = db.get_user_settings(callback.from_user.id)
    if not bool(settings_row.get("byt_defer_enabled", 1)):
        return

    times = (
        db.list_byt_reminder_times(callback.from_user.id, category_id)
        if category_id is not None
        else []
    )
    times_hhmm = [str(item.get("time_hhmm", "")) for item in times if item.get("time_hhmm")]
    next_run = get_next_reminder_dt(now_tz(), times_hhmm)

    existing_deferred = parse_deferred_until(wish.get("deferred_until"))

    deferred_until = resolve_deferred_until(existing_deferred, next_run)
    if existing_deferred != deferred_until:
        db.set_wishlist_item_deferred_until(
            callback.from_user.id, item_id, deferred_until.isoformat()
        )
    LOGGER.info(
        "USER=%s ACTION=BYT_DEFER_NEXT META=item_id=%s deferred_until=%s",
        callback.from_user.id,
        item_id,
        deferred_until.isoformat(),
    )

    now_dt = now_tz()
    due_items, deferred_items = get_byt_category_items(
        db, callback.from_user.id, category_title, now_dt
    )
    checklist_text = format_byt_category_checklist_text(
        category_title, due_items, deferred_items
    )
    message_text = format_byt_defer_confirmation_text(
        wish, category_title, deferred_until, checklist_text
    )
    category_row = db.get_wishlist_category_by_title(callback.from_user.id, category_title)
    category_ref = int(category_row["id"]) if category_row else None
    keyboard = (
        _build_byt_items_keyboard(
            due_items,
            allow_defer=bool(settings_row.get("byt_defer_enabled", 1)),
            category_id=category_ref,
        )
        if due_items
        else None
    )
    if callback.message:
        edited = await safe_edit_message_text(
            callback.message.bot,
            chat_id=callback.message.chat.id,
            message_id=callback.message.message_id,
            text=message_text,
            reply_markup=keyboard,
            logger=LOGGER,
        )
        if not edited:
            sent_id = await safe_answer(
                callback.message,
                message_text,
                reply_markup=keyboard,
                logger=LOGGER,
            )
            if sent_id:
                await ui_register_message(state, callback.message.chat.id, sent_id)
    else:
        sent = await safe_send_message(
            callback.bot,
            chat_id=callback.from_user.id,
            text=message_text,
            reply_markup=keyboard,
            logger=LOGGER,
        )
        if sent:
            await ui_register_message(state, sent.chat.id, sent.message_id)


@router.callback_query(F.data.startswith("byt_defer_pick:"))
async def handle_byt_defer_pick(callback: CallbackQuery, state: FSMContext) -> None:
    """Start deferring selected BYT item."""

    data = callback.data.split(":", maxsplit=1)
    wish_id: int | None = None
    if len(data) == 2:
        try:
            wish_id = int(data[1])
        except ValueError:
            wish_id = None
    if wish_id is None:
        state_data = await state.get_data()
        try:
            wish_id = (
                int(state_data.get("defer_item_id"))
                if state_data.get("defer_item_id") is not None
                else None
            )
        except (TypeError, ValueError):
            wish_id = None
    if wish_id is None:
        await safe_callback_answer(callback, "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω item_id", show_alert=True, logger=LOGGER)
        return

    started = await _start_byt_defer_flow(callback, state, wish_id)
    if not started:
        await state.clear()


@router.message(
    BytDeferState.waiting_for_days,
    F.text.in_(
        {
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "–û—á–∏—Å—Ç–∏—Ç—å",
            "‚úÖ –ì–∞–∑",
        }
    ),
)
async def handle_byt_defer_days(message: Message, state: FSMContext) -> None:
    """Handle calculator input for BYT defer days."""

    data = await state.get_data()
    current_sum = str(data.get("defer_days_str", "0"))
    display_chat_id = data.get("defer_display_chat_id", message.chat.id)
    display_message_id = data.get("defer_display_message_id")
    db = get_db()

    if message.text == "–û—á–∏—Å—Ç–∏—Ç—å":
        new_sum = "0"
    elif message.text == "‚úÖ –ì–∞–∑":
        amount_str = current_sum.strip()
        if not amount_str:
            LOGGER.warning(
                "BYT defer submit missing entered_days user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return
        try:
            days = int(amount_str)
        except (TypeError, ValueError):
            LOGGER.warning(
                "BYT defer submit invalid days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                amount_str,
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        if days <= 0:
            LOGGER.warning(
                "BYT defer submit non-positive days user_id=%s value=%s",
                message.from_user.id if message.from_user else "unknown",
                days,
            )
            await message.answer("–ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ –¥–Ω–µ–π. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        try:
            settings_row = db.get_user_settings(message.from_user.id)
        except Exception as exc:
            LOGGER.error(
                "Failed to load user settings for BYT defer user_id=%s",
                message.from_user.id if message.from_user else "unknown",
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return
        max_days = int(settings_row.get("byt_defer_max_days", 365) or 365)
        if days < 1 or days > max_days:
            await message.answer(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ {max_days}.")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        raw_defer_item_id = data.get("defer_item_id")
        try:
            defer_item_id = int(raw_defer_item_id) if raw_defer_item_id is not None else None
        except (TypeError, ValueError):
            defer_item_id = None
        if defer_item_id is None:
            LOGGER.warning(
                "BYT defer submit missing item_id user_id=%s",
                message.from_user.id if message.from_user else "unknown",
            )
            await message.answer("–ù–µ –≤—ã–±—Ä–∞–Ω —Ç–æ–≤–∞—Ä –¥–ª—è –æ—Ç—Å—Ä–æ—á–∫–∏.")
            await state.clear()
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return
        reminder_message_id = data.get("reminder_message_id")
        desired_deferred_until = now_tz() + timedelta(days=days)
        wish = db.get_wish(defer_item_id)
        existing_deferred = parse_deferred_until(
            wish.get("deferred_until") if wish else None
        )
        deferred_until = resolve_deferred_until(existing_deferred, desired_deferred_until)

        try:
            if existing_deferred != deferred_until:
                db.set_wishlist_item_deferred_until(
                    message.from_user.id, defer_item_id, deferred_until.isoformat()
                )
        except Exception as exc:
            LOGGER.error(
                "Failed to set BYT defer days user_id=%s item_id=%s days=%s",
                message.from_user.id if message.from_user else "unknown",
                defer_item_id,
                days,
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        if wish:
            category_id, category_title = _resolve_wish_category(db, message.from_user.id, wish)
            due_items, deferred_items = get_byt_category_items(
                db, message.from_user.id, category_title, now_tz()
            )
            checklist_text = format_byt_category_checklist_text(
                category_title, due_items, deferred_items
            )
            message_text = format_byt_defer_confirmation_text(
                wish, category_title, deferred_until, checklist_text
            )
            category_row = db.get_wishlist_category_by_title(message.from_user.id, category_title)
            category_ref = int(category_row["id"]) if category_row else category_id
            keyboard = (
                _build_byt_items_keyboard(
                    due_items,
                    allow_defer=bool(settings_row.get("byt_defer_enabled", 1)),
                    category_id=category_ref,
                )
                if due_items
                else None
            )
            if reminder_message_id:
                edited = await safe_edit_message_text(
                    message.bot,
                    chat_id=message.chat.id,
                    message_id=int(reminder_message_id),
                    text=message_text,
                    reply_markup=keyboard,
                    logger=LOGGER,
                )
                if not edited:
                    sent = await message.answer(message_text, reply_markup=keyboard)
                    if sent:
                        await ui_register_message(state, sent.chat.id, sent.message_id)
            else:
                sent = await message.answer(message_text, reply_markup=keyboard)
                if sent:
                    await ui_register_message(state, sent.chat.id, sent.message_id)
            await message.answer(" ", reply_markup=ReplyKeyboardRemove())
        else:
            await message.answer(
                f"–û—Ç–ª–æ–∂–µ–Ω–æ –Ω–∞ {days} –¥–Ω.", reply_markup=ReplyKeyboardRemove()
            )

        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        new_display_message_id = prompt.message_id
        new_display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(BytDeferState.waiting_for_days)
async def handle_byt_defer_days_invalid(message: Message) -> None:
    """Prompt to use calculator buttons for defer days."""

    await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞ –Ω–∏–∂–µ.")

===== Bot/keyboards/__init__.py =====



===== Bot/keyboards/calculator.py =====

"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """–û–±—â–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Å—É–º–º."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å"),
            KeyboardButton(text="0"),
            KeyboardButton(text="‚úÖ –ì–∞–∑"),
        ],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )

===== Bot/keyboards/household.py =====

"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="‚úÖ –î–∞"),
            KeyboardButton(text="‚ùå –ù–µ—Ç"),
            KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/main.py =====

"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")], [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/settings.py =====

"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup

from Bot.constants.ui_labels import (
    WISHLIST_DEBIT_CATEGORY_BACK,
    WISHLIST_DEBIT_CATEGORY_BUTTON,
    WISHLIST_DEBIT_CATEGORY_NONE,
    WISHLIST_BYT_CATEGORY_BUTTON,
)


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting household debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
