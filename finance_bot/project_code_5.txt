

@router.callback_query(F.data == "wl:purchased_mode:days")
async def wishlist_set_purchased_days(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    data = await state.get_data()
    category_id = data.get("editing_wl_category_id")
    if category_id is None:
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    db = get_db()
    category = db.get_wishlist_category_by_id(callback.from_user.id, int(category_id))
    if not category:
        await _reset_navigation(state, "st:wishlist")
        await render_settings_screen("st:wishlist", message=callback.message, state=state)
        return
    await _push_current_screen(state, "wl:purchased_days")
    await state.set_state(WishlistSettingsState.waiting_for_purchased_days)
    await state.update_data(
        purchased_days_str="0",
        purchased_display_chat_id=None,
        purchased_display_message_id=None,
        editing_wl_category_id=int(category_id),
    )
    db.update_wishlist_category_purchased_mode(callback.from_user.id, int(category_id), "days")
    chat_id, message_id = await _get_settings_message_ids(state, callback.message)
    await _edit_settings_page(
        bot=callback.message.bot,
        state=state,
        chat_id=chat_id,
        message_id=message_id,
        text=(
            f'–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ –¥–ª—è "{category.get("title", "")}"?'
        ),
        reply_markup=None,
    )
    prompt = await _send_and_register(
        message=callback.message,
        state=state,
        text=": 0",
        reply_markup=income_calculator_keyboard(),
    )
    await state.update_data(
        purchased_display_chat_id=prompt.chat.id,
        purchased_display_message_id=prompt.message_id,
    )


@router.message(IncomeSettingsState.waiting_for_percent)
async def income_percent_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text in {"–ù–∞–∑–∞–¥", "‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "‚è™ –ù–∞–∑–∞–¥"}:
        return

    percent_str = data.get("percent_str", "0")
    display_chat_id = data.get("percent_display_chat_id", message.chat.id)
    display_message_id = data.get("percent_display_message_id")

    if text not in PERCENT_INPUT_BUTTONS:
        parsed_value = parse_int_choice(text)
        if parsed_value is None:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text=f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        percent_str = str(parsed_value)
        LOGGER.info(
            "Percent input: user=%s scope=%s value=%s",
            message.from_user.id,
            data.get("edit_scope", "income"),
            percent_str,
        )
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {percent_str}",
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text in PERCENT_DIGITS:
        percent_str = percent_str.lstrip("0") if percent_str != "0" else ""
        percent_str = f"{percent_str}{text}" or "0"
        LOGGER.info(
            "Percent input: user=%s scope=%s value=%s",
            message.from_user.id,
            data.get("edit_scope", "income"),
            percent_str,
        )
        try:
            await _safe_edit(message.bot, 
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {percent_str}",
            )
        except Exception:
            fallback = await safe_send_message(message.bot, 
                chat_id=display_chat_id, text=f": {percent_str}"
            )
            display_message_id = fallback.message_id
            await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "–û—á–∏—Å—Ç–∏—Ç—å":
        percent_str = "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=": 0",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=": 0",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            percent_str=percent_str,
            percent_display_chat_id=display_chat_id,
            percent_display_message_id=display_message_id,
        )
        return

    if text == "‚úÖ –ì–∞–∑":
        error_message = None
        try:
            percent = int(percent_str or "0")
        except ValueError:
            error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º."
        else:
            if percent < 0 or percent > 100:
                error_message = "–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 0‚Äì100."

        category_id = data.get("editing_category_id")
        if category_id is None:
            await state.set_state(None)
            await _cleanup_input_ui(
                message.bot,
                data,
                display_chat_key="percent_display_chat_id",
                display_message_key="percent_display_message_id",
            )
            await message.answer("–ù–µ –≤—ã–±—Ä–∞–Ω —Ç–æ–≤–∞—Ä –¥–ª—è –æ—Ç—Å—Ä–æ—á–∫–∏.")
            await state.clear()
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        await state.set_state(None)
        previous_screen = await _pop_previous_screen(state) or "st:income"
        await render_settings_screen(previous_screen, message=message, state=state)


@router.message(WishlistSettingsState.waiting_for_purchased_days)
async def wishlist_purchased_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text in {"–ù–∞–∑–∞–¥", "‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "‚è™ –ù–∞–∑–∞–¥"}:
        return

    days_str = data.get("purchased_days_str", "0")
    display_chat_id = data.get("purchased_display_chat_id", message.chat.id)
    display_message_id = data.get("purchased_display_message_id")

    if text not in PERCENT_INPUT_BUTTONS:
        parsed_value = parse_positive_int(text)
        if parsed_value is None:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text=f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        days_str = str(parsed_value)
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {days_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
                await ui_register_message(state, display_chat_id, display_message_id)
        await state.update_data(
            purchased_days_str=days_str,
            purchased_display_chat_id=display_chat_id,
            purchased_display_message_id=display_message_id,
        )
        return

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            if existing_deferred != deferred_until:
                db.set_wishlist_item_deferred_until(
                    message.from_user.id, defer_item_id, deferred_until.isoformat()
                )
        except Exception as exc:
            LOGGER.error(
                "Failed to set BYT defer days user_id=%s item_id=%s days=%s",
                message.from_user.id if message.from_user else "unknown",
                defer_item_id,
                days,
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        if wish:
            category_id, category_title = _resolve_wish_category(db, message.from_user.id, wish)
            due_items, deferred_items = get_byt_category_items(
                db, message.from_user.id, category_title, now_for_user(db, message.from_user.id, DEFAULT_TZ)
            )
            checklist_text = format_byt_category_checklist_text(
                category_title, due_items, deferred_items
            )
            message_text = format_byt_defer_confirmation_text(
                wish, category_title, deferred_until, checklist_text
            )
            category_row = db.get_wishlist_category_by_title(message.from_user.id, category_title)
            category_ref = int(category_row["id"]) if category_row else category_id
            keyboard = (
                _build_byt_items_keyboard(
                    due_items,
                    allow_defer=bool(settings_row.get("byt_defer_enabled", 1)),
                    category_id=category_ref,
                )
                if due_items
                else None
            )
            if reminder_message_id:
                edited = await safe_edit_message_text(
                    message.bot,
                    chat_id=message.chat.id,
                    message_id=int(reminder_message_id),
                    text=message_text,
                    reply_markup=keyboard,
                    logger=LOGGER,
                )
                if not edited:
                    sent = await message.answer(message_text, reply_markup=keyboard)
                    if sent:
                        await ui_register_message(state, sent.chat.id, sent.message_id)
            else:
                sent = await message.answer(message_text, reply_markup=keyboard)
                if sent:
                    await ui_register_message(state, sent.chat.id, sent.message_id)
            await message.answer(" ", reply_markup=ReplyKeyboardRemove())
        else:
            await message.answer(
                f"–û—Ç–ª–æ–∂–µ–Ω–æ –Ω–∞ {days} –¥–Ω.", reply_markup=ReplyKeyboardRemove()
            )

        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        new_display_message_id = prompt.message_id
        new_display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

@router.message(BytSettingsState.waiting_for_max_defer_days)
async def byt_max_defer_days_value(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    text = (message.text or "").strip()
    await _register_user_message(state, message)
    await _delete_user_message(message)
    if text in {"–ù–∞–∑–∞–¥", "‚¨Ö –ù–∞–∑–∞–¥", "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "‚è™ –ù–∞–∑–∞–¥"}:
        return


    if text not in PERCENT_INPUT_BUTTONS:
        parsed_value = parse_positive_int(text)
        if parsed_value is None:
            chat_id, message_id = await _get_settings_message_ids(state, message)
            await _edit_settings_page(
                bot=message.bot,
                state=state,
                chat_id=chat_id,
                message_id=message_id,
                text=f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.",
                reply_markup=None,
            )
            return
        days_str = str(parsed_value)
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {days_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
        return

    if text in PERCENT_DIGITS:
        days_str = days_str.lstrip("0") if days_str != "0" else ""
        days_str = f"{days_str}{text}" or "0"
        try:
            await _safe_edit(
                message.bot,
                chat_id=display_chat_id,
                message_id=int(display_message_id),
                text=f": {days_str}",
            )
        except Exception:
            fallback = await safe_send_message(
                message.bot,
                chat_id=display_chat_id,
                text=f": {days_str}",
            )
            if fallback:
                display_message_id = fallback.message_id
        await state.update_data(
            byt_max_days_str=days_str,
            byt_max_display_chat_id=display_chat_id,
            byt_max_display_message_id=display_message_id,
        )
    buttons.append(
        [InlineKeyboardButton(text=NAV_HOME, callback_data="nav:home")]
    )
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/main.py =====

"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup

from Bot.constants.ui_labels import NAV_BACK, NAV_HOME


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text=NAV_HOME)]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text=NAV_BACK), KeyboardButton(text=NAV_HOME)]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [
        [KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text=NAV_BACK), KeyboardButton(text=NAV_HOME)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text=NAV_BACK), KeyboardButton(text=NAV_HOME)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/navigation.py =====

"""Navigation inline keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup

from Bot.constants.ui_labels import NAV_BACK, NAV_HOME


def nav_back(back_cb: str) -> InlineKeyboardMarkup:
    """Inline keyboard with Back button."""

    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text=NAV_BACK, callback_data=back_cb),
            ]
        ]
    )


def nav_back_home(back_cb: str, home_cb: str) -> InlineKeyboardMarkup:
    """Inline keyboard with Back and Home buttons."""

    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text=NAV_BACK, callback_data=back_cb),
                InlineKeyboardButton(text=NAV_HOME, callback_data=home_cb),
            ]
        ]
    )

===== Bot/keyboards/settings.py =====

"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup

from Bot.constants.ui_labels import (
    NAV_BACK,
    WISHLIST_DEBIT_CATEGORY_BUTTON,
    WISHLIST_DEBIT_CATEGORY_NONE,
    WISHLIST_BYT_CATEGORY_BUTTON,
)
from Bot.keyboards.navigation import nav_back


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting household debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household payments settings."""

    inline_keyboard = [
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:add_payment")],
        [InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:del_payment_menu")],
        [InlineKeyboardButton(text="üîÑ –û–±–Ω—É–ª–∏—Ç—å", callback_data="hp:reset_questions")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_payments_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household payments in settings."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hp:del_payment:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for settings home screen."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="üìä –î–æ—Ö–æ–¥", callback_data="st:income"),
            InlineKeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç", callback_data="st:wishlist"),
        ],
        [InlineKeyboardButton(text="–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="st:byt_rules")],
        [InlineKeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏", callback_data="st:household_payments")],
        [InlineKeyboardButton(text="–¢–∞–π–º–∑–æ–Ω–∞", callback_data="st:timezone")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings home screen."""

    buttons = [
        [KeyboardButton(text="üìä –î–æ—Ö–æ–¥"), KeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç")],
        [KeyboardButton(text="–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"), KeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")],
        [KeyboardButton(text="–¢–∞–π–º–∑–æ–Ω–∞")],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:add_cat"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:del_cat_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –°—Ä–æ–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ", callback_data="wl:purchased_select_category"),
        ],
        [InlineKeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è", callback_data="wl:debit_category_menu")],
    ]
    inline_keyboard.extend(nav_back("st:wishlist").inline_keyboard)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for wishlist settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
        ],
        [KeyboardButton(text="üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BUTTON)],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_reply_keyboard(categories: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_purchased_mode_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist purchased mode."""

    buttons = [
        [KeyboardButton(text="–í—Å–µ–≥–¥–∞")],
        [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏")],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_NONE)])
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_byt_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_category_toggle_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for toggling BYT categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        enabled = bool(category.get("enabled", 0))
        label = f"{'‚úÖ' if enabled else '‚ùå'} {category.get('title', '')}"
        next_state = 0 if enabled else 1
        row.append(
            InlineKeyboardButton(
                text=label,
                callback_data=f"byt:category_toggle:{category.get('id')}:{next_state}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.append([InlineKeyboardButton(text=NAV_BACK, callback_data="st:byt_rules")])
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=category.get("title", ""),
            callback_data=f"{action_prefix}:{category.get('id')}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.extend(nav_back("st:byt_rules").inline_keyboard)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_categories_inline_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        enabled = bool(category.get("enabled", 0))
        label = f"{'‚úÖ' if enabled else '‚ùå'} {category.get('title', '')}"
        row.append(
            InlineKeyboardButton(
                text=label,
                callback_data=f"{action_prefix}:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.append([InlineKeyboardButton(text=NAV_BACK, callback_data="st:byt_rules")])
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_purchased_mode_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist purchased mode."""

    inline_keyboard = [
        [InlineKeyboardButton(text="–í—Å–µ–≥–¥–∞", callback_data="wl:purchased_mode:always")],
        [InlineKeyboardButton(text="–ù–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π", callback_data="wl:purchased_mode:days")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT rules settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(
                text="–í—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π", callback_data="wl:byt_category_menu"
            )
        ],
        [
            InlineKeyboardButton(
                text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="byt:toggle_enabled"
            ),
            InlineKeyboardButton(
                text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª", callback_data="byt:toggle_defer"
            ),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å", callback_data="byt:edit_max_defer_days"),
            InlineKeyboardButton(text="‚è∞ –í—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π", callback_data="byt:timer_menu"),
        ],
    ]
    inline_keyboard.extend(nav_back("st:home").inline_keyboard)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT rules settings."""

    buttons = [
        [KeyboardButton(text=WISHLIST_BYT_CATEGORY_BUTTON)],
        [
            KeyboardButton(text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª"),
        ],
        [KeyboardButton(text="‚è∞ –í—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π")],
        [KeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT timer settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:add_time"),
            InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:del_time_menu"),
        ],
        [InlineKeyboardButton(text=NAV_BACK, callback_data="byt:timer_menu")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT timer settings."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è"),
            KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è"),
        ],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_times_select_reply_keyboard(times: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT timer time."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for timer in times:
        if timer.get("time_hhmm"):
            label = str(timer.get("time_hhmm"))
        else:
            label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_timer_times_select_keyboard(times: list[dict], action_prefix: str) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer time."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for timer in times:
        if timer.get("time_hhmm"):
            label = str(timer.get("time_hhmm"))
            callback_value = label
        else:
            label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
            callback_value = str(timer.get("id"))
        row.append(
            InlineKeyboardButton(text=label, callback_data=f"{action_prefix}:{callback_value}")
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_back_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with a single back button for settings mode."""

    buttons = [[KeyboardButton(text=NAV_BACK)]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for income settings actions."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:add"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:del_menu"),
        ],
        [
            InlineKeyboardButton(text="‚úèÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã", callback_data="inc:pct_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def income_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for income settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
        ],
        [KeyboardButton(text="‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤")],
        [KeyboardButton(text=NAV_BACK)],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_categories_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting income category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        title = category.get("title", "")
        percent = category.get("percent", 0)
        row.append(KeyboardButton(text=f"{title} ‚Äî {percent}%"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=NAV_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def income_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting an income category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=f"{category['title']} ({category['percent']}%)",
            callback_data=f"{action_prefix}:{category['id']}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def timezone_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for timezone selection."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="Europe/Amsterdam", callback_data="st:tz:Europe/Amsterdam"),
            InlineKeyboardButton(text="Europe/Moscow", callback_data="st:tz:Europe/Moscow"),
        ],
        [
            InlineKeyboardButton(text="Asia/Tashkent", callback_data="st:tz:Asia/Tashkent"),
            InlineKeyboardButton(text="UTC", callback_data="st:tz:UTC"),
        ],
    ]
    inline_keyboard.extend(nav_back("st:home").inline_keyboard)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_stub_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for stub sections with back button."""

    return InlineKeyboardMarkup(inline_keyboard=[])

===== Bot/main.py =====

"""Entry point for finance bot."""
import asyncio
import contextlib
import logging
import sys
from datetime import datetime
from pathlib import Path

project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramUnauthorizedError

from Bot.config.settings import get_settings
from Bot.database.get_db import get_db
from Bot.handlers import (
    callbacks,
    common,
    finances,
    household_payments,
    settings,
    start,
    wishlist,
)
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.logging import init_logging
from Bot.utils.time import now_for_user


def register_routers(dispatcher: Dispatcher) -> None:
    """Register all routers to dispatcher."""

    dispatcher.include_router(start.router)
    dispatcher.include_router(finances.router)
    dispatcher.include_router(household_payments.router)
    dispatcher.include_router(settings.router)
    dispatcher.include_router(wishlist.router)
    dispatcher.include_router(callbacks.router)
    dispatcher.include_router(common.router)


def _token_fingerprint(token: str) -> str:
    if not token:
        return "empty"
    if len(token) <= 8:
        return f"{token[:2]}‚Ä¶{token[-2:]}"
    return f"{token[:4]}‚Ä¶{token[-4:]}"


@router.message(
    WishlistState.waiting_for_price,
    F.text.regexp(r"^\\s*\\+?\\d+\\s*$"),
)
async def add_wish_price_manual(message: Message, state: FSMContext) -> None:
    """Handle manual numeric price input."""

    value = parse_positive_int(message.text or "")
    if value is None:
        await message.answer(f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return

    data = await state.get_data()
    price_message_id = data.get("price_message_id")
    new_sum = str(value)

    if price_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=message.chat.id,
            message_id=int(price_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            price_message_id = prompt.message_id
    else:
        prompt = await message.answer(f": {new_sum}")
        price_message_id = prompt.message_id

    await state.update_data(price_sum=new_sum, price_message_id=price_message_id)
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(WishlistState.waiting_for_url, F.text != "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def add_wish_url(message: Message, state: FSMContext) -> None:
    """Save URL and request category selection."""

    errors = []
    if ":" not in token:
        errors.append("BOT_TOKEN –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ —Ç–æ–∫–µ–Ω (–Ω–µ—Ç ':')")
    if len(token) < 20:
        errors.append("BOT_TOKEN —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–æ–∂–∏–¥–∞–µ—Ç—Å—è > 20 —Å–∏–º–≤–æ–ª–æ–≤)")
    return errors


def _format_token_context(token_source: str, fingerprint: str, env_path: Path) -> str:
    if token_source == ".env":
        return f"token_source={token_source}, fingerprint={fingerprint}, env_path={env_path}"
    return f"token_source={token_source}, fingerprint={fingerprint}"


async def _run_byt_scheduler(bot: Bot, db, default_tz: str) -> None:
    """Background scheduler for BYT reminders."""

    while True:
        user_ids = set(db.get_users_with_byt_reminder_times()) | set(
            db.get_users_with_active_byt_wishes()
        )
        now_values: dict[int, datetime] = {}
        for uid in user_ids:
            now_values[uid] = now_for_user(db, uid, default_tz)
            await run_byt_timer_check(bot, db, user_id=uid, run_time=now_values[uid])
        reference = now_values[min(now_values)] if now_values else now_for_user(db, 0, default_tz)
        sleep_for = 60 - reference.second - reference.microsecond / 1_000_000
        await asyncio.sleep(max(sleep_for, 1))


async def main() -> None:
    """Run bot polling."""

    init_logging()
    settings = get_settings()
    logger = logging.getLogger(__name__)
    token = (settings.bot_token or "").strip()
    token_source = settings.bot_token_source
    fingerprint = _token_fingerprint(token)
    token_context = _format_token_context(token_source, fingerprint, project_root / ".env")

    errors = _validate_token(token)
    for error in errors:
        logger.error("%s (%s)", error, token_context)
    if errors:
        return

    bot = Bot(
        token=token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher()

    db = get_db()
    register_routers(dp)

    try:
        await bot.me()
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
        await bot.session.close()
        return

    reminder_task = asyncio.create_task(
        _run_byt_scheduler(
            bot,
            db,
            settings.timezone.key if hasattr(settings.timezone, "key") else str(settings.timezone),
        )
    )
    try:
        logger.info(
            "Starting bot polling (%s)",
            token_context,
        )
        await dp.start_polling(bot)
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
    except Exception as error:  # noqa: BLE001
        logger.exception("Bot stopped due to error: %s", error)
    finally:
        reminder_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await reminder_task
        await bot.session.close()
        logger.info("Bot shutdown complete")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        # —à—Ç–∞—Ç–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (–±–µ–∑ traceback)
        pass

===== Bot/renderers/__init__.py =====

"""Renderer layer package."""

===== Bot/renderers/household.py =====

"""Renderers for household payments UI."""
from __future__ import annotations

import html
from typing import Dict, List

from aiogram.types import InlineKeyboardMarkup

from Bot.keyboards.household import household_payments_inline_keyboard


def render_household_questions_text(
    month: str,
    questions: list[dict],
    answers: dict[str, str],
    current_index: int | None,
) -> str:
    header = f"<b>–ë–´–¢–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò ‚Äî {html.escape(month)}</b>"
    lines = [header]
    for index, question in enumerate(questions, start=1):
        code = str(question.get("code", ""))
        text = html.escape(str(question.get("text", "")).strip())
        text = text.rstrip("?").strip()
        suffix = ""
        answer = answers.get(code)
        if answer == "yes":
            suffix = " ‚úÖ"
        elif answer == "no":
            suffix = " ‚ùå"
        display = text
        if current_index is not None and index - 1 == current_index:
            display = f"<b>{display.upper()}</b>"
        lines.append(f"{index}) {display}{suffix}")
    return "\n".join(lines)


def format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    if not items:
        return "–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π: (–ø—É—Å—Ç–æ)"

    lines = ["–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π:"]
    for index, item in enumerate(items, start=1):
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        code = str(item.get("code", ""))
        status = "‚ùå" if code in unpaid_set else "‚úÖ"
        if amount is not None:
            lines.append(f"{index}) {status} {title} ‚Äî {amount}")
        else:
            lines.append(f"{index}) {status} {title}")
    return "\n".join(lines)


def build_household_question_keyboard(
    question_code: str | None, show_back: bool
) -> InlineKeyboardMarkup:
    return household_payments_inline_keyboard(
        show_back=show_back, question_code=question_code
    )

===== Bot/services/__init__.py =====

    await message.answer(f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")

from Bot.services.byt_service import build_manual_check_summary
from Bot.services.household_service import ensure_household_month, list_active_byt_wishes
from Bot.services.types import ManualCheckResult, ServiceError, WishlistPurchaseResult
from Bot.services.wishlist_service import add_wish, list_wishlist_categories, purchase_wish

__all__ = [
    "ManualCheckResult",
    "ServiceError",
    "WishlistPurchaseResult",
    "add_wish",
    "list_wishlist_categories",
    "purchase_wish",
    "build_manual_check_summary",
    "ensure_household_month",
    "list_active_byt_wishes",
]

===== Bot/services/household.py =====

"""Business logic for household payments flow."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable


@dataclass
class HouseholdFlowState:
    """Container for household flow state."""

    month: str
    questions: list[dict]
    current_step_index: int
    current_question_code: str | None
    answers: dict[str, str]
    processed_steps: set[str]


def build_household_questions(items: Iterable[dict]) -> list[dict]:
    return [
        {
            "code": str(item.get("code", "")),
            "text": str(item.get("text", "")),
            "amount": item.get("amount"),
        }
        for item in items
        if item.get("code") is not None
    ]


def build_answers_from_status(status_map: dict[str, int]) -> dict[str, str]:
    return {
        str(code): "yes"
        for code, value in status_map.items()
        if int(value) == 1
    }


def filter_unpaid_questions(
    questions: Iterable[dict], unpaid_codes: Iterable[str]
) -> list[dict]:
    unpaid_set = {str(code) for code in unpaid_codes}
    return [question for question in questions if question.get("code") in unpaid_set]


def get_current_question(questions: list[dict], index: int) -> dict | None:
    if index < 0 or index >= len(questions):
        return None
    return questions[index]


def get_next_index(index: int, questions: list[dict]) -> int:
    return min(index + 1, len(questions))


def get_previous_index(index: int) -> int:
    return max(index - 1, 0)


def should_ignore_answer(
    answers: dict[str, str],
    processed_steps: set[str],
    question_code: str,
    action: str,
) -> bool:
    return question_code in processed_steps and answers.get(question_code) == action


def normalize_processed_steps(value: Iterable[str] | None) -> set[str]:
    if not value:
        return set()
    return {str(item) for item in value}


def update_flow_state(
    month: str,
    questions: list[dict],
    current_step_index: int,
    answers: dict[str, str] | None,
    processed_steps: Iterable[str] | None,
) -> HouseholdFlowState:
    current_question = get_current_question(questions, current_step_index)
    return HouseholdFlowState(
        month=month,
        questions=questions,
        current_step_index=current_step_index,
        current_question_code=str(current_question.get("code"))
        if current_question
        else None,
        answers=dict(answers or {}),
        processed_steps=normalize_processed_steps(processed_steps),
    )

===== Bot/states/__init__.py =====


===== Bot/states/money_states.py =====

"""FSM states for money flow."""
from aiogram.fsm.state import State, StatesGroup


class MoneyState(StatesGroup):
    """State machine for income distribution."""

    waiting_for_amount = State()
    confirm_category = State()
    waiting_for_purchase_confirmation = State()


class HouseholdPaymentsState(StatesGroup):
    """State machine for household payments flow."""

    waiting_for_answer = State()


class HouseholdSettingsState(StatesGroup):
    """State machine for household payments settings."""

    waiting_for_title = State()
    waiting_for_amount = State()
    waiting_for_removal = State()
    waiting_for_debit_category = State()


class IncomeSettingsState(StatesGroup):
    """State machine for income settings."""

    waiting_for_category_title = State()
    waiting_for_new_category_percent = State()
    waiting_for_removal = State()
    waiting_for_percent_category = State()
    waiting_for_percent = State()

===== Bot/states/wishlist_states.py =====

"""FSM states for wishlist."""
from aiogram.fsm.state import State, StatesGroup


class WishlistState(StatesGroup):
    """State machine for wishlist management."""

    waiting_for_name = State()
    waiting_for_price = State()
    waiting_for_url = State()
    waiting_for_category = State()


class WishlistBytReminderState(StatesGroup):
    """State machine for BYT reminder flow."""

    waiting_answer = State()


class BytDeferState(StatesGroup):
    """State machine for deferring BYT wishlist items."""

    waiting_for_days = State()


class WishlistSettingsState(StatesGroup):
    """States for wishlist settings inputs."""

    waiting_for_category_title = State()
    waiting_for_removal = State()
    waiting_for_purchased_category = State()
    waiting_for_purchased_mode = State()
    waiting_for_purchased_days = State()
    waiting_for_debit_category = State()


class BytSettingsState(StatesGroup):
    """States for BYT settings inputs."""

    waiting_for_max_defer_days = State()


class BytTimerState(StatesGroup):
    """States for BYT timer settings inputs."""

    waiting_for_time_add = State()

===== Bot/utils/__init__.py =====


===== Bot/utils/byt_manual_check.py =====

"""Helpers for manual BYT reminder checks."""

from typing import Any


def parse_byt_manual_cursor_index(raw: Any) -> int:
    """Parse FSM stored cursor index for BYT manual check.

    FSM may store index as int or str. Returns -1 when missing/invalid.
    """
    if raw is None:
        return -1
    try:
        if isinstance(raw, str) and raw.strip() == "":
            return -1
        return int(raw)
    except (TypeError, ValueError):
        return -1


def build_byt_times_sorted(times_by_category: dict[int, list[str]]) -> list[str]:
    """Build a unique sorted list of HH:MM times from category mapping."""

    times: set[str] = set()
    for values in times_by_category.values():
        for value in values:
            cleaned = str(value).strip()
            if cleaned:
                times.add(cleaned)
    return sorted(times)


def select_next_byt_manual_time(
    times_sorted: list[str],
    current_date: str,
    saved_date: str | None,
    index: int,
) -> tuple[str, int, str]:
    """Select next time slot and return selected time, updated index, restart notice."""

    if saved_date != current_date:
        index = -1
    next_index = index + 1
    restart_notice = ""
    if next_index >= len(times_sorted):
        next_index = 0
        restart_notice = "–°–µ–≥–æ–¥–Ω—è –≤—Å–µ –≤—Ä–µ–º–µ–Ω–∞ —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã ‚Äî –Ω–∞—á–∏–Ω–∞—é –∑–∞–Ω–æ–≤–æ."
    return times_sorted[next_index], next_index, restart_notice

===== Bot/utils/byt_render.py =====

"""Rendering helpers for BYT reminders."""

from __future__ import annotations

        try:
            if existing_deferred != deferred_until:
                db.set_wishlist_item_deferred_until(
                    message.from_user.id, defer_item_id, deferred_until.isoformat()
                )
        except Exception as exc:
            LOGGER.error(
                "Failed to set BYT defer days user_id=%s item_id=%s days=%s",
                message.from_user.id if message.from_user else "unknown",
                defer_item_id,
                days,
                exc_info=exc,
            )
            await message.answer("–û—à–∏–±–∫–∞ –ë–î")
            await safe_delete_message(
                message.bot,
                chat_id=message.chat.id,
                message_id=message.message_id,
                logger=LOGGER,
            )
