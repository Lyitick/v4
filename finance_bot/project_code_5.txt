===== Bot/keyboards/__init__.py =====



===== Bot/keyboards/calculator.py =====


"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """–û–±—â–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Å—É–º–º."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å"),
            KeyboardButton(text="0"),
            KeyboardButton(text="‚úÖ –ì–∞–∑"),
        ],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )

===== Bot/keyboards/household.py =====


"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="‚úÖ –î–∞"),
            KeyboardButton(text="‚ùå –ù–µ—Ç"),
            KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/main.py =====


"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")], [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/settings.py =====
"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup

from Bot.constants.ui_labels import (
    WISHLIST_DEBIT_CATEGORY_BACK,
    WISHLIST_DEBIT_CATEGORY_BUTTON,
    WISHLIST_DEBIT_CATEGORY_NONE,
    WISHLIST_BYT_CATEGORY_BUTTON,
)


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting household debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household payments settings."""

    inline_keyboard = [
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:add_payment")],
        [InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:del_payment_menu")],
        [InlineKeyboardButton(text="üîÑ –û–±–Ω—É–ª–∏—Ç—å", callback_data="hp:reset_questions")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_payments_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household payments in settings."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hp:del_payment:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for settings home screen."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="üìä –î–æ—Ö–æ–¥", callback_data="st:income"),
            InlineKeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç", callback_data="st:wishlist"),
        ],
        [InlineKeyboardButton(text="–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="st:byt_rules")],
        [InlineKeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏", callback_data="st:household_payments")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings home screen."""

    buttons = [
        [KeyboardButton(text="üìä –î–æ—Ö–æ–¥"), KeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç")],
        [KeyboardButton(text="–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"), KeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:add_cat"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:del_cat_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –°—Ä–æ–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ", callback_data="wl:purchased_select_category"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for wishlist settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
        ],
        [KeyboardButton(text="üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BUTTON)],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_reply_keyboard(categories: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_purchased_mode_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist purchased mode."""

    buttons = [
        [KeyboardButton(text="–í—Å–µ–≥–¥–∞")],
        [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_NONE)])
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_byt_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚è™ –ù–∞–∑–∞–¥"), KeyboardButton(text="üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=category.get("title", ""),
            callback_data=f"{action_prefix}:{category.get('id')}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_purchased_mode_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist purchased mode."""

    inline_keyboard = [
        [InlineKeyboardButton(text="–í—Å–µ–≥–¥–∞", callback_data="wl:purchased_mode:always")],
        [InlineKeyboardButton(text="–ù–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π", callback_data="wl:purchased_mode:days")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT rules settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(
                text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="byt:toggle_enabled"
            ),
            InlineKeyboardButton(
                text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª", callback_data="byt:toggle_defer"
            ),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å", callback_data="byt:edit_max_defer_days"),
            InlineKeyboardButton(text="‚è∞ –¢–∞–π–º–µ—Ä", callback_data="byt:timer_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT rules settings."""

    buttons = [
        [KeyboardButton(text=WISHLIST_BYT_CATEGORY_BUTTON)],
        [
            KeyboardButton(text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª"),
        ],
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        ],
        [KeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT timer settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:add_time_hour"),
            InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:del_time_menu"),
        ],
        [
            InlineKeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é", callback_data="bt:reset_default"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT timer settings."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è"),
        ],
        [KeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_times_select_reply_keyboard(times: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT timer time."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_timer_times_select_keyboard(times: list[dict], action_prefix: str) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer time."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(
            InlineKeyboardButton(text=label, callback_data=f"{action_prefix}:{timer.get('id')}")
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_back_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with a single back button for settings mode."""

    buttons = [[KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for income settings actions."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:add"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:del_menu"),
        ],
        [
            InlineKeyboardButton(text="‚úèÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã", callback_data="inc:pct_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def income_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for income settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
        ],
        [KeyboardButton(text="‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_categories_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting income category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        title = category.get("title", "")
        percent = category.get("percent", 0)
        row.append(KeyboardButton(text=f"{title} ‚Äî {percent}%"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def income_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting an income category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=f"{category['title']} ({category['percent']}%)",
            callback_data=f"{action_prefix}:{category['id']}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_stub_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for stub sections with back button."""

    return InlineKeyboardMarkup(inline_keyboard=[])


===== Bot/main.py =====


"""Entry point for finance bot."""
import asyncio
import contextlib
import logging
import sys
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramUnauthorizedError

from Bot.config.settings import get_settings
from Bot.database.get_db import get_db
from Bot.handlers import (
    callbacks,
    common,
    finances,
    household_payments,
    settings,
    start,
    wishlist,
)
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.logging import init_logging


def register_routers(dispatcher: Dispatcher) -> None:
    """Register all routers to dispatcher."""

    dispatcher.include_router(start.router)
    dispatcher.include_router(finances.router)
    dispatcher.include_router(household_payments.router)
    dispatcher.include_router(settings.router)
    dispatcher.include_router(wishlist.router)
    dispatcher.include_router(callbacks.router)
    dispatcher.include_router(common.router)


def _token_fingerprint(token: str) -> str:
    if not token:
        return "empty"
    if len(token) <= 8:
        return f"{token[:2]}‚Ä¶{token[-2:]}"
    return f"{token[:4]}‚Ä¶{token[-4:]}"


def _validate_token(token: str) -> list[str]:
    if not token.strip():
        return ["BOT_TOKEN –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω"]

    errors = []
    if ":" not in token:
        errors.append("BOT_TOKEN –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ —Ç–æ–∫–µ–Ω (–Ω–µ—Ç ':')")
    if len(token) < 20:
        errors.append("BOT_TOKEN —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–æ–∂–∏–¥–∞–µ—Ç—Å—è > 20 —Å–∏–º–≤–æ–ª–æ–≤)")
    return errors


def _format_token_context(token_source: str, fingerprint: str, env_path: Path) -> str:
    if token_source == ".env":
        return f"token_source={token_source}, fingerprint={fingerprint}, env_path={env_path}"
    return f"token_source={token_source}, fingerprint={fingerprint}"


async def _run_byt_scheduler(bot: Bot, db, timezone: ZoneInfo) -> None:
    """Background scheduler for BYT reminders."""

    while True:
        now = datetime.now(tz=timezone)
        user_ids = set(db.get_users_with_byt_timer_times()) | set(
            db.get_users_with_active_byt_wishes()
        )
        for uid in user_ids:
            await run_byt_timer_check(bot, db, user_id=uid, run_time=now)
        sleep_for = 60 - now.second - now.microsecond / 1_000_000
        await asyncio.sleep(max(sleep_for, 1))


async def main() -> None:
    """Run bot polling."""

    init_logging()
    settings = get_settings()
    logger = logging.getLogger(__name__)
    token = (settings.bot_token or "").strip()
    token_source = settings.bot_token_source
    fingerprint = _token_fingerprint(token)
    token_context = _format_token_context(token_source, fingerprint, project_root / ".env")

    errors = _validate_token(token)
    for error in errors:
        logger.error("%s (%s)", error, token_context)
    if errors:
        return

    bot = Bot(
        token=token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher()

    db = get_db()
    register_routers(dp)

    try:
        await bot.me()
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
        await bot.session.close()
        return

    reminder_task = asyncio.create_task(
        _run_byt_scheduler(bot, db, settings.timezone)
    )
    try:
        logger.info(
            "Starting bot polling (%s)",
            token_context,
        )
        await dp.start_polling(bot)
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
    except Exception as error:  # noqa: BLE001
        logger.exception("Bot stopped due to error: %s", error)
    finally:
        reminder_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await reminder_task
        await bot.session.close()
        logger.info("Bot shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())

===== Bot/renderers/__init__.py =====


"""Renderer layer package."""

===== Bot/renderers/household.py =====


"""Renderers for household payments UI."""
from __future__ import annotations

import html
from typing import Dict, List

from aiogram.types import InlineKeyboardMarkup

from Bot.keyboards.household import household_payments_inline_keyboard


def render_household_questions_text(
    month: str,
    questions: list[dict],
    answers: dict[str, str],
    current_index: int | None,
) -> str:
    header = f"<b>–ë–´–¢–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò ‚Äî {html.escape(month)}</b>"
    lines = [header]
    for index, question in enumerate(questions, start=1):
        code = str(question.get("code", ""))
        text = html.escape(str(question.get("text", "")).strip())
        text = text.rstrip("?").strip()
        suffix = ""
        answer = answers.get(code)
        if answer == "yes":
            suffix = " ‚úÖ"
        elif answer == "no":
            suffix = " ‚ùå"
        display = text
        if current_index is not None and index - 1 == current_index:
            display = f"<b>{display.upper()}</b>"
        lines.append(f"{index}) {display}{suffix}")
    return "\n".join(lines)


def format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    if not items:
        return "–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π: (–ø—É—Å—Ç–æ)"

    lines = ["–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π:"]
    for index, item in enumerate(items, start=1):
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        code = str(item.get("code", ""))
        status = "‚ùå" if code in unpaid_set else "‚úÖ"
        if amount is not None:
            lines.append(f"{index}) {status} {title} ‚Äî {amount}")
        else:
            lines.append(f"{index}) {status} {title}")
    return "\n".join(lines)


def build_household_question_keyboard(
    question_code: str | None, show_back: bool
) -> InlineKeyboardMarkup:
    return household_payments_inline_keyboard(
        show_back=show_back, question_code=question_code
    )

===== Bot/services/__init__.py =====


"""Service layer package."""

===== Bot/services/household.py =====


"""Business logic for household payments flow."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable


@dataclass
class HouseholdFlowState:
    """Container for household flow state."""

    month: str
    questions: list[dict]
    current_step_index: int
    current_question_code: str | None
    answers: dict[str, str]
    processed_steps: set[str]


def build_household_questions(items: Iterable[dict]) -> list[dict]:
    return [
        {
            "code": str(item.get("code", "")),
            "text": str(item.get("text", "")),
            "amount": item.get("amount"),
        }
        for item in items
        if item.get("code") is not None
    ]


def build_answers_from_status(status_map: dict[str, int]) -> dict[str, str]:
    return {
        str(code): "yes"
        for code, value in status_map.items()
        if int(value) == 1
    }


def filter_unpaid_questions(
    questions: Iterable[dict], unpaid_codes: Iterable[str]
) -> list[dict]:
    unpaid_set = {str(code) for code in unpaid_codes}
    return [question for question in questions if question.get("code") in unpaid_set]


def get_current_question(questions: list[dict], index: int) -> dict | None:
    if index < 0 or index >= len(questions):
        return None
    return questions[index]


def get_next_index(index: int, questions: list[dict]) -> int:
    return min(index + 1, len(questions))


def get_previous_index(index: int) -> int:
    return max(index - 1, 0)


def should_ignore_answer(
    answers: dict[str, str],
    processed_steps: set[str],
    question_code: str,
    action: str,
) -> bool:
    return question_code in processed_steps and answers.get(question_code) == action


def normalize_processed_steps(value: Iterable[str] | None) -> set[str]:
    if not value:
        return set()
    return {str(item) for item in value}


def update_flow_state(
    month: str,
    questions: list[dict],
    current_step_index: int,
    answers: dict[str, str] | None,
    processed_steps: Iterable[str] | None,
) -> HouseholdFlowState:
    current_question = get_current_question(questions, current_step_index)
    return HouseholdFlowState(
        month=month,
        questions=questions,
        current_step_index=current_step_index,
        current_question_code=str(current_question.get("code"))
        if current_question
        else None,
        answers=dict(answers or {}),
        processed_steps=normalize_processed_steps(processed_steps),
    )

===== Bot/states/__init__.py =====



===== Bot/states/money_states.py =====


"""FSM states for money flow."""
from aiogram.fsm.state import State, StatesGroup


class MoneyState(StatesGroup):
    """State machine for income distribution."""

    waiting_for_amount = State()
    confirm_category = State()
    waiting_for_purchase_confirmation = State()


class HouseholdPaymentsState(StatesGroup):
    """State machine for household payments flow."""

    waiting_for_answer = State()


class HouseholdSettingsState(StatesGroup):
    """State machine for household payments settings."""

    waiting_for_title = State()
    waiting_for_amount = State()
    waiting_for_removal = State()
    waiting_for_debit_category = State()


class IncomeSettingsState(StatesGroup):
    """State machine for income settings."""

    waiting_for_category_title = State()
    waiting_for_new_category_percent = State()
    waiting_for_removal = State()
    waiting_for_percent_category = State()
    waiting_for_percent = State()

===== Bot/states/wishlist_states.py =====

"""FSM states for wishlist."""
from aiogram.fsm.state import State, StatesGroup


class WishlistState(StatesGroup):
    """State machine for wishlist management."""

    waiting_for_name = State()
    waiting_for_price = State()
    waiting_for_url = State()
    waiting_for_category = State()


class WishlistBytReminderState(StatesGroup):
    """State machine for BYT reminder flow."""

    waiting_answer = State()


class BytDeferState(StatesGroup):
    """State machine for deferring BYT wishlist items."""

    waiting_for_days = State()


class WishlistSettingsState(StatesGroup):
    """States for wishlist settings inputs."""

    waiting_for_category_title = State()
    waiting_for_removal = State()
    waiting_for_purchased_category = State()
    waiting_for_purchased_mode = State()
    waiting_for_purchased_days = State()
    waiting_for_debit_category = State()
    waiting_for_byt_category = State()


class BytSettingsState(StatesGroup):
    """States for BYT settings inputs."""

    waiting_for_max_defer_days = State()


class BytTimerState(StatesGroup):
    """States for BYT timer settings inputs."""

    waiting_for_removal = State()
    waiting_for_time_add = State()
    waiting_for_hour = State()
    waiting_for_minute = State()
