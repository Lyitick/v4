


===== Bot/keyboards/calculator.py =====

"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """–û–±—â–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Å—É–º–º."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å"),
            KeyboardButton(text="0"),
            KeyboardButton(text="‚úÖ –ì–∞–∑"),
        ],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )



===== Bot/keyboards/household.py =====

"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="‚úÖ –î–∞"),
            KeyboardButton(text="‚ùå –ù–µ—Ç"),
            KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)



===== Bot/keyboards/main.py =====

"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±—ã—Ç")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")], [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)



===== Bot/keyboards/settings.py =====

"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup

from Bot.constants.ui_labels import (
    WISHLIST_DEBIT_CATEGORY_BACK,
    WISHLIST_DEBIT_CATEGORY_BUTTON,
    WISHLIST_DEBIT_CATEGORY_NONE,
)


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting household debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household payments settings."""

    inline_keyboard = [
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:add_payment")],
        [InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:del_payment_menu")],
        [InlineKeyboardButton(text="üîÑ –û–±–Ω—É–ª–∏—Ç—å", callback_data="hp:reset_questions")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_payments_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household payments in settings."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hp:del_payment:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for settings home screen."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="üìä –î–æ—Ö–æ–¥", callback_data="st:income"),
            InlineKeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç", callback_data="st:wishlist"),
        ],
        [InlineKeyboardButton(text="üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è", callback_data="st:byt_rules")],
        [InlineKeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏", callback_data="st:household_payments")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings home screen."""

    buttons = [
        [KeyboardButton(text="üìä –î–æ—Ö–æ–¥"), KeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç")],
        [KeyboardButton(text="üß∫ –ë–´–¢ —É—Å–ª–æ–≤–∏—è"), KeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:add_cat"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:del_cat_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –°—Ä–æ–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ", callback_data="wl:purchased_select_category"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for wishlist settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
        ],
        [KeyboardButton(text="üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BUTTON)],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_reply_keyboard(categories: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_purchased_mode_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist purchased mode."""

    buttons = [
        [KeyboardButton(text="–í—Å–µ–≥–¥–∞")],
        [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_NONE)])
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=category.get("title", ""),
            callback_data=f"{action_prefix}:{category.get('id')}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_purchased_mode_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist purchased mode."""

    inline_keyboard = [
        [InlineKeyboardButton(text="–í—Å–µ–≥–¥–∞", callback_data="wl:purchased_mode:always")],
        [InlineKeyboardButton(text="–ù–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π", callback_data="wl:purchased_mode:days")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT rules settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(
                text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="byt:toggle_enabled"
            ),
            InlineKeyboardButton(
                text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª", callback_data="byt:toggle_defer"
            ),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å", callback_data="byt:edit_max_defer_days"),
            InlineKeyboardButton(text="‚è∞ –¢–∞–π–º–µ—Ä", callback_data="byt:timer_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT rules settings."""

    buttons = [
        [
            KeyboardButton(text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª"),
        ],
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        ],
        [KeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT timer settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:add_time_hour"),
            InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:del_time_menu"),
        ],
        [
            InlineKeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é", callback_data="bt:reset_default"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT timer settings."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è"),
        ],
        [KeyboardButton(text="üîÅ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_times_select_reply_keyboard(times: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT timer time."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_timer_times_select_keyboard(times: list[dict], action_prefix: str) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer time."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for timer in times:
        label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(
            InlineKeyboardButton(text=label, callback_data=f"{action_prefix}:{timer.get('id')}")
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_back_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with a single back button for settings mode."""

    buttons = [[KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for income settings actions."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:add"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:del_menu"),
        ],
        [
            InlineKeyboardButton(text="‚úèÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã", callback_data="inc:pct_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def income_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for income settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
        ],
        [KeyboardButton(text="‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_categories_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting income category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        title = category.get("title", "")
        percent = category.get("percent", 0)
        row.append(KeyboardButton(text=f"{title} ‚Äî {percent}%"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def income_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting an income category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=f"{category['title']} ({category['percent']}%)",
            callback_data=f"{action_prefix}:{category['id']}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_stub_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for stub sections with back button."""

    return InlineKeyboardMarkup(inline_keyboard=[])



===== Bot/main.py =====

"""Entry point for finance bot."""
import asyncio
import contextlib
import logging
import sys
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramUnauthorizedError

from Bot.config.settings import get_settings
from Bot.database.get_db import get_db
from Bot.handlers import (
    callbacks,
    common,
    finances,
    household_payments,
    settings,
    start,
    wishlist,
)
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.logging import init_logging


def register_routers(dispatcher: Dispatcher) -> None:
    """Register all routers to dispatcher."""

    dispatcher.include_router(start.router)
    dispatcher.include_router(finances.router)
    dispatcher.include_router(household_payments.router)
    dispatcher.include_router(settings.router)
    dispatcher.include_router(wishlist.router)
    dispatcher.include_router(callbacks.router)
    dispatcher.include_router(common.router)


def _token_fingerprint(token: str) -> str:
    if not token:
        return "empty"
    if len(token) <= 8:
        return f"{token[:2]}‚Ä¶{token[-2:]}"
    return f"{token[:4]}‚Ä¶{token[-4:]}"


def _validate_token(token: str) -> list[str]:
    if not token.strip():
        return ["BOT_TOKEN –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω"]

    errors = []
    if ":" not in token:
        errors.append("BOT_TOKEN –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ —Ç–æ–∫–µ–Ω (–Ω–µ—Ç ':')")
    if len(token) < 20:
        errors.append("BOT_TOKEN —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–æ–∂–∏–¥–∞–µ—Ç—Å—è > 20 —Å–∏–º–≤–æ–ª–æ–≤)")
    return errors


def _format_token_context(token_source: str, fingerprint: str, env_path: Path) -> str:
    if token_source == ".env":
        return f"token_source={token_source}, fingerprint={fingerprint}, env_path={env_path}"
    return f"token_source={token_source}, fingerprint={fingerprint}"


async def _run_byt_scheduler(bot: Bot, db, timezone: ZoneInfo) -> None:
    """Background scheduler for BYT reminders."""

    while True:
        now = datetime.now(tz=timezone)
        user_ids = set(db.get_users_with_byt_timer_times()) | set(
            db.get_users_with_active_byt_wishes()
        )
        for uid in user_ids:
            await run_byt_timer_check(bot, db, user_id=uid, run_time=now)
        sleep_for = 60 - now.second - now.microsecond / 1_000_000
        await asyncio.sleep(max(sleep_for, 1))


async def main() -> None:
    """Run bot polling."""

    init_logging()
    settings = get_settings()
    logger = logging.getLogger(__name__)
    token = (settings.bot_token or "").strip()
    token_source = settings.bot_token_source
    fingerprint = _token_fingerprint(token)
    token_context = _format_token_context(token_source, fingerprint, project_root / ".env")

    errors = _validate_token(token)
    for error in errors:
        logger.error("%s (%s)", error, token_context)
    if errors:
        return

    bot = Bot(
        token=token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher()

    db = get_db()
    register_routers(dp)

    try:
        await bot.me()
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
        await bot.session.close()
        return

    reminder_task = asyncio.create_task(
        _run_byt_scheduler(bot, db, settings.timezone)
    )
    try:
        logger.info(
            "Starting bot polling (%s)",
            token_context,
        )
        await dp.start_polling(bot)
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
    except Exception as error:  # noqa: BLE001
        logger.exception("Bot stopped due to error: %s", error)
    finally:
        reminder_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await reminder_task
        await bot.session.close()
        logger.info("Bot shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())



===== Bot/renderers/__init__.py =====

"""Renderer layer package."""



===== Bot/renderers/household.py =====

"""Renderers for household payments UI."""
from __future__ import annotations

import html
from typing import Dict, List

from aiogram.types import InlineKeyboardMarkup

from Bot.keyboards.household import household_payments_inline_keyboard


def render_household_questions_text(
    month: str,
    questions: list[dict],
    answers: dict[str, str],
    current_index: int | None,
) -> str:
    header = f"<b>–ë–´–¢–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò ‚Äî {html.escape(month)}</b>"
    lines = [header]
    for index, question in enumerate(questions, start=1):
        code = str(question.get("code", ""))
        text = html.escape(str(question.get("text", "")).strip())
        text = text.rstrip("?").strip()
        suffix = ""
        answer = answers.get(code)
        if answer == "yes":
            suffix = " ‚úÖ"
        elif answer == "no":
            suffix = " ‚ùå"
        display = text
        if current_index is not None and index - 1 == current_index:
            display = f"<b>{display.upper()}</b>"
        lines.append(f"{index}) {display}{suffix}")
    return "\n".join(lines)


def format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    if not items:
        return "–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π: (–ø—É—Å—Ç–æ)"

    lines = ["–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π:"]
    for index, item in enumerate(items, start=1):
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        code = str(item.get("code", ""))
        status = "‚ùå" if code in unpaid_set else "‚úÖ"
        if amount is not None:
            lines.append(f"{index}) {status} {title} ‚Äî {amount}")
        else:
            lines.append(f"{index}) {status} {title}")
    return "\n".join(lines)


def build_household_question_keyboard(
    question_code: str | None, show_back: bool
) -> InlineKeyboardMarkup:
    return household_payments_inline_keyboard(
        show_back=show_back, question_code=question_code
    )



===== Bot/services/__init__.py =====

"""Service layer package."""



===== Bot/services/household.py =====

"""Business logic for household payments flow."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable


@dataclass
class HouseholdFlowState:
    """Container for household flow state."""

    month: str
    questions: list[dict]
    current_step_index: int
    current_question_code: str | None
    answers: dict[str, str]
    processed_steps: set[str]


def build_household_questions(items: Iterable[dict]) -> list[dict]:
    return [
        {
            "code": str(item.get("code", "")),
            "text": str(item.get("text", "")),
            "amount": item.get("amount"),
        }
        for item in items
        if item.get("code") is not None
    ]


def build_answers_from_status(status_map: dict[str, int]) -> dict[str, str]:
    return {
        str(code): "yes"
        for code, value in status_map.items()
        if int(value) == 1
    }


def filter_unpaid_questions(
    questions: Iterable[dict], unpaid_codes: Iterable[str]
) -> list[dict]:
    unpaid_set = {str(code) for code in unpaid_codes}
    return [question for question in questions if question.get("code") in unpaid_set]


def get_current_question(questions: list[dict], index: int) -> dict | None:
    if index < 0 or index >= len(questions):
        return None
    return questions[index]


def get_next_index(index: int, questions: list[dict]) -> int:
    return min(index + 1, len(questions))


def get_previous_index(index: int) -> int:
    return max(index - 1, 0)


def should_ignore_answer(
    answers: dict[str, str],
    processed_steps: set[str],
    question_code: str,
    action: str,
) -> bool:
    return question_code in processed_steps and answers.get(question_code) == action


def normalize_processed_steps(value: Iterable[str] | None) -> set[str]:
    if not value:
        return set()
    return {str(item) for item in value}


def update_flow_state(
    month: str,
    questions: list[dict],
    current_step_index: int,
    answers: dict[str, str] | None,
    processed_steps: Iterable[str] | None,
) -> HouseholdFlowState:
    current_question = get_current_question(questions, current_step_index)
    return HouseholdFlowState(
        month=month,
        questions=questions,
        current_step_index=current_step_index,
        current_question_code=str(current_question.get("code"))
        if current_question
        else None,
        answers=dict(answers or {}),
        processed_steps=normalize_processed_steps(processed_steps),
    )



===== Bot/states/__init__.py =====




===== Bot/states/money_states.py =====

"""FSM states for money flow."""
from aiogram.fsm.state import State, StatesGroup


class MoneyState(StatesGroup):
    """State machine for income distribution."""

    waiting_for_amount = State()
    confirm_category = State()
    waiting_for_purchase_confirmation = State()


class HouseholdPaymentsState(StatesGroup):
    """State machine for household payments flow."""

    waiting_for_answer = State()


class HouseholdSettingsState(StatesGroup):
    """State machine for household payments settings."""

    waiting_for_title = State()
    waiting_for_amount = State()
    waiting_for_removal = State()
    waiting_for_debit_category = State()


class IncomeSettingsState(StatesGroup):
    """State machine for income settings."""

    waiting_for_category_title = State()
    waiting_for_new_category_percent = State()
    waiting_for_removal = State()
    waiting_for_percent_category = State()
    waiting_for_percent = State()



===== Bot/states/wishlist_states.py =====

"""FSM states for wishlist."""
from aiogram.fsm.state import State, StatesGroup


class WishlistState(StatesGroup):
    """State machine for wishlist management."""

    waiting_for_name = State()
    waiting_for_price = State()
    waiting_for_url = State()
    waiting_for_category = State()


class WishlistBytReminderState(StatesGroup):
    """State machine for BYT reminder flow."""

    waiting_answer = State()


class BytDeferState(StatesGroup):
    """State machine for deferring BYT wishlist items."""

    waiting_for_days = State()


class WishlistSettingsState(StatesGroup):
    """States for wishlist settings inputs."""

    waiting_for_category_title = State()
    waiting_for_removal = State()
    waiting_for_purchased_category = State()
    waiting_for_purchased_mode = State()
    waiting_for_purchased_days = State()
    waiting_for_debit_category = State()


class BytSettingsState(StatesGroup):
    """States for BYT settings inputs."""

    waiting_for_max_defer_days = State()


class BytTimerState(StatesGroup):
    """States for BYT timer settings inputs."""

    waiting_for_removal = State()
    waiting_for_time_add = State()
    waiting_for_hour = State()
    waiting_for_minute = State()



===== Bot/utils/__init__.py =====




===== Bot/utils/datetime_utils.py =====

"""Datetime utilities for the bot."""
from datetime import datetime, timedelta

from Bot.config import settings


def now_tz() -> datetime:
    """Return current datetime in configured timezone."""

    return datetime.now(tz=settings.TIMEZONE)


def current_month_str(now: datetime | None = None) -> str:
    """Return current month label as YYYY-MM using configured timezone."""

    current = now or now_tz()
    return f"{current.year:04d}-{current.month:02d}"


def add_one_month(source: datetime) -> datetime:
    """Add one calendar month to datetime without external dependencies."""

    year = source.year + (source.month // 12)
    month = 1 if source.month == 12 else source.month + 1
    last_day = (
        (source.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    ).day
    day = min(source.day, last_day)
    return source.replace(year=year, month=month, day=day)



===== Bot/utils/logging.py =====

"""Logging utilities."""
import logging

from Bot.config.logging_config import setup_logging


def init_logging() -> logging.Logger:
    """Initialize logging and return module logger.

    Returns:
        logging.Logger: Configured logger instance.
    """

    setup_logging()
    return logging.getLogger(__name__)



===== Bot/utils/savings.py =====

"""Savings utility helpers."""
from typing import Any, Dict, List, Tuple


def _fallback_humanize_category(category: str) -> str:
    name = str(category)
    if name.startswith("savings_"):
        name = name[len("savings_") :]
    name = name.replace("_", " ").strip()
    return name or str(category)


def format_savings_summary(
    savings: Dict[str, Dict[str, Any]],
    categories_map: Dict[str, str] | None = None,
) -> str:
    """Format savings summary for user message."""

    if not savings:
        return "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π."

    lines: List[str] = []
    for category, data in savings.items():
        display_name = None
        if categories_map is not None:
            display_name = categories_map.get(str(category))
        if not display_name:
            display_name = _fallback_humanize_category(str(category))
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        purpose = data.get("purpose", "")
        line = f"{display_name}: {current:.2f}"
        if goal and goal > 0:
            progress = min(current / goal * 100, 100)
            extra = f" (—Ü–µ–ª—å {goal:.2f} –¥–ª—è '{purpose}', –ø—Ä–æ–≥—Ä–µ—Å—Å {progress:.1f}%)"
            line = f"{line}{extra}"
        lines.append(line)
    return "\n".join(lines)


def find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> Tuple[str, Dict[str, Any]] | Tuple[None, None]:
    """Find first saving goal that has been reached."""

    for category, data in savings.items():
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        if goal and current >= goal:
            return category, data
    return None, None



===== Bot/utils/telegram_safe.py =====

"""Safe wrappers for Telegram API operations."""
from __future__ import annotations

import asyncio
import logging

from aiohttp import ClientConnectionError, ClientOSError
from aiogram.exceptions import TelegramBadRequest, TelegramNetworkError
from aiogram.types import ReplyKeyboardMarkup, ReplyKeyboardRemove

LOGGER = logging.getLogger(__name__)

DEFAULT_REQUEST_TIMEOUT = 30


def _get_logger(logger: logging.Logger | None) -> logging.Logger:
    return logger or LOGGER


def _is_network_error(exc: Exception) -> bool:
    return isinstance(
        exc,
        (
            TelegramNetworkError,
            ClientOSError,
            ClientConnectionError,
            asyncio.TimeoutError,
            TimeoutError,
        ),
    )


def _log_network_error(
    logger: logging.Logger,
    action: str,
    exc: Exception,
    attempt: int,
    retries: int,
) -> None:
    logger.warning(
        "NETWORK_RETRY action=%s attempt=%s/%s error=%s",
        action,
        attempt,
        retries + 1,
        exc,
    )
    if logger.isEnabledFor(logging.DEBUG):
        logger.debug("Network error details for %s", action, exc_info=True)


async def safe_delete_message(
    bot,
    chat_id: int,
    message_id: int,
    *,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> bool:
    """Safely delete a message without raising exceptions."""

    log = _get_logger(logger)
    for attempt in range(retries + 1):
        try:
            await bot.delete_message(
                chat_id=chat_id,
                message_id=message_id,
                request_timeout=request_timeout,
            )
            return True
        except TelegramBadRequest as exc:
            text = str(exc).lower()
            if (
                "message to delete not found" in text
                or "message can't be deleted" in text
                or "message can‚Äôt be deleted" in text
            ):
                log.debug(
                    "Safe delete skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False
            log.warning(
                "Safe delete failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe delete failure details", exc_info=True)
            return False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "delete_message", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False
            log.warning(
                "Safe delete unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe delete unexpected error details", exc_info=True)
            return False
    return False


async def safe_edit_message_text(
    bot,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> bool:
    """Safely edit a message text without raising exceptions."""

    log = _get_logger(logger)
    if isinstance(reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)):
        log.warning("Safe edit skipped due to reply keyboard markup")
        return False

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False
            log.warning(
                "Safe edit unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit unexpected error details", exc_info=True)
            return False
    return False


async def safe_edit_message_text_with_status(
    bot,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> tuple[bool, bool]:
    """Safely edit a message text, reporting network failures."""

    log = _get_logger(logger)
    if isinstance(reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)):
        log.warning("Safe edit skipped due to reply keyboard markup")
        return False, False

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True, False
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True, False
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False, False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False, False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False, True
            log.warning(
                "Safe edit unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit unexpected error details", exc_info=True)
            return False, False
    return False, False


async def safe_send_message(
    bot,
    chat_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
):
    """Safely send a message using bot.send_message without raising exceptions."""

    log = _get_logger(logger)
    normalized = "" if text is None else str(text)
    if not normalized.strip():
        normalized = "."
    for attempt in range(retries + 1):
        try:
            return await bot.send_message(
                chat_id=chat_id,
                text=normalized,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
        except TelegramBadRequest as exc:
            log.warning("Safe send failed: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe send failure details", exc_info=True)
            return None
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "send_message", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return None
            log.warning("Safe send unexpected error: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe send unexpected error details", exc_info=True)
            return None
    return None


async def safe_answer(
    message_or_callback,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> int | None:
    """Safely send a message using .answer without raising exceptions."""

    log = _get_logger(logger)
    for attempt in range(retries + 1):
        try:
            sent = await message_or_callback.answer(
                text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return int(sent.message_id)
        except TelegramBadRequest as exc:
            log.warning("Safe answer failed: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe answer failure details", exc_info=True)
            return None
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "answer", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return None
            log.warning("Safe answer unexpected error: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe answer unexpected error details", exc_info=True)
            return None
    return None


async def safe_callback_answer(
    callback,
    text: str | None = None,
    *,
    show_alert: bool | None = None,
    logger: logging.Logger | None = None,
) -> None:
    """Safely answer a callback query without raising exceptions."""

    log = _get_logger(logger)
    try:
        await callback.answer(text=text, show_alert=show_alert)
    except Exception as exc:  # noqa: BLE001
        if _is_network_error(exc):
            log.warning("Safe callback answer failed due to network error: %s", exc)
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe callback answer network details", exc_info=True)
            return
        log.warning("Safe callback answer unexpected error: %s", exc)
        if log.isEnabledFor(logging.DEBUG):
            log.debug("Safe callback answer unexpected error details", exc_info=True)



===== Bot/utils/text_sanitizer.py =====

"""Text sanitizers for user-facing labels."""
from __future__ import annotations

import re


_TAIL_PATTERNS = [
    r"–Ω–∞\s+—Ç–∏–Ω—å–∫",
    r"–Ω–∞\s+–∞–ª—å—Ñ—É",
    r"–Ω–∞\s+—Å–±–µ—Ä",
    r"–Ω–∞\s+—è–Ω–¥–µ–∫—Å",
]


def sanitize_income_title(text: str) -> str:
    value = str(text or "")
    for pattern in _TAIL_PATTERNS:
        value = re.sub(rf"\s*(?:‚Äî|-|:)?\s*{pattern}", "", value, flags=re.IGNORECASE)
    value = re.sub(r"\s*\(\s*–æ–∑–æ–Ω\s*\)", "", value, flags=re.IGNORECASE)
    value = re.sub(r"\(\s*\)", "", value)
    value = re.sub(r"\s{2,}", " ", value)
    return value.strip(" -‚Äî:\t\n")



===== Bot/utils/ui_cleanup.py =====

import logging
from typing import List

from aiogram import Bot
from aiogram.types import ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.fsm.context import FSMContext

from Bot.database.get_db import get_db
from Bot.utils.telegram_safe import (
    safe_delete_message,
    safe_edit_message_text,
    safe_send_message,
)

LOGGER = logging.getLogger(__name__)


async def ui_register_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Track a UI message id for later cleanup."""

    data = await state.get_data()
    ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    if message_id not in ids:
        ids.append(int(message_id))
    if len(ids) > 300:
        ids = ids[-300:]
    current_chat_id = data.get("ui_chat_id")
    await state.update_data(
        ui_chat_id=current_chat_id if current_chat_id is not None else chat_id,
        ui_tracked_message_ids=ids,
    )


async def ui_register_protected_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    """Track a UI message id that should never be deleted."""

    data = await state.get_data()
    ids: List[int] = list(data.get("ui_protected_message_ids") or [])
    if message_id not in ids:
        ids.append(int(message_id))
    if len(ids) > 300:
        ids = ids[-300:]
    current_chat_id = data.get("ui_chat_id")
    await state.update_data(
        ui_chat_id=current_chat_id if current_chat_id is not None else chat_id,
        ui_protected_message_ids=ids,
    )


async def ui_register_user_message(state: FSMContext, chat_id: int, message_id: int) -> None:
    """Do not track user messages for later cleanup."""

    data = await state.get_data()
    if data.get("ui_chat_id") is None:
        await state.update_data(ui_chat_id=chat_id)


async def ui_safe_delete_message(
    bot: Bot,
    state: FSMContext | None,
    chat_id: int,
    message_id: int,
    log_context: str | None = None,
) -> bool:
    if state is not None:
        welcome_id = await ui_get_welcome_id(state)
        if welcome_id is not None and int(message_id) == int(welcome_id):
            LOGGER.info("SKIP_DELETE_WELCOME message_id=%s", message_id)
            return False
    return await safe_delete_message(
        bot,
        chat_id=chat_id,
        message_id=message_id,
        logger=LOGGER,
    )


async def ui_get_welcome_id(state: FSMContext) -> int | None:
    data = await state.get_data()
    welcome_id = data.get("ui_welcome_message_id")
    return int(welcome_id) if welcome_id is not None else None


async def ui_set_welcome_id(
    state: FSMContext, message_id: int, chat_id: int | None = None
) -> None:
    update = {"ui_welcome_message_id": int(message_id)}
    if chat_id is not None:
        update["ui_chat_id"] = int(chat_id)
    await state.update_data(**update)


async def ui_set_welcome_message(
    bot: Bot, state: FSMContext, chat_id: int, text: str
) -> int:
    welcome_id = await ui_get_welcome_id(state)
    if welcome_id is not None:
        edited = await safe_edit_message_text(
            bot,
            chat_id=chat_id,
            message_id=int(welcome_id),
            text=text,
            logger=LOGGER,
        )
        if edited:
            LOGGER.info("WELCOME reused (chat_id=%s, message_id=%s)", chat_id, welcome_id)
            return int(welcome_id)

    if welcome_id is None:
        db = get_db()
        persisted = db.get_welcome_message_id(chat_id)
        if persisted is not None:
            await ui_set_welcome_id(state, int(persisted), chat_id=chat_id)
            LOGGER.info("WELCOME reused (chat_id=%s, message_id=%s)", chat_id, persisted)
            return int(persisted)

    sent = await safe_send_message(bot, chat_id=chat_id, text=text, logger=LOGGER)
    if sent:
        await ui_set_welcome_id(state, int(sent.message_id), chat_id=chat_id)
        get_db().set_welcome_message_id(chat_id, int(sent.message_id))
        LOGGER.info("WELCOME created (chat_id=%s, message_id=%s)", chat_id, sent.message_id)
        return int(sent.message_id)
    return 0


async def ui_get_protected_ids(state: FSMContext) -> set[int]:
    welcome_id = await ui_get_welcome_id(state)
    if welcome_id is None:
        return set()
    return {int(welcome_id)}


async def ui_set_settings_mode_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_set_screen_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)
    await state.update_data(ui_screen_message_id=int(message_id), ui_chat_id=chat_id)


async def ui_track_message(
    state: FSMContext, chat_id: int, message_id: int
) -> None:
    await ui_register_message(state, chat_id, message_id)


async def ui_cleanup_to_context(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    context_name: str,
    keep_ids: List[int] | None = None,
) -> None:
    data = await state.get_data()
    tracked_ids: List[int] = list(data.get("ui_tracked_message_ids") or [])
    welcome_id = data.get("ui_welcome_message_id")
    protected_ids = await ui_get_protected_ids(state)
    extra_protected_ids = {
        int(item)
        for item in (data.get("ui_protected_message_ids") or [])
        if item is not None
    }
    protected_ids.update(extra_protected_ids)
    keep_id_set = {int(item) for item in (keep_ids or []) if item is not None}
    delete_ids = []
    kept_ids = set()
    for mid in tracked_ids:
        mid_int = int(mid)
        if mid_int in protected_ids:
            kept_ids.add(mid_int)
            continue
        if mid_int in keep_id_set:
            kept_ids.add(mid_int)
            continue
        delete_ids.append(mid_int)
    deleted_count = 0
    for message_id in delete_ids:
        deleted = await ui_safe_delete_message(
            bot,
            state,
            chat_id=chat_id,
            message_id=message_id,
            log_context=f"context={context_name}",
        )
        if deleted:
            deleted_count += 1

    LOGGER.info(
        "UI_CLEANUP context=%s deleted=%s kept=%s welcome_id=%s",
        context_name,
        deleted_count,
        len(kept_ids),
        welcome_id,
    )
    await state.update_data(
        ui_tracked_message_ids=list(
            {
                int(item)
                for item in (keep_ids or [])
                if item is not None and int(item) not in protected_ids
            }
        ),
    )


async def ui_cleanup_messages(bot: Bot, state: FSMContext, *args, **kwargs) -> None:
    data = await state.get_data()
    chat_id = kwargs.get("chat_id") or data.get("ui_chat_id")
    if chat_id is None:
        return
    await ui_cleanup_to_context(bot, state, int(chat_id), "MAIN_MENU")


async def ui_render_screen(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    text: str,
    reply_markup=None,
    parse_mode: str | None = None,
) -> int:
    data = await state.get_data()
    screen_id = data.get("ui_screen_message_id")
    if screen_id is not None and not isinstance(
        reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)
    ):
        edited = await safe_edit_message_text(
            bot,
            chat_id=chat_id,
            message_id=int(screen_id),
            text=text,
            reply_markup=reply_markup,
            parse_mode=parse_mode,
            logger=LOGGER,
        )
        if edited:
            await ui_set_screen_message(state, chat_id, int(screen_id))
            return int(screen_id)
    sent = await safe_send_message(
        bot,
        chat_id=chat_id,
        text=text,
        reply_markup=reply_markup,
        parse_mode=parse_mode,
        logger=LOGGER,
    )
    if sent:
        await ui_set_screen_message(state, chat_id, sent.message_id)
        return int(sent.message_id)
    return int(screen_id or 0)



===== Bot/utils/ui_flow.py =====

import logging
from collections.abc import Awaitable, Callable
from typing import Any

from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from Bot.utils.telegram_safe import safe_delete_message
from Bot.utils.ui_cleanup import ui_get_protected_ids
LOGGER = logging.getLogger(__name__)


async def ui_get(state: FSMContext) -> dict[str, Any]:
    data = await state.get_data()
    return {
        "greeting_id": data.get("ui_welcome_message_id"),
        "tracked_ids": list(data.get("ui_tracked_message_ids") or []),
    }


async def ui_set_greeting(state: FSMContext, message_id: int) -> None:
    ui = await ui_get(state)
    if ui.get("greeting_id") is not None:
        return
    # greeting_id –Ω–µ —É–¥–∞–ª—è–µ–º –Ω–∏–∫–æ–≥–¥–∞
    await state.update_data(ui_welcome_message_id=int(message_id))


async def ui_track(
    state: FSMContext, message_id: int, kind: str, screen: str | None
) -> None:
    ui = await ui_get(state)
    tracked: list[int] = list(ui.get("tracked_ids") or [])
    tracked.append(int(message_id))
    if len(tracked) > 300:
        tracked = tracked[-300:]
    await state.update_data(ui_tracked_message_ids=tracked)


async def ui_set_screen_message(
    state: FSMContext, screen: str, message_id: int
) -> None:
    await ui_track(state, message_id, kind="ui", screen=screen)


async def ui_cleanup_for_transition(
    bot: Bot, state: FSMContext, chat_id: int, keep_greeting: bool = True
) -> None:
    ui = await ui_get(state)
    greeting_id = ui.get("greeting_id") if keep_greeting else None
    tracked: list[int] = list(ui.get("tracked_ids") or [])
    data = await state.get_data()
    protected_ids = await ui_get_protected_ids(state)
    extra_protected_ids = {
        int(item)
        for item in (data.get("ui_protected_message_ids") or [])
        if item is not None
    }
    protected_ids.update(extra_protected_ids)
    ids = [int(item) for item in tracked]
    for message_id in ids:
        if greeting_id and message_id == greeting_id:
            continue
        if message_id in protected_ids:
            continue
        await safe_delete_message(
            bot,
            chat_id=chat_id,
            message_id=message_id,
            logger=LOGGER,
        )
    await state.update_data(ui_tracked_message_ids=[])


async def ui_transition(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    new_screen: str,
    send_screen: Callable[[], Awaitable[Message]],
) -> Message:
    await ui_cleanup_for_transition(bot, state, chat_id, keep_greeting=True)
    sent = await send_screen()
    await ui_set_screen_message(state, new_screen, sent.message_id)
    return sent



===== __init__.py =====




===== docs/AUDIT_REPORT.md =====

# Audit Report (finance_bot v4)

## Found issues
- UI cleanup tracked multiple message lists and could retain welcome in tracked ids.
- Welcome message id was not persisted and could be duplicated after state loss.
- Direct Telegram edit/delete calls could fail on network errors or invalid reply keyboards.
- Income category titles contained bank/service suffixes and older rows were not sanitized.
- Database access used direct `FinanceDatabase()` construction across handlers.

## Fixes applied
- Unified UI tracking to `ui_tracked_message_ids` and excluded welcome from tracked ids after cleanup.
- Added persistent welcome id storage in `ui_pins` table and reused it on startup.
- Implemented safe Telegram operations with retries and guarded edits against reply keyboards.
- Added income title sanitizer and migration to update existing stored titles.
- Introduced `get_db()` for a shared database instance and updated handlers.

## Backlog / Follow-up
- Expand safe Telegram wrapper adoption in remaining handlers and services.
- Add safe reply markup editing helper if required by additional flows.



===== docs/RUNBOOK.md =====

# Runbook

## –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
```bash
python Bot/main.py
```

## –ü—Ä–æ–≥–æ–Ω —Ç–µ—Å—Ç–æ–≤
```bash
pytest
```



===== finance_bot.log =====

[2025-11-25 14:56:00,395] [INFO] [database.crud] Database initialized at C:\Users\admin\PycharmProjects\v4\finance_bot\finance.db
[2025-11-25 14:56:00,396] [INFO] [__main__] Starting bot polling
[2025-11-25 14:56:00,397] [INFO] [aiogram.dispatcher] Start polling
[2025-11-25 14:56:00,637] [INFO] [aiogram.dispatcher] Run polling for bot @IanDyniBot id=8440100118 - '–ú–æ—è –ë–æ–ª—å –Ø–Ω—å–î—É–Ω—å'
[2025-11-25 14:56:00,876] [INFO] [handlers.start] User 838347504 started bot
[2025-11-25 14:56:00,877] [INFO] [aiogram.event] Update id=131879015 is handled. Duration 180 ms by bot id=8440100118
[2025-11-25 14:56:00,897] [INFO] [handlers.start] User 838347504 started bot
[2025-11-25 14:56:00,898] [INFO] [aiogram.event] Update id=131879016 is handled. Duration 199 ms by bot id=8440100118
[2025-11-25 14:56:00,919] [INFO] [handlers.start] User 838347504 started bot
[2025-11-25 14:56:00,919] [INFO] [aiogram.event] Update id=131879017 is handled. Duration 219 ms by bot id=8440100118
[2025-11-25 14:56:00,937] [INFO] [handlers.start] User 838347504 started bot
[2025-11-25 14:56:00,937] [INFO] [aiogram.event] Update id=131879018 is handled. Duration 236 ms by bot id=8440100118
[2025-11-25 14:57:27,080] [INFO] [handlers.start] User 838347504 started bot
[2025-11-25 14:57:27,081] [INFO] [aiogram.event] Update id=131879019 is handled. Duration 84 ms by bot id=8440100118
[2025-11-25 14:57:56,254] [INFO] [handlers.finances] User 838347504 started income calculation
[2025-11-25 14:57:56,255] [INFO] [aiogram.event] Update id=131879020 is handled. Duration 95 ms by bot id=8440100118
[2025-11-25 14:58:00,888] [INFO] [handlers.start] User 838347504 returned to main menu
[2025-11-25 14:58:00,888] [INFO] [aiogram.event] Update id=131879021 is handled. Duration 105 ms by bot id=8440100118
[2025-11-25 14:58:02,102] [INFO] [handlers.finances] User 838347504 started income calculation
[2025-11-25 14:58:02,102] [INFO] [aiogram.event] Update id=131879022 is handled. Duration 79 ms by bot id=8440100118
[2025-11-25 14:58:10,082] [INFO] [aiogram.event] Update id=131879023 is handled. Duration 103 ms by bot id=8440100118
[2025-11-25 14:58:14,297] [INFO] [database.crud] Updated saving for user 838347504 category –¥–æ–ª–≥–∏ by 3000.0
[2025-11-25 14:58:14,480] [INFO] [aiogram.event] Update id=131879024 is handled. Duration 213 ms by bot id=8440100118
[2025-11-25 14:58:22,837] [INFO] [database.crud] Updated saving for user 838347504 category –±—ã—Ç by 2000.0
[2025-11-25 14:58:23,038] [INFO] [aiogram.event] Update id=131879025 is handled. Duration 228 ms by bot id=8440100118
[2025-11-25 14:58:26,322] [INFO] [database.crud] Updated saving for user 838347504 category –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ by 2000.0
[2025-11-25 14:58:26,464] [INFO] [aiogram.event] Update id=131879026 is handled. Duration 161 ms by bot id=8440100118
[2025-11-25 14:58:33,379] [INFO] [database.crud] Updated saving for user 838347504 category —Å–±–µ—Ä–µ–∂–µ–Ω–∏—è by 2000.0
[2025-11-25 14:58:33,586] [INFO] [aiogram.event] Update id=131879027 is handled. Duration 238 ms by bot id=8440100118
[2025-11-25 14:58:36,150] [INFO] [database.crud] Updated saving for user 838347504 category —Å–ø–æ–Ω—Ç–∞–Ω–Ω—ã–µ —Ç—Ä–∞—Ç—ã by 1000.0
[2025-11-25 14:58:36,237] [INFO] [database.crud] Fetched savings for user 838347504
[2025-11-25 14:58:36,314] [INFO] [aiogram.event] Update id=131879028 is handled. Duration 180 ms by bot id=8440100118
[2025-11-25 14:58:53,690] [INFO] [handlers.wishlist] User 838347504 opened wishlist
[2025-11-25 14:58:53,690] [INFO] [aiogram.event] Update id=131879029 is handled. Duration 161 ms by bot id=8440100118
[2025-11-25 14:58:57,875] [INFO] [database.crud] Fetched purchases for user 838347504
[2025-11-25 14:58:57,947] [INFO] [aiogram.event] Update id=131879030 is handled. Duration 75 ms by bot id=8440100118
[2025-11-25 14:58:59,960] [INFO] [aiogram.event] Update id=131879031 is handled. Duration 69 ms by bot id=8440100118
[2025-11-25 14:59:02,045] [INFO] [database.crud] Fetched wishes for user 838347504
[2025-11-25 14:59:02,117] [INFO] [aiogram.event] Update id=131879032 is handled. Duration 73 ms by bot id=8440100118
[2025-11-25 14:59:08,043] [INFO] [handlers.start] User 838347504 returned to main menu
[2025-11-25 14:59:08,044] [INFO] [aiogram.event] Update id=131879033 is handled. Duration 70 ms by bot id=8440100118
[2025-11-25 14:59:10,023] [INFO] [handlers.wishlist] User 838347504 opened wishlist
[2025-11-25 14:59:10,023] [INFO] [aiogram.event] Update id=131879034 is handled. Duration 160 ms by bot id=8440100118
[2025-11-25 14:59:14,674] [INFO] [database.crud] Fetched wishes for user 838347504
[2025-11-25 14:59:14,749] [INFO] [aiogram.event] Update id=131879035 is handled. Duration 75 ms by bot id=8440100118
[2025-11-25 14:59:17,760] [INFO] [database.crud] Fetched wishes for user 838347504
[2025-11-25 14:59:17,829] [INFO] [aiogram.event] Update id=131879036 is not handled. Duration 69 ms by bot id=8440100118
[2025-11-25 14:59:17,830] [ERROR] [aiogram.event] Cause exception while process update id=131879036 by bot id=8440100118
TelegramBadRequest: Telegram server says - Bad Request: message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message
Traceback (most recent call last):
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\dispatcher.py", line 309, in _process_update
    response = await self.feed_update(bot, update, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\dispatcher.py", line 158, in feed_update
    response = await self.update.wrap_outer_middleware(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<7 lines>...
    )
    ^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\middlewares\error.py", line 25, in __call__
    return await handler(event, data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\middlewares\user_context.py", line 56, in __call__
    return await handler(event, data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\fsm\middleware.py", line 42, in __call__
    return await handler(event, data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\event\telegram.py", line 121, in trigger
    return await wrapped_inner(event, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\event\handler.py", line 43, in call
    return await wrapped()
           ^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\dispatcher.py", line 276, in _listen_update
    return await self.propagate_event(update_type=update_type, event=event, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\router.py", line 146, in propagate_event
    return await observer.wrap_outer_middleware(_wrapped, event=event, data=kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\router.py", line 141, in _wrapped
    return await self._propagate_event(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        observer=observer, update_type=update_type, event=telegram_event, **data
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "C:\Users\admin\AppData\Local\Programs\Python\Python313\Lib\site-packages\aiogram\dispatcher\router.py", line 174, in _propagate_event
    response = await router.propagate_event(update_type=update_type, event=event, **kwargs)