            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        if wish:
            category_id, category_title = _resolve_wish_category(db, message.from_user.id, wish)
            due_items, deferred_items = get_byt_category_items(
                db, message.from_user.id, category_title, now_tz()
            )
            checklist_text = format_byt_category_checklist_text(
                category_title, due_items, deferred_items
            )
            message_text = format_byt_defer_confirmation_text(
                wish, category_title, deferred_until, checklist_text
            )
            category_row = db.get_wishlist_category_by_title(message.from_user.id, category_title)
            category_ref = int(category_row["id"]) if category_row else category_id
            keyboard = (
                _build_byt_items_keyboard(
                    due_items,
                    allow_defer=bool(settings_row.get("byt_defer_enabled", 1)),
                    category_id=category_ref,
                )
                if due_items
                else None
            )
            if reminder_message_id:
                edited = await safe_edit_message_text(
                    message.bot,
                    chat_id=message.chat.id,
                    message_id=int(reminder_message_id),
                    text=message_text,
                    reply_markup=keyboard,
                    logger=LOGGER,
                )
                if not edited:
                    sent = await message.answer(message_text, reply_markup=keyboard)
                    if sent:
                        await ui_register_message(state, sent.chat.id, sent.message_id)
            else:
                sent = await message.answer(message_text, reply_markup=keyboard)
                if sent:
                    await ui_register_message(state, sent.chat.id, sent.message_id)
            await message.answer(" ", reply_markup=ReplyKeyboardRemove())
        else:
            await message.answer(
                f"–û—Ç–ª–æ–∂–µ–Ω–æ –Ω–∞ {days} –¥–Ω.", reply_markup=ReplyKeyboardRemove()
            )

        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        new_display_message_id = prompt.message_id
        new_display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(
    BytDeferState.waiting_for_days,
    F.text.regexp(r"^\\s*\\+?\\d+\\s*$"),
)
async def handle_byt_defer_days_manual(message: Message, state: FSMContext) -> None:
    """Handle manual numeric input for BYT defer days."""

    value = parse_positive_int(message.text or "")
    if value is None:
        await message.answer(f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return

    data = await state.get_data()
    display_chat_id = data.get("defer_display_chat_id", message.chat.id)
    display_message_id = data.get("defer_display_message_id")
    new_sum = str(value)

    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            display_message_id = prompt.message_id
            display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        display_message_id = prompt.message_id
        display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=display_message_id,
        defer_display_chat_id=display_chat_id,
    )
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(BytDeferState.waiting_for_days)
async def handle_byt_defer_days_invalid(message: Message) -> None:
    """Prompt to use calculator buttons for defer days."""

    await message.answer(f"{ERR_INVALID_INPUT} –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")

===== Bot/keyboards/__init__.py =====


===== Bot/keyboards/calculator.py =====

"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """–û–±—â–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Å—É–º–º."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å"),
            KeyboardButton(text="0"),
            KeyboardButton(text="‚úÖ –ì–∞–∑"),
        ],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )

===== Bot/keyboards/household.py =====

"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="‚úÖ –î–∞"),
            KeyboardButton(text="‚ùå –ù–µ—Ç"),
            KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/main.py =====

"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ—Ö–æ–¥")], [KeyboardButton(text="üìã –í–∏—à–ª–∏—Å—Ç")]]
    if show_household:
        buttons.append([KeyboardButton(text="–ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")])
    if show_settings:
        buttons.append([KeyboardButton(text="‚öôÔ∏è")])
    if show_test_button:
        buttons.append([KeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è")])  # TODO: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="–î–∞"), KeyboardButton(text="–ù–µ—Ç")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm_yes"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="‚ûï"), KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")], [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="–ö—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        row.append(
            InlineKeyboardButton(
                text=category.get("title", ""),
                callback_data=f"wlcat:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_url_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for skipping wishlist URL input."""

    buttons = [[InlineKeyboardButton(text="—Å–∫–∏–ø", callback_data="wishlist_skip_url")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def purchase_confirmation_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for confirming purchase suggestion."""

    buttons = [[KeyboardButton(text="‚úÖ –ö—É–ø–∏–ª"), KeyboardButton(text="üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def income_confirm_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with confirm income button."""

    buttons = [[InlineKeyboardButton(text="‚úÖ –ü–æ–ª—É—á–µ–Ω–æ", callback_data="income_confirm")]]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/settings.py =====

"""Settings keyboards."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup

from Bot.constants.ui_labels import (
    WISHLIST_DEBIT_CATEGORY_BACK,
    WISHLIST_DEBIT_CATEGORY_BUTTON,
    WISHLIST_DEBIT_CATEGORY_NONE,
    WISHLIST_BYT_CATEGORY_BUTTON,
)


def settings_menu_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings menu."""

    buttons = [
        [KeyboardButton(text="‚öôÔ∏è –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏ ‚öôÔ∏è")],
        [KeyboardButton(text="‚è™ –ù–∞ –≥–ª–∞–≤–Ω—É—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household settings actions."""

    buttons = [
        [
            InlineKeyboardButton(text="‚ûï", callback_data="hh_set:add"),
            InlineKeyboardButton(text="‚ûñ", callback_data="hh_set:del"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def household_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household items."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hh_set:remove:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for household payments settings actions."""

    buttons = [
        [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å"), KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å")],
        [KeyboardButton(text="üí∞ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å–ø–∏—Å–∞–Ω–∏—è"), KeyboardButton(text="üßπ –û–±–Ω—É–ª–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def household_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting household debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_remove_reply_keyboard(
    items: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for removing household payments in settings."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def household_payments_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for household payments settings."""

    inline_keyboard = [
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:add_payment")],
        [InlineKeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data="hp:del_payment_menu")],
        [InlineKeyboardButton(text="üîÑ –û–±–Ω—É–ª–∏—Ç—å", callback_data="hp:reset_questions")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def household_payments_remove_keyboard(items: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for removing household payments in settings."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    for item in items:
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        label = f"{title} ‚Äî {amount}" if amount is not None else title
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"hp:del_payment:{item.get('code', '')}",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for settings home screen."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="üìä –î–æ—Ö–æ–¥", callback_data="st:income"),
            InlineKeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç", callback_data="st:wishlist"),
        ],
        [InlineKeyboardButton(text="–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="st:byt_rules")],
        [InlineKeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏", callback_data="st:household_payments")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_home_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for settings home screen."""

    buttons = [
        [KeyboardButton(text="üìä –î–æ—Ö–æ–¥"), KeyboardButton(text="üßæ –í–∏—à–ª–∏—Å—Ç")],
        [KeyboardButton(text="–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"), KeyboardButton(text="üßæ –ë—ã—Ç–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for wishlist settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:add_cat"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="wl:del_cat_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –°—Ä–æ–∫ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ", callback_data="wl:purchased_select_category"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for wishlist settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–∏—à–ª–∏—Å—Ç–∞"),
        ],
        [KeyboardButton(text="üïí –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∫—É–ø–ª–µ–Ω–Ω–æ–µ")],
        [KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BUTTON)],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_categories_select_reply_keyboard(categories: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_purchased_mode_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist purchased mode."""

    buttons = [
        [KeyboardButton(text="–í—Å–µ–≥–¥–∞")],
        [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–Ω–∏")],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_debit_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting wishlist debit category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_NONE)])
    rows.append([KeyboardButton(text=WISHLIST_DEBIT_CATEGORY_BACK)])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def wishlist_byt_category_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT wishlist category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        row.append(KeyboardButton(text=category.get("title", "")))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚è™ –ù–∞–∑–∞–¥"), KeyboardButton(text="üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_category_toggle_keyboard(categories: list[dict]) -> InlineKeyboardMarkup:
    """Inline keyboard for toggling BYT categories."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        enabled = bool(category.get("enabled", 0))
        label = f"{'‚úÖ' if enabled else '‚ùå'} {category.get('title', '')}"
        next_state = 0 if enabled else 1
        row.append(
            InlineKeyboardButton(
                text=label,
                callback_data=f"byt:category_toggle:{category.get('id')}:{next_state}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.append(
        [
            InlineKeyboardButton(text="‚è™ –ù–∞–∑–∞–¥", callback_data="st:byt_rules"),
            InlineKeyboardButton(text="üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="st:home"),
        ]
    )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=category.get("title", ""),
            callback_data=f"{action_prefix}:{category.get('id')}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_categories_inline_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        enabled = bool(category.get("enabled", 0))
        label = f"{'‚úÖ' if enabled else '‚ùå'} {category.get('title', '')}"
        row.append(
            InlineKeyboardButton(
                text=label,
                callback_data=f"{action_prefix}:{category.get('id')}",
            )
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.append(
        [
            InlineKeyboardButton(text="‚è™ –ù–∞–∑–∞–¥", callback_data="st:byt_rules"),
            InlineKeyboardButton(text="üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="st:home"),
        ]
    )
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def wishlist_purchased_mode_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for selecting wishlist purchased mode."""

    inline_keyboard = [
        [InlineKeyboardButton(text="–í—Å–µ–≥–¥–∞", callback_data="wl:purchased_mode:always")],
        [InlineKeyboardButton(text="–ù–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π", callback_data="wl:purchased_mode:days")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT rules settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(
                text="–í—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π", callback_data="wl:byt_category_menu"
            )
        ],
        [
            InlineKeyboardButton(
                text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="byt:toggle_enabled"
            ),
            InlineKeyboardButton(
                text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª", callback_data="byt:toggle_defer"
            ),
        ],
        [
            InlineKeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å", callback_data="byt:edit_max_defer_days"),
            InlineKeyboardButton(text="‚è∞ –í—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π", callback_data="byt:timer_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_rules_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT rules settings."""

    buttons = [
        [KeyboardButton(text=WISHLIST_BYT_CATEGORY_BUTTON)],
        [
            KeyboardButton(text="üîÅ –í–∫–ª/–í—ã–∫–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            KeyboardButton(text="üîÅ –û–¢–õ–û–ñ–ò–¢–¨ –í–∫–ª/–í—ã–∫–ª"),
        ],
        [KeyboardButton(text="‚è∞ –í—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π")],
        [KeyboardButton(text="‚è≥ –ú–∞–∫—Å. –¥–Ω–∏ –æ—Ç–ª–æ–∂–∏—Ç—å")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for BYT timer settings."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:add_time"),
            InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è", callback_data="bt:del_time_menu"),
        ],
        [
            InlineKeyboardButton(text="‚è™ –ù–∞–∑–∞–¥", callback_data="byt:timer_menu"),
            InlineKeyboardButton(text="üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="st:home"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def byt_timer_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for BYT timer settings."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º—è"),
            KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º—è"),
        ],
        [KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def byt_timer_times_select_reply_keyboard(times: list[dict]) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting BYT timer time."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for timer in times:
        if timer.get("time_hhmm"):
            label = str(timer.get("time_hhmm"))
        else:
            label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
        row.append(KeyboardButton(text=label))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def byt_timer_times_select_keyboard(times: list[dict], action_prefix: str) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting BYT timer time."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for timer in times:
        if timer.get("time_hhmm"):
            label = str(timer.get("time_hhmm"))
            callback_value = label
        else:
            label = f"{int(timer.get('hour', 0)):02d}:{int(timer.get('minute', 0)):02d}"
            callback_value = str(timer.get("id"))
        row.append(
            InlineKeyboardButton(text=label, callback_data=f"{action_prefix}:{callback_value}")
        )
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_back_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with a single back button for settings mode."""

    buttons = [[KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_settings_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for income settings actions."""

    inline_keyboard = [
        [
            InlineKeyboardButton(text="‚ûï –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:add"),
            InlineKeyboardButton(text="‚ûñ –ö–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="inc:del_menu"),
        ],
        [
            InlineKeyboardButton(text="‚úèÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã", callback_data="inc:pct_menu"),
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def income_settings_reply_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard for income settings actions."""

    buttons = [
        [
            KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
            KeyboardButton(text="‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞"),
        ],
        [KeyboardButton(text="‚öôÔ∏è –ü—Ä–æ—Ü–µ–Ω—Ç—ã –¥–æ—Ö–æ–¥–æ–≤")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def income_categories_select_reply_keyboard(
    categories: list[dict],
) -> ReplyKeyboardMarkup:
    """Reply keyboard for selecting income category."""

    rows: list[list[KeyboardButton]] = []
    row: list[KeyboardButton] = []
    for category in categories:
        title = category.get("title", "")
        percent = category.get("percent", 0)
        row.append(KeyboardButton(text=f"{title} ‚Äî {percent}%"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([KeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def income_categories_select_keyboard(
    categories: list[dict], action_prefix: str
) -> InlineKeyboardMarkup:
    """Inline keyboard for selecting an income category."""

    inline_keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for category in categories:
        button = InlineKeyboardButton(
            text=f"{category['title']} ({category['percent']}%)",
            callback_data=f"{action_prefix}:{category['id']}",
        )
        row.append(button)
        if len(row) == 2:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def settings_stub_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard for stub sections with back button."""

    return InlineKeyboardMarkup(inline_keyboard=[])

===== Bot/main.py =====

"""Entry point for finance bot."""
import asyncio
import contextlib
import logging
import sys
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramUnauthorizedError

from Bot.config.settings import get_settings
from Bot.database.get_db import get_db
from Bot.handlers import (
    callbacks,
    common,
    finances,
    household_payments,
    settings,
    start,
    wishlist,
)
from Bot.handlers.wishlist import run_byt_timer_check
from Bot.utils.logging import init_logging


def register_routers(dispatcher: Dispatcher) -> None:
    """Register all routers to dispatcher."""

    dispatcher.include_router(start.router)
    dispatcher.include_router(finances.router)
    dispatcher.include_router(household_payments.router)
    dispatcher.include_router(settings.router)
    dispatcher.include_router(wishlist.router)
    dispatcher.include_router(callbacks.router)
    dispatcher.include_router(common.router)


def _token_fingerprint(token: str) -> str:
    if not token:
        return "empty"
    if len(token) <= 8:
        return f"{token[:2]}‚Ä¶{token[-2:]}"
    return f"{token[:4]}‚Ä¶{token[-4:]}"


def _validate_token(token: str) -> list[str]:
    if not token.strip():
        return ["BOT_TOKEN –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω"]

    errors = []
    if ":" not in token:
        errors.append("BOT_TOKEN –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ —Ç–æ–∫–µ–Ω (–Ω–µ—Ç ':')")
    if len(token) < 20:
        errors.append("BOT_TOKEN —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–æ–∂–∏–¥–∞–µ—Ç—Å—è > 20 —Å–∏–º–≤–æ–ª–æ–≤)")
    return errors


def _format_token_context(token_source: str, fingerprint: str, env_path: Path) -> str:
    if token_source == ".env":
        return f"token_source={token_source}, fingerprint={fingerprint}, env_path={env_path}"
    return f"token_source={token_source}, fingerprint={fingerprint}"


async def _run_byt_scheduler(bot: Bot, db, timezone: ZoneInfo) -> None:
    """Background scheduler for BYT reminders."""

    while True:
        now = datetime.now(tz=timezone)
        user_ids = set(db.get_users_with_byt_reminder_times()) | set(
            db.get_users_with_active_byt_wishes()
        )
        for uid in user_ids:
            await run_byt_timer_check(bot, db, user_id=uid, run_time=now)
        sleep_for = 60 - now.second - now.microsecond / 1_000_000
        await asyncio.sleep(max(sleep_for, 1))


async def main() -> None:
    """Run bot polling."""

    init_logging()
    settings = get_settings()
    logger = logging.getLogger(__name__)
    token = (settings.bot_token or "").strip()
    token_source = settings.bot_token_source
    fingerprint = _token_fingerprint(token)
    token_context = _format_token_context(token_source, fingerprint, project_root / ".env")

    errors = _validate_token(token)
    for error in errors:
        logger.error("%s (%s)", error, token_context)
    if errors:
        return

    bot = Bot(
        token=token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    dp = Dispatcher()

    db = get_db()
    register_routers(dp)

    try:
        await bot.me()
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
        await bot.session.close()
        return

    reminder_task = asyncio.create_task(
        _run_byt_scheduler(bot, db, settings.timezone)
    )
    try:
        logger.info(
            "Starting bot polling (%s)",
            token_context,
        )
        await dp.start_polling(bot)
    except TelegramUnauthorizedError:
        logger.error(
            "Unauthorized: —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π/–æ—Ç–æ–∑–≤–∞–Ω/–±–æ—Ç —É–¥–∞–ª—ë–Ω. "
            "–ü—Ä–æ–≤–µ—Ä—å BotFather –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è. "
            "(%s)",
            token_context,
        )
    except Exception as error:  # noqa: BLE001
        logger.exception("Bot stopped due to error: %s", error)
    finally:
        reminder_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await reminder_task
        await bot.session.close()
        logger.info("Bot shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())

===== Bot/renderers/__init__.py =====

"""Renderer layer package."""

===== Bot/renderers/household.py =====

"""Renderers for household payments UI."""
from __future__ import annotations

import html
from typing import Dict, List

from aiogram.types import InlineKeyboardMarkup

from Bot.keyboards.household import household_payments_inline_keyboard


def render_household_questions_text(
    month: str,
    questions: list[dict],
    answers: dict[str, str],
    current_index: int | None,
) -> str:
    header = f"<b>–ë–´–¢–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò ‚Äî {html.escape(month)}</b>"
    lines = [header]
    for index, question in enumerate(questions, start=1):
        code = str(question.get("code", ""))
        text = html.escape(str(question.get("text", "")).strip())
        text = text.rstrip("?").strip()
        suffix = ""
        answer = answers.get(code)
        if answer == "yes":
            suffix = " ‚úÖ"
        elif answer == "no":
            suffix = " ‚ùå"
        display = text
        if current_index is not None and index - 1 == current_index:
            display = f"<b>{display.upper()}</b>"
        lines.append(f"{index}) {display}{suffix}")
    return "\n".join(lines)


def format_household_items(
    items: List[Dict[str, int | str]],
    unpaid_set: set[str],
) -> str:
    if not items:
        return "–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π: (–ø—É—Å—Ç–æ)"

    lines = ["–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π:"]
    for index, item in enumerate(items, start=1):
        title = str(item.get("text", "")).rstrip("?")
        amount = item.get("amount")
        code = str(item.get("code", ""))
        status = "‚ùå" if code in unpaid_set else "‚úÖ"
        if amount is not None:
            lines.append(f"{index}) {status} {title} ‚Äî {amount}")
        else:
            lines.append(f"{index}) {status} {title}")
    return "\n".join(lines)


def build_household_question_keyboard(
    question_code: str | None, show_back: bool
) -> InlineKeyboardMarkup:
    return household_payments_inline_keyboard(
        show_back=show_back, question_code=question_code
    )

===== Bot/services/__init__.py =====

"""Service layer package."""

===== Bot/services/household.py =====

"""Business logic for household payments flow."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable


@dataclass
class HouseholdFlowState:
    """Container for household flow state."""

    month: str
    questions: list[dict]
    current_step_index: int
    current_question_code: str | None
    answers: dict[str, str]
    processed_steps: set[str]


def build_household_questions(items: Iterable[dict]) -> list[dict]:
    return [
        {
            "code": str(item.get("code", "")),
            "text": str(item.get("text", "")),
            "amount": item.get("amount"),
        }
        for item in items
        if item.get("code") is not None
    ]


def build_answers_from_status(status_map: dict[str, int]) -> dict[str, str]:
    return {
        str(code): "yes"
        for code, value in status_map.items()
        if int(value) == 1
    }


def filter_unpaid_questions(
    questions: Iterable[dict], unpaid_codes: Iterable[str]
) -> list[dict]:
    unpaid_set = {str(code) for code in unpaid_codes}
    return [question for question in questions if question.get("code") in unpaid_set]


def get_current_question(questions: list[dict], index: int) -> dict | None:
    if index < 0 or index >= len(questions):
        return None
    return questions[index]


def get_next_index(index: int, questions: list[dict]) -> int:
    return min(index + 1, len(questions))


def get_previous_index(index: int) -> int:
    return max(index - 1, 0)


def should_ignore_answer(
    answers: dict[str, str],
    processed_steps: set[str],
    question_code: str,
    action: str,
) -> bool:
    return question_code in processed_steps and answers.get(question_code) == action


def normalize_processed_steps(value: Iterable[str] | None) -> set[str]:
    if not value:
        return set()
    return {str(item) for item in value}


def update_flow_state(
    month: str,
    questions: list[dict],
    current_step_index: int,
    answers: dict[str, str] | None,
    processed_steps: Iterable[str] | None,
) -> HouseholdFlowState:
    current_question = get_current_question(questions, current_step_index)
    return HouseholdFlowState(
        month=month,
        questions=questions,
        current_step_index=current_step_index,
        current_question_code=str(current_question.get("code"))
        if current_question
        else None,
        answers=dict(answers or {}),
        processed_steps=normalize_processed_steps(processed_steps),
    )

===== Bot/states/__init__.py =====


===== Bot/states/money_states.py =====

"""FSM states for money flow."""
from aiogram.fsm.state import State, StatesGroup


class MoneyState(StatesGroup):
    """State machine for income distribution."""

    waiting_for_amount = State()
    confirm_category = State()
    waiting_for_purchase_confirmation = State()


class HouseholdPaymentsState(StatesGroup):
    """State machine for household payments flow."""

    waiting_for_answer = State()


class HouseholdSettingsState(StatesGroup):
    """State machine for household payments settings."""

    waiting_for_title = State()
    waiting_for_amount = State()
    waiting_for_removal = State()
    waiting_for_debit_category = State()


class IncomeSettingsState(StatesGroup):
    """State machine for income settings."""

    waiting_for_category_title = State()
    waiting_for_new_category_percent = State()
    waiting_for_removal = State()
    waiting_for_percent_category = State()
    waiting_for_percent = State()

===== Bot/states/wishlist_states.py =====

"""FSM states for wishlist."""
from aiogram.fsm.state import State, StatesGroup


class WishlistState(StatesGroup):
    """State machine for wishlist management."""

    waiting_for_name = State()
    waiting_for_price = State()
    waiting_for_url = State()
    waiting_for_category = State()


class WishlistBytReminderState(StatesGroup):
    """State machine for BYT reminder flow."""

    waiting_answer = State()


class BytDeferState(StatesGroup):
    """State machine for deferring BYT wishlist items."""

    waiting_for_days = State()


class WishlistSettingsState(StatesGroup):
    """States for wishlist settings inputs."""

    waiting_for_category_title = State()
    waiting_for_removal = State()
    waiting_for_purchased_category = State()
    waiting_for_purchased_mode = State()
    waiting_for_purchased_days = State()
    waiting_for_debit_category = State()


class BytSettingsState(StatesGroup):
    """States for BYT settings inputs."""

    waiting_for_max_defer_days = State()


class BytTimerState(StatesGroup):
    """States for BYT timer settings inputs."""

    waiting_for_time_add = State()

===== Bot/utils/__init__.py =====


===== Bot/utils/byt_manual_check.py =====

"""Helpers for manual BYT reminder checks."""

from typing import Any


def parse_byt_manual_cursor_index(raw: Any) -> int:
    """Parse FSM stored cursor index for BYT manual check.

    FSM may store index as int or str. Returns -1 when missing/invalid.
    """
    if raw is None:
        return -1
    try:
        if isinstance(raw, str) and raw.strip() == "":
            return -1
        return int(raw)
    except (TypeError, ValueError):
        return -1


def build_byt_times_sorted(times_by_category: dict[int, list[str]]) -> list[str]:
    """Build a unique sorted list of HH:MM times from category mapping."""

    times: set[str] = set()
    for values in times_by_category.values():
        for value in values:
            cleaned = str(value).strip()
            if cleaned:
                times.add(cleaned)
    return sorted(times)


def select_next_byt_manual_time(
    times_sorted: list[str],
    current_date: str,
    saved_date: str | None,
    index: int,
) -> tuple[str, int, str]:
    """Select next time slot and return selected time, updated index, restart notice."""

    if saved_date != current_date:
        index = -1
    next_index = index + 1
    restart_notice = ""
    if next_index >= len(times_sorted):
        next_index = 0
        restart_notice = "–°–µ–≥–æ–¥–Ω—è –≤—Å–µ –≤—Ä–µ–º–µ–Ω–∞ —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã ‚Äî –Ω–∞—á–∏–Ω–∞—é –∑–∞–Ω–æ–≤–æ."
    return times_sorted[next_index], next_index, restart_notice

===== Bot/utils/byt_render.py =====

"""Rendering helpers for BYT reminders."""

from __future__ import annotations

from datetime import datetime

from Bot.database.crud import FinanceDatabase


def format_byt_item_price(item: dict) -> str:
    price = item.get("price")
    if price in (None, "", 0):
        return ""
    try:
        value = float(price)
    except (TypeError, ValueError):
        return ""
    if value <= 0:
        return ""
    if value.is_integer():
        return f"{int(value)}—Ä"
    return f"{value:.2f}".rstrip("0").rstrip(".") + "—Ä"


def format_byt_item_line(item: dict) -> str:
    name = str(item.get("name", "")).strip()
    price_label = format_byt_item_price(item)
    if price_label:
        return f"‚Ä¢ {name} ‚Äî {price_label}"
    return f"‚Ä¢ {name}"


def parse_deferred_until(value: str | None) -> datetime | None:
    if not value:
        return None
    try:
        return datetime.fromisoformat(str(value))
    except ValueError:
        return None


def format_byt_category_checklist_text(
    category_title: str, due_items: list[dict], deferred_items: list[dict]
) -> str:
    lines: list[str] = [f"üìã –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category_title}", ""]
    if not due_items and not deferred_items:
        lines.append("–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.")
        return "\n".join(lines)

    if due_items:
        lines.append("üü¢ –ü–æ—Ä–∞ –∫—É–ø–∏—Ç—å:")
        for item in due_items:
            lines.append(format_byt_item_line(item))
        lines.append("")

    if deferred_items:
        lines.append("‚è≥ –û—Ç–ª–æ–∂–µ–Ω–æ:")
        for item in deferred_items:
            deferred_until = parse_deferred_until(item.get("deferred_until"))
            if deferred_until:
                lines.append(
                    f"{format_byt_item_line(item)} (–¥–æ {deferred_until.strftime('%Y-%m-%d %H:%M')})"
                )
            else:
                lines.append(format_byt_item_line(item))
    return "\n".join(lines)


def format_byt_categories_status_text(categories: list[dict]) -> str:
    """Format BYT reminder category statuses as a checklist."""

    lines = ["–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π:", ""]
    if categories:
        for category in categories:
            status = "‚úÖ" if category.get("enabled") else "‚ùå"
            lines.append(f"{status} {category.get('title', '')}")
    else:
        lines.append("–ö–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ–∫–∞ –Ω–µ—Ç.")
    return "\n".join(lines)


def format_byt_defer_confirmation_text(
    item: dict, category_title: str, deferred_until: datetime, checklist_text: str
) -> str:
    price_label = format_byt_item_price(item)
    price_part = f", —Å—É–º–º–∞: {price_label}" if price_label else ""
    lines = [
        f"‚úÖ –û—Ç–ª–æ–∂–µ–Ω–æ: ¬´{item.get('name', '')}¬ª (–∫–∞—Ç–µ–≥–æ—Ä–∏—è: {category_title}{price_part})",
        f"‚è∞ –î–æ: {deferred_until.strftime('%Y-%m-%d %H:%M')}",
        "",
        checklist_text,
    ]
    return "\n".join(lines)


def get_byt_category_items(
    db: FinanceDatabase, user_id: int, category_title: str, now_dt: datetime
) -> tuple[list[dict], list[dict]]:
    total_items = db.get_active_byt_wishes(user_id, category_title)
    due_items = db.list_active_byt_items_for_reminder(user_id, now_dt, category_title)
    due_ids = {int(item.get("id")) for item in due_items if item.get("id") is not None}
    deferred_items = [
        item
        for item in total_items
        if item.get("id") is not None and int(item.get("id")) not in due_ids
    ]
    return due_items, deferred_items

===== Bot/utils/byt_utils.py =====

"""Utilities for BYT reminder source category."""

from __future__ import annotations

import logging
from typing import Optional

from Bot.database.crud import FinanceDatabase

LOGGER = logging.getLogger(__name__)


def normalize_wishlist_category_title(value: str) -> str:
    """Normalize wishlist category titles for comparison."""

    normalized = str(value or "").strip().casefold()
    if normalized == "byt":
        return "–±—ã—Ç"
    return normalized


def wishlist_category_matches(wish_category: str, source_title: str) -> bool:
    """Return True when wish category matches selected BYT source."""

    return normalize_wishlist_category_title(wish_category) == normalize_wishlist_category_title(
        source_title
    )


def get_byt_source_category_id(db: FinanceDatabase, user_id: int) -> Optional[int]:
    """Return BYT source wishlist category id with fallback by name."""

    db.ensure_user_settings(user_id)
    settings_row = db.get_user_settings(user_id)
    raw_id = settings_row.get("byt_wishlist_category_id")
    category_id: Optional[int] = None
    if raw_id is not None:
        try:
            category_id = int(raw_id)
        except (TypeError, ValueError):
            category_id = None
    if category_id is not None:
        category_row = db.get_wishlist_category_by_id(user_id, category_id)
        if category_row:
            return int(category_row.get("id"))
        db.set_byt_wishlist_category_id(user_id, None)

    fallback = db.get_wishlist_category_by_title(user_id, "–±—ã—Ç")
    if fallback:
        fallback_id = int(fallback.get("id"))
        db.set_byt_wishlist_category_id(user_id, fallback_id)
        LOGGER.info(
            "USER=%s ACTION=BYT_SOURCE_CATEGORY_SET META=category_id=%s",
            user_id,
            fallback_id,
        )
        return fallback_id
    return None


def get_byt_source_category(
    db: FinanceDatabase, user_id: int
) -> tuple[Optional[int], Optional[str]]:
    """Return BYT source category id and title."""

    category_id = get_byt_source_category_id(db, user_id)
    if category_id is None:
        return None, None
    category_row = db.get_wishlist_category_by_id(user_id, category_id)
    if not category_row:
        return None, None
    return category_id, str(category_row.get("title", ""))

===== Bot/utils/datetime_utils.py =====

"""Datetime utilities for the bot."""
from datetime import datetime, time, timedelta
from zoneinfo import ZoneInfo

from Bot.config import settings


def now_tz() -> datetime:
    """Return current datetime in configured timezone."""

    return datetime.now(tz=settings.TIMEZONE)


def current_month_str(now: datetime | None = None) -> str:
    """Return current month label as YYYY-MM using configured timezone."""

    current = now or now_tz()
    return f"{current.year:04d}-{current.month:02d}"


def add_one_month(source: datetime) -> datetime:
    """Add one calendar month to datetime without external dependencies."""

    year = source.year + (source.month // 12)
    month = 1 if source.month == 12 else source.month + 1
    last_day = (
        (source.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    ).day
    day = min(source.day, last_day)
    return source.replace(year=year, month=month, day=day)


def get_next_byt_run_dt(now: datetime, schedule_times: list[time]) -> datetime:
    """Return next BYT reminder datetime based on schedule times."""

    if not schedule_times:
        return now

    sorted_times = sorted(
        schedule_times, key=lambda value: (value.hour, value.minute, value.second)
    )
    candidates = [
        now.replace(
            hour=slot.hour,
            minute=slot.minute,
            second=slot.second,
            microsecond=0,
        )
        for slot in sorted_times
    ]
    for candidate in candidates:
        if candidate >= now:
            return candidate
    return candidates[0] + timedelta(days=1)


def get_next_reminder_dt(
    now: datetime, times_hhmm: list[str], tz: ZoneInfo | None = None
) -> datetime:
    """Return next reminder datetime based on HH:MM list."""

    timezone = tz or now.tzinfo
    valid_times: list[time] = []
    for raw in times_hhmm:
        if not raw:
            continue
        parts = str(raw).strip().split(":", maxsplit=1)
        if len(parts) != 2:
            continue
        try:
            hour = int(parts[0])
            minute = int(parts[1])
        except (TypeError, ValueError):
            continue
        if hour < 0 or hour > 23 or minute < 0 or minute > 59:
            continue
        valid_times.append(time(hour=hour, minute=minute))
    if not valid_times:
        valid_times = [time(hour=12, minute=0)]

    sorted_times = sorted(valid_times, key=lambda value: (value.hour, value.minute))
    candidates = [
        now.replace(
            hour=slot.hour,
            minute=slot.minute,
            second=0,
            microsecond=0,
            tzinfo=timezone,
        )
        for slot in sorted_times
    ]
    for candidate in candidates:
        if candidate > now:
            return candidate
    return candidates[0] + timedelta(days=1)


def resolve_deferred_until(
    existing: datetime | None, candidate: datetime
) -> datetime:
    """Pick later deferred_until value."""

    if existing and existing > candidate:
        return existing
    return candidate

===== Bot/utils/logging.py =====

"""Logging utilities."""
import logging

from Bot.config.logging_config import setup_logging


def init_logging() -> logging.Logger:
    """Initialize logging and return module logger.

    Returns:
        logging.Logger: Configured logger instance.
    """

    setup_logging()
    return logging.getLogger(__name__)

===== Bot/utils/messages.py =====

"""Message constants for user-facing prompts and errors."""

ERR_INVALID_INPUT = "‚ö†Ô∏è –ù–µ –ø–æ–Ω—è–ª –≤–≤–æ–¥. –í—ã–±–µ—Ä–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏–ª–∏ –≤–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ."
HINT_TIME_FORMAT = "–§–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏: —á—á:–º–º (–Ω–∞–ø—Ä–∏–º–µ—Ä 09:30)."

===== Bot/utils/number_input.py =====

"""Utilities for parsing numeric input."""

from __future__ import annotations


def parse_int_choice(text: str) -> int | None:
    """Parse a simple integer choice like "2" or "+2"."""

    value = (text or "").strip()
    if not value:
        return None
    if value.startswith("+"):
        value = value[1:]
    if not value.isdigit():
        return None
    return int(value)


def parse_positive_int(text: str) -> int | None:
    """Parse a positive integer (> 0) from input."""

    value = parse_int_choice(text)
    if value is None or value <= 0:
        return None
    return value

===== Bot/utils/savings.py =====

"""Savings utility helpers."""
from typing import Any, Dict, List, Tuple


def _fallback_humanize_category(category: str) -> str:
    name = str(category)
    if name.startswith("savings_"):
        name = name[len("savings_") :]
    name = name.replace("_", " ").strip()
    return name or str(category)


def format_savings_summary(
    savings: Dict[str, Dict[str, Any]],
    categories_map: Dict[str, str] | None = None,
) -> str:
    """Format savings summary for user message."""

    if not savings:
        return "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π."

    lines: List[str] = []
    for category, data in savings.items():
        display_name = None
        if categories_map is not None:
            display_name = categories_map.get(str(category))
        if not display_name:
            display_name = _fallback_humanize_category(str(category))
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        purpose = data.get("purpose", "")
        line = f"{display_name}: {current:.2f}"
        if goal and goal > 0:
            progress = min(current / goal * 100, 100)
            extra = f" (—Ü–µ–ª—å {goal:.2f} –¥–ª—è '{purpose}', –ø—Ä–æ–≥—Ä–µ—Å—Å {progress:.1f}%)"
            line = f"{line}{extra}"
        lines.append(line)
    return "\n".join(lines)


def find_reached_goal(
    savings: Dict[str, Dict[str, Any]]
) -> Tuple[str, Dict[str, Any]] | Tuple[None, None]:
    """Find first saving goal that has been reached."""

    for category, data in savings.items():
        current = data.get("current", 0)
        goal = data.get("goal", 0)
        if goal and current >= goal:
            return category, data
    return None, None

===== Bot/utils/telegram_safe.py =====

"""Safe wrappers for Telegram API operations."""
from __future__ import annotations

import asyncio
import logging

from aiohttp import ClientConnectionError, ClientOSError
from aiogram.exceptions import TelegramBadRequest, TelegramNetworkError
from aiogram.types import ReplyKeyboardMarkup, ReplyKeyboardRemove

LOGGER = logging.getLogger(__name__)

DEFAULT_REQUEST_TIMEOUT = 30


def _get_logger(logger: logging.Logger | None) -> logging.Logger:
    return logger or LOGGER


def _is_network_error(exc: Exception) -> bool:
    return isinstance(
        exc,
        (
            TelegramNetworkError,
            ClientOSError,
            ClientConnectionError,
            asyncio.TimeoutError,
            TimeoutError,
        ),
    )


def _log_network_error(
    logger: logging.Logger,
    action: str,
    exc: Exception,
    attempt: int,
    retries: int,
) -> None:
    logger.warning(
        "NETWORK_RETRY action=%s attempt=%s/%s error=%s",
        action,
        attempt,
        retries + 1,
        exc,
    )
    if logger.isEnabledFor(logging.DEBUG):
        logger.debug("Network error details for %s", action, exc_info=True)


async def safe_delete_message(
    bot,
    chat_id: int,
    message_id: int,
    *,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> bool:
    """Safely delete a message without raising exceptions."""

    log = _get_logger(logger)
    for attempt in range(retries + 1):
        try:
            await bot.delete_message(
                chat_id=chat_id,
                message_id=message_id,
                request_timeout=request_timeout,
            )
            return True
        except TelegramBadRequest as exc:
            text = str(exc).lower()
            if (
                "message to delete not found" in text
                or "message can't be deleted" in text
                or "message can‚Äôt be deleted" in text
            ):
                log.debug(
                    "Safe delete skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False
            log.warning(
                "Safe delete failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe delete failure details", exc_info=True)
            return False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "delete_message", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False
            log.warning(
                "Safe delete unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe delete unexpected error details", exc_info=True)
            return False
    return False


async def safe_edit_message_text(
    bot,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> bool:
    """Safely edit a message text without raising exceptions."""

    log = _get_logger(logger)
    if isinstance(reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)):
        log.warning("Safe edit skipped due to reply keyboard markup")
        return False

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False
            log.warning(
                "Safe edit unexpected error (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit unexpected error details", exc_info=True)
            return False
    return False


async def safe_edit_message_text_with_status(
    bot,
    chat_id: int,
    message_id: int,
    text: str,
    reply_markup=None,
    *,
    parse_mode: str | None = None,
    retries: int = 2,
    base_delay: float = 0.3,
    logger: logging.Logger | None = None,
    request_timeout: int | None = DEFAULT_REQUEST_TIMEOUT,
) -> tuple[bool, bool]:
    """Safely edit a message text, reporting network failures."""

    log = _get_logger(logger)
    if isinstance(reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)):
        log.warning("Safe edit skipped due to reply keyboard markup")
        return False, False

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True, False
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True, False
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False, False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False, False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False, True
            log.warning(
