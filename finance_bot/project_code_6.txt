            return

        LOGGER.info(
            "BYT defer days submit user_id=%s item_id=%s days=%s",
            message.from_user.id if message.from_user else "unknown",
            defer_item_id,
            days,
        )

        await state.clear()
        if wish:
            category_id, category_title = _resolve_wish_category(db, message.from_user.id, wish)
            due_items, deferred_items = get_byt_category_items(
                db, message.from_user.id, category_title, now_tz()
            )
            checklist_text = format_byt_category_checklist_text(
                category_title, due_items, deferred_items
            )
            message_text = format_byt_defer_confirmation_text(
                wish, category_title, deferred_until, checklist_text
            )
            category_row = db.get_wishlist_category_by_title(message.from_user.id, category_title)
            category_ref = int(category_row["id"]) if category_row else category_id
            keyboard = (
                _build_byt_items_keyboard(
                    due_items,
                    allow_defer=bool(settings_row.get("byt_defer_enabled", 1)),
                    category_id=category_ref,
                )
                if due_items
                else None
            )
            if reminder_message_id:
                edited = await safe_edit_message_text(
                    message.bot,
                    chat_id=message.chat.id,
                    message_id=int(reminder_message_id),
                    text=message_text,
                    reply_markup=keyboard,
                    logger=LOGGER,
                )
                if not edited:
                    sent = await message.answer(message_text, reply_markup=keyboard)
                    if sent:
                        await ui_register_message(state, sent.chat.id, sent.message_id)
            else:
                sent = await message.answer(message_text, reply_markup=keyboard)
                if sent:
                    await ui_register_message(state, sent.chat.id, sent.message_id)
            await message.answer(" ", reply_markup=ReplyKeyboardRemove())
        else:
            await message.answer(
                f"ÐžÑ‚Ð»Ð¾Ð¶ÐµÐ½Ð¾ Ð½Ð° {days} Ð´Ð½.", reply_markup=ReplyKeyboardRemove()
            )

        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return
    else:
        if current_sum == "0":
            new_sum = message.text
        else:
            new_sum = current_sum + message.text

    new_display_message_id = display_message_id
    new_display_chat_id = display_chat_id
    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            new_display_message_id = prompt.message_id
            new_display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        new_display_message_id = prompt.message_id
        new_display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=new_display_message_id,
        defer_display_chat_id=new_display_chat_id,
    )

    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(
    BytDeferState.waiting_for_days,
    F.text.regexp(r"^\\s*\\+?\\d+\\s*$"),
)
async def handle_byt_defer_days_manual(message: Message, state: FSMContext) -> None:
    """Handle manual numeric input for BYT defer days."""

    value = parse_positive_int(message.text or "")
    if value is None:
        await message.answer(f"{ERR_INVALID_INPUT} Ð’Ð²ÐµÐ´Ð¸ Ñ‡Ð¸ÑÐ»Ð¾.")
        await safe_delete_message(
            message.bot,
            chat_id=message.chat.id,
            message_id=message.message_id,
            logger=LOGGER,
        )
        return

    data = await state.get_data()
    display_chat_id = data.get("defer_display_chat_id", message.chat.id)
    display_message_id = data.get("defer_display_message_id")
    new_sum = str(value)

    if display_message_id:
        edited = await safe_edit_message_text(
            message.bot,
            chat_id=display_chat_id,
            message_id=int(display_message_id),
            text=f": {new_sum}",
            logger=LOGGER,
        )
        if not edited:
            prompt = await message.answer(f": {new_sum}")
            display_message_id = prompt.message_id
            display_chat_id = message.chat.id
    else:
        prompt = await message.answer(f": {new_sum}")
        display_message_id = prompt.message_id
        display_chat_id = message.chat.id

    await state.update_data(
        defer_days_str=new_sum,
        defer_display_message_id=display_message_id,
        defer_display_chat_id=display_chat_id,
    )
    await safe_delete_message(
        message.bot,
        chat_id=message.chat.id,
        message_id=message.message_id,
        logger=LOGGER,
    )


@router.message(BytDeferState.waiting_for_days)
async def handle_byt_defer_days_invalid(message: Message) -> None:
    """Prompt to use calculator buttons for defer days."""

    await message.answer(f"{ERR_INVALID_INPUT} Ð’Ð²ÐµÐ´Ð¸ Ñ‡Ð¸ÑÐ»Ð¾.")

===== Bot/keyboards/__init__.py =====


===== Bot/keyboards/calculator.py =====

"""Calculator keyboard definitions."""

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup


def income_calculator_keyboard() -> ReplyKeyboardMarkup:
    """ÐžÐ±Ñ‰Ð°Ñ Ñ†Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ñ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ð° Ð´Ð»Ñ Ð²Ð²Ð¾Ð´Ð° ÑÑƒÐ¼Ð¼."""

    keyboard = [
        [KeyboardButton(text="7"), KeyboardButton(text="8"), KeyboardButton(text="9")],
        [KeyboardButton(text="4"), KeyboardButton(text="5"), KeyboardButton(text="6")],
        [KeyboardButton(text="1"), KeyboardButton(text="2"), KeyboardButton(text="3")],
        [
            KeyboardButton(text="ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ"),
            KeyboardButton(text="0"),
            KeyboardButton(text="âœ… Ð“Ð°Ð·"),
        ],
        [KeyboardButton(text="â¬…ï¸ ÐÐ°Ð·Ð°Ð´")],
    ]
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
    )

===== Bot/keyboards/household.py =====

"""Keyboards for household payments."""
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)


def household_payments_answer_keyboard() -> ReplyKeyboardMarkup:
    """Reply keyboard with Yes/No and Back options for household payments."""

    buttons = [
        [
            KeyboardButton(text="âœ… Ð”Ð°"),
            KeyboardButton(text="âŒ ÐÐµÑ‚"),
            KeyboardButton(text="â¬…ï¸ ÐÐ°Ð·Ð°Ð´"),
        ]
    ]
    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True,
        one_time_keyboard=False,
    )


def household_payments_inline_keyboard(
    show_back: bool, question_code: str | None = None
) -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No/Back options for household payments."""

    suffix = f":{question_code}" if question_code else ""
    buttons = [
        [
            InlineKeyboardButton(text="Ð”Ð°", callback_data=f"hh_pay:yes{suffix}"),
            InlineKeyboardButton(text="ÐÐµÑ‚", callback_data=f"hh_pay:no{suffix}"),
        ]
    ]
    if show_back:
        buttons[0].append(
            InlineKeyboardButton(text="ÐÐ°Ð·Ð°Ð´", callback_data=f"hh_pay:back{suffix}")
        )
    return InlineKeyboardMarkup(inline_keyboard=buttons)

===== Bot/keyboards/main.py =====

"""Keyboard definitions."""
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup


def main_menu_keyboard(
    show_household: bool = False,
    show_test_button: bool = False,
    show_settings: bool = True,
) -> ReplyKeyboardMarkup:
    """Create main menu keyboard."""

    buttons = [[KeyboardButton(text="Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ð´Ð¾Ñ…Ð¾Ð´")], [KeyboardButton(text="ðŸ“‹ Ð’Ð¸ÑˆÐ»Ð¸ÑÑ‚")]]
    if show_household:
        buttons.append([KeyboardButton(text="Ð‘Ñ‹Ñ‚Ð¾Ð²Ñ‹Ðµ Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð¸")])
    if show_settings:
        buttons.append([KeyboardButton(text="âš™ï¸")])
    if show_test_button:
        buttons.append([KeyboardButton(text="ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ")])  # TODO: ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð¿Ð¾ÑÐ»Ðµ Ñ‚ÐµÑÑ‚Ð¾Ð²
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def yes_no_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with Yes/No options."""

    buttons = [[KeyboardButton(text="Ð”Ð°"), KeyboardButton(text="ÐÐµÑ‚")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=True)


def yes_no_inline_keyboard() -> InlineKeyboardMarkup:
    """Inline keyboard with Yes/No options to avoid opening system keyboard."""

    buttons = [
        [
            InlineKeyboardButton(text="Ð”Ð°", callback_data="confirm_yes"),
            InlineKeyboardButton(text="ÐÐµÑ‚", callback_data="confirm_no"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def back_to_main_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with back to main option."""

    buttons = [[KeyboardButton(text="âª ÐÐ° Ð³Ð»Ð°Ð²Ð½ÑƒÑŽ")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def back_only_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard with a single back button."""

    buttons = [[KeyboardButton(text="â¬…ï¸ ÐÐ°Ð·Ð°Ð´")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions."""

    buttons = [[KeyboardButton(text="âž•"), KeyboardButton(text="ÐšÑƒÐ¿Ð»ÐµÐ½Ð½Ð¾Ðµ")], [KeyboardButton(text="âª ÐÐ° Ð³Ð»Ð°Ð²Ð½ÑƒÑŽ")]]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def wishlist_reply_keyboard_no_add() -> ReplyKeyboardMarkup:
    """Keyboard for wishlist actions without add button (+)."""

    buttons = [
        [KeyboardButton(text="ÐšÑƒÐ¿Ð»ÐµÐ½Ð½Ð¾Ðµ")],
        [KeyboardButton(text="âª ÐÐ° Ð³Ð»Ð°Ð²Ð½ÑƒÑŽ")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)

    LOGGER.info(
        "UI_CLEANUP context=%s deleted=%s kept=%s welcome_id=%s",
        context_name,
        deleted_count,
        len(kept_ids),
        await ui_get_welcome_id(state),
    )
    await state.update_data(
        ui_tracked_message_ids=list(
            {
                int(item)
                for item in (keep_ids or [])
                if item is not None
                and int(item) not in protected_ids
            }
        ),
    )


async def ui_cleanup_messages(bot: Bot, state: FSMContext, *args, **kwargs) -> None:
    data = await state.get_data()
    chat_id = kwargs.get("chat_id") or data.get("ui_chat_id")
    if chat_id is None:
        return
    await ui_cleanup_to_context(bot, state, int(chat_id), "MAIN_MENU")


async def ui_render_screen(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    text: str,
    reply_markup=None,
    parse_mode: str | None = None,
) -> int:
    data = await state.get_data()
    screen_id = data.get("ui_screen_message_id")
    if screen_id is not None and not isinstance(
        reply_markup, (ReplyKeyboardMarkup, ReplyKeyboardRemove)
    ):
        edited = await safe_edit_message_text(
            bot,
            chat_id=chat_id,
            message_id=int(screen_id),
            text=text,
            reply_markup=reply_markup,
            parse_mode=parse_mode,
            logger=LOGGER,
        )
        if edited:
            await ui_set_screen_message(state, chat_id, int(screen_id))
            return int(screen_id)
    sent = await safe_send_message(
        bot,
        chat_id=chat_id,
        text=text,
        reply_markup=reply_markup,
        parse_mode=parse_mode,
        logger=LOGGER,
    )
    if sent:
        await ui_set_screen_message(state, chat_id, sent.message_id)
        return int(sent.message_id)
    return int(screen_id or 0)

===== Bot/utils/ui_flow.py =====

import logging
from collections.abc import Awaitable, Callable
from typing import Any

from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from Bot.utils.telegram_safe import safe_delete_message
LOGGER = logging.getLogger(__name__)


async def ui_get(state: FSMContext) -> dict[str, Any]:
    data = await state.get_data()
    return {
        "greeting_id": data.get("ui_welcome_message_id"),
        "tracked_ids": list(data.get("ui_tracked_message_ids") or []),
    }


async def ui_set_greeting(state: FSMContext, message_id: int) -> None:
    ui = await ui_get(state)
    if ui.get("greeting_id") is not None:
        return
    # greeting_id Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÐµÐ¼ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð°
    await state.update_data(ui_welcome_message_id=int(message_id))


async def ui_track(
    state: FSMContext, message_id: int, kind: str, screen: str | None
) -> None:
    ui = await ui_get(state)
    tracked: list[int] = list(ui.get("tracked_ids") or [])
    tracked.append(int(message_id))
    if len(tracked) > 300:
        tracked = tracked[-300:]
    await state.update_data(ui_tracked_message_ids=tracked)


async def ui_set_screen_message(
    state: FSMContext, screen: str, message_id: int
) -> None:
    await ui_track(state, message_id, kind="ui", screen=screen)


async def ui_cleanup_for_transition(
    bot: Bot, state: FSMContext, chat_id: int, keep_greeting: bool = True
) -> None:
    ui = await ui_get(state)
    greeting_id = ui.get("greeting_id") if keep_greeting else None
    tracked: list[int] = list(ui.get("tracked_ids") or [])
    ids = [int(item) for item in tracked]
    for message_id in ids:
        if greeting_id and message_id == greeting_id:
            continue
        await safe_delete_message(
            bot,
            chat_id=chat_id,
            message_id=message_id,
            logger=LOGGER,
        )
    await state.update_data(ui_tracked_message_ids=[])


async def ui_transition(
    bot: Bot,
    state: FSMContext,
    chat_id: int,
    new_screen: str,
    send_screen: Callable[[], Awaitable[Message]],
) -> Message:
    await ui_cleanup_for_transition(bot, state, chat_id, keep_greeting=True)
    sent = await send_screen()
    await ui_set_screen_message(state, new_screen, sent.message_id)
    return sent

===== __init__.py =====


===== docs/AUDIT_REPORT.md =====

# Audit Report (finance_bot v4)

## Found issues
- UI cleanup tracked multiple message lists and could retain welcome in tracked ids.
- Welcome message id was not persisted and could be duplicated after state loss.
- Direct Telegram edit/delete calls could fail on network errors or invalid reply keyboards.
- Income category titles contained bank/service suffixes and older rows were not sanitized.
- Database access used direct `FinanceDatabase()` construction across handlers.

## Fixes applied
- Unified UI tracking to `ui_tracked_message_ids` and excluded welcome from tracked ids after cleanup.
- Added persistent welcome id storage in `ui_pins` table and reused it on startup.
- Implemented safe Telegram operations with retries and guarded edits against reply keyboards.
- Added income title sanitizer and migration to update existing stored titles.
- Introduced `get_db()` for a shared database instance and updated handlers.

## Backlog / Follow-up
- Expand safe Telegram wrapper adoption in remaining handlers and services.
- Add safe reply markup editing helper if required by additional flows.

===== docs/RUNBOOK.md =====

# Runbook

## Ð—Ð°Ð¿ÑƒÑÐº Ð±Ð¾Ñ‚Ð°
```bash
python Bot/main.py
```

## ÐŸÑ€Ð¾Ð³Ð¾Ð½ Ñ‚ÐµÑÑ‚Ð¾Ð²
```bash
pytest
```

===== tests/__init__.py =====


===== tests/integration/__init__.py =====


===== tests/integration/test_database.py =====

"""Integration tests for database operations."""
from Bot.database.crud import FinanceDatabase, TABLES


def setup_module(module) -> None:  # noqa: D401
    """Clean database tables before tests."""

    db = FinanceDatabase()
    cursor = db.connection.cursor()
    cursor.execute(f"DELETE FROM {TABLES.wishes}")
    cursor.execute(f"DELETE FROM {TABLES.purchases}")
    cursor.execute(f"DELETE FROM {TABLES.savings}")
    db.connection.commit()


def test_add_and_get_wish() -> None:
    """Add wish and retrieve it."""

    db = FinanceDatabase()
    wish_id = db.add_wish(1, "Test", 10.0, None, "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹")
    wish = db.get_wish(wish_id)
    assert wish is not None
    assert wish["name"] == "Test"


def test_update_saving_and_purchase() -> None:
    """Update savings and add purchase entry."""

    db = FinanceDatabase()
    db.update_saving(1, "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹", 20.0)
    savings = db.get_user_savings(1)
    assert savings.get("Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹", {}).get("current") == 20.0
    db.add_purchase(1, "Test", 10.0, "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹")
    purchases = db.get_purchases_by_user(1)
    assert len(purchases) == 1

===== tests/integration/test_schema_migration.py =====

"""Integration tests for schema migration."""
from __future__ import annotations

import sqlite3
from pathlib import Path

from Bot.database.crud import TABLES, migrate_schema


def test_schema_migration_renames_tables(tmp_path: Path) -> None:
    """Rename legacy tables without losing data."""

    db_path = tmp_path / "legacy.db"
    connection = sqlite3.connect(db_path)
    cursor = connection.cursor()
    cursor.execute(
        """
        CREATE TABLE savings (
            id INTEGER PRIMARY KEY,
            user_id INTEGER,
            category TEXT,
            current REAL
        )
        """
    )
    cursor.execute(
        """
        CREATE TABLE wishes (
            id INTEGER PRIMARY KEY,
            user_id INTEGER,
            name TEXT,
            price REAL,
            category TEXT,
            is_purchased INTEGER,
            saved_amount REAL,
            purchased_at TEXT
        )
        """
    )
    cursor.execute(
        """
        CREATE TABLE purchases (
            id INTEGER PRIMARY KEY,
            user_id INTEGER,
            wish_name TEXT,
            price REAL,
            category TEXT,
            purchased_at TEXT
        )
        """
    )
    cursor.execute(
        """
        CREATE TABLE household_payment_items (
            id INTEGER PRIMARY KEY,
            user_id INTEGER,
            code TEXT,
            text TEXT,
            amount INTEGER,
            position INTEGER,
            is_active INTEGER
        )
        """
    )
    cursor.execute(
        """
        CREATE TABLE household_payments (
            id INTEGER PRIMARY KEY,
            user_id INTEGER,
            month TEXT,
            question_code TEXT,
            is_paid INTEGER
        )
        """
    )
    cursor.execute(
        "INSERT INTO savings (user_id, category, current) VALUES (?,?,?)",
        (1, "Ð‘Ð«Ð¢", 500.0),
    )
    cursor.execute(
        """
        INSERT INTO wishes (user_id, name, price, category, is_purchased, saved_amount, purchased_at)
        VALUES (?,?,?,?,?,?,?)
        """,
        (1, "Ð§Ð°Ð¹Ð½Ð¸Ðº", 1200.0, "Ð‘Ð«Ð¢", 0, 0, None),
    )
    cursor.execute(
        "INSERT INTO purchases (user_id, wish_name, price, category, purchased_at) VALUES (?,?,?,?,?)",
        (1, "Ð¢ÐµÑÑ‚", 100.0, "Ð‘Ð«Ð¢", "2025-01-01"),
    )
    cursor.execute(
        """
        INSERT INTO household_payment_items (user_id, code, text, amount, position, is_active)
        VALUES (?,?,?,?,?,?)
        """,
        (1, "rent", "ÐšÐ²Ð°Ñ€Ñ‚Ð¿Ð»Ð°Ñ‚Ð°", 4000, 1, 1),
    )
    cursor.execute(
        """
        INSERT INTO household_payments (user_id, month, question_code, is_paid)
        VALUES (?,?,?,?)
        """,
        (1, "2025-01", "rent", 0),
    )
    connection.commit()

    migrate_schema(connection)
    migrate_schema(connection)

    cursor.execute(f"SELECT category, current FROM {TABLES.savings}")
    savings_row = cursor.fetchone()
    assert savings_row == ("Ð‘Ð«Ð¢", 500.0)

    cursor.execute(f"SELECT name FROM {TABLES.wishes}")
    assert cursor.fetchone()[0] == "Ð§Ð°Ð¹Ð½Ð¸Ðº"

    cursor.execute(f"SELECT wish_name FROM {TABLES.purchases}")
    assert cursor.fetchone()[0] == "Ð¢ÐµÑÑ‚"

    cursor.execute(f"SELECT code FROM {TABLES.household_payment_items}")
    assert cursor.fetchone()[0] == "rent"

    cursor.execute(f"SELECT question_code FROM {TABLES.household_payments}")
    assert cursor.fetchone()[0] == "rent"

    connection.close()

===== tests/run_all_tests.py =====

"""Run all pytest suites."""
import pytest


if __name__ == "__main__":
    raise SystemExit(pytest.main(["-q", "tests"]))

===== tests/test_runner.py =====

"""Helper to run tests programmatically."""
import subprocess
import sys
from pathlib import Path


def main() -> int:
    """Run pytest suite and return exit code."""

    root = Path(__file__).resolve().parents[1]
    result = subprocess.run([sys.executable, "-m", "pytest", "-q", str(root / "tests")], check=False)
    return result.returncode


if __name__ == "__main__":
    raise SystemExit(main())

===== tests/unit/__init__.py =====


===== tests/unit/test_byt_manual_check.py =====

"""Tests for manual BYT reminder check helpers."""

from Bot.utils.byt_manual_check import (
    build_byt_times_sorted,
    parse_byt_manual_cursor_index,
    select_next_byt_manual_time,
)


def test_build_byt_times_sorted_unique_sorted() -> None:
    times_by_category = {
        1: ["12:00", "18:00"],
        2: ["14:00", "12:00"],
    }
    assert build_byt_times_sorted(times_by_category) == ["12:00", "14:00", "18:00"]


def test_select_next_byt_manual_time_cycles() -> None:
    times_sorted = ["12:00", "14:00"]
    current_date = "2026-01-09"
    selected, index, notice = select_next_byt_manual_time(
        times_sorted, current_date, current_date, -1
    )
    assert selected == "12:00"
    assert index == 0
    assert notice == ""

    selected, index, notice = select_next_byt_manual_time(
        times_sorted, current_date, current_date, index
    )
    assert selected == "14:00"
    assert index == 1
    assert notice == ""

    selected, index, notice = select_next_byt_manual_time(
        times_sorted, current_date, current_date, index
    )
    assert selected == "12:00"
    assert index == 0
    assert notice == "Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ Ð²ÑÐµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð° ÑƒÐ¶Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐµÐ½Ñ‹ â€” Ð½Ð°Ñ‡Ð¸Ð½Ð°ÑŽ Ð·Ð°Ð½Ð¾Ð²Ð¾."


def test_parse_byt_manual_cursor_index_zero_is_valid() -> None:
    assert parse_byt_manual_cursor_index(0) == 0
    assert parse_byt_manual_cursor_index("0") == 0


def test_parse_byt_manual_cursor_index_invalid_returns_minus_one() -> None:
    assert parse_byt_manual_cursor_index(None) == -1
    assert parse_byt_manual_cursor_index("") == -1
    assert parse_byt_manual_cursor_index("   ") == -1
    assert parse_byt_manual_cursor_index("abc") == -1

===== tests/unit/test_byt_reminder_schedule.py =====

"""Tests for BYT reminder schedule helpers."""

from datetime import datetime
from zoneinfo import ZoneInfo

from Bot.utils.datetime_utils import get_next_reminder_dt


def test_get_next_reminder_dt_today() -> None:
    now = datetime(2026, 1, 8, 10, 30, tzinfo=ZoneInfo("UTC"))
    result = get_next_reminder_dt(now, ["12:00", "18:00"])
    assert result == datetime(2026, 1, 8, 12, 0, tzinfo=ZoneInfo("UTC"))


def test_get_next_reminder_dt_tomorrow() -> None:
    now = datetime(2026, 1, 8, 19, 0, tzinfo=ZoneInfo("UTC"))
    result = get_next_reminder_dt(now, ["12:00", "18:00"])
    assert result == datetime(2026, 1, 9, 12, 0, tzinfo=ZoneInfo("UTC"))


def test_get_next_reminder_dt_default() -> None:
    now = datetime(2026, 1, 8, 13, 0, tzinfo=ZoneInfo("UTC"))
    result = get_next_reminder_dt(now, [])
    assert result == datetime(2026, 1, 9, 12, 0, tzinfo=ZoneInfo("UTC"))

===== tests/unit/test_byt_reminder_settings.py =====

"""Tests for BYT reminder category and time settings."""

from datetime import datetime

from Bot.database import crud
from aiogram.types import InlineKeyboardMarkup, ReplyKeyboardMarkup

from Bot.keyboards.settings import byt_timer_categories_inline_keyboard
from Bot.utils.byt_render import (
    format_byt_categories_status_text,
    format_byt_category_checklist_text,
    format_byt_defer_confirmation_text,
)


def _fresh_db(tmp_path, monkeypatch) -> crud.FinanceDatabase:
    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None
    return crud.FinanceDatabase()


def test_toggle_byt_category_and_times(tmp_path, monkeypatch) -> None:
    db = _fresh_db(tmp_path, monkeypatch)
    try:
        category_id = db.create_wishlist_category(1, "Ð”Ð¾Ð¼")
        assert db.get_byt_reminder_category_enabled(1, category_id) is False
        enabled = db.toggle_byt_reminder_category(1, category_id)
        assert enabled is True
        assert db.get_byt_reminder_category_enabled(1, category_id) is True
        enabled = db.toggle_byt_reminder_category(1, category_id)
        assert enabled is False

        db.add_byt_reminder_time(1, category_id, "09:00")
        times = db.list_byt_reminder_times(1, category_id)
        assert times == [{"time_hhmm": "09:00"}]
        db.remove_byt_reminder_time(1, category_id, "09:00")
        assert db.list_byt_reminder_times(1, category_id) == []
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_defer_confirmation_text_contains_details() -> None:
    item = {"name": "Ð¨Ð²Ð°Ð±Ñ€Ð°", "price": 1990}
    deferred_until = datetime(2026, 1, 9, 12, 0)
    checklist_text = format_byt_category_checklist_text("Ð‘Ñ‹Ñ‚", [item], [])
    text = format_byt_defer_confirmation_text(
        item, "Ð‘Ñ‹Ñ‚", deferred_until, checklist_text
    )
    assert "Ð¨Ð²Ð°Ð±Ñ€Ð°" in text
    assert "2026-01-09 12:00" in text
    assert "ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ: Ð‘Ñ‹Ñ‚" in text


def test_byt_categories_status_text_format() -> None:
    categories = [
        {"title": "Ð‘Ñ‹Ñ‚", "enabled": 1},
        {"title": "Ð•Ð´Ð°", "enabled": 0},
    ]
    text = format_byt_categories_status_text(categories)
    lines = [line for line in text.splitlines() if line.strip()]
    status_lines = lines[1:]
    assert status_lines == ["âœ… Ð‘Ñ‹Ñ‚", "âŒ Ð•Ð´Ð°"]
    assert all(not any(char.isdigit() for char in line) for line in status_lines)


def test_byt_timer_categories_keyboard_inline() -> None:
    categories = [{"id": 1, "title": "Ð‘Ñ‹Ñ‚", "enabled": 1}]
    keyboard = byt_timer_categories_inline_keyboard(categories, "byt:timer_category")
    assert isinstance(keyboard, InlineKeyboardMarkup)
    assert not isinstance(keyboard, ReplyKeyboardMarkup)

===== tests/unit/test_byt_source_category.py =====

"""Tests for BYT source category selection."""

from Bot.database import crud
from Bot.utils.byt_utils import get_byt_source_category_id
from Bot.utils.datetime_utils import now_tz


def _fresh_db(tmp_path, monkeypatch) -> crud.FinanceDatabase:
    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None
    return crud.FinanceDatabase()


def test_byt_source_category_respects_setting(tmp_path, monkeypatch) -> None:
    """Return stored BYT source category id when configured."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        category_id = db.create_wishlist_category(1, "Ð”Ð¾Ð¼")
        db.set_byt_wishlist_category_id(1, category_id)
        assert get_byt_source_category_id(db, 1) == category_id
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_byt_source_category_fallback_by_name(tmp_path, monkeypatch) -> None:
    """Fallback should pick wishlist category named 'Ð±Ñ‹Ñ‚' and persist it."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        category_id = db.create_wishlist_category(1, "Ð±Ñ‹Ñ‚")
        assert get_byt_source_category_id(db, 1) == category_id
        assert db.get_byt_wishlist_category_id(1) == category_id
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_byt_source_category_missing_returns_none(tmp_path, monkeypatch) -> None:
    """Return None when no BYT category is configured or found."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        assert get_byt_source_category_id(db, 1) is None
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_byt_query_filters_by_category(tmp_path, monkeypatch) -> None:
    """BYT query should return items only from selected category."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        category_a = db.create_wishlist_category(1, "Ð±Ñ‹Ñ‚")
        category_b = db.create_wishlist_category(1, "Ð¿Ð¾Ð´Ð°Ñ€ÐºÐ¸")
        db.add_wish(1, "Ð¨Ð²Ð°Ð±Ñ€Ð°", 100, None, "Ð±Ñ‹Ñ‚")
        db.add_wish(1, "ÐŸÐ¾Ð´Ð°Ñ€Ð¾Ðº", 200, None, "Ð¿Ð¾Ð´Ð°Ñ€ÐºÐ¸")
        now_dt = now_tz()
        items = db.list_active_byt_items_for_reminder(1, now_dt, "Ð±Ñ‹Ñ‚")
        assert {item["name"] for item in items} == {"Ð¨Ð²Ð°Ð±Ñ€Ð°"}
        assert db.get_active_byt_wishes(1, "Ð±Ñ‹Ñ‚")[0]["name"] == "Ð¨Ð²Ð°Ð±Ñ€Ð°"
        assert category_a != category_b
    finally:
        db.close()
        crud.FinanceDatabase._instance = None

===== tests/unit/test_handlers.py =====

"""Tests for handler utilities."""
from Bot.handlers.finances import _format_savings_summary, _find_reached_goal


def test_format_savings_summary_empty() -> None:
    """Empty savings returns default message."""

    assert _format_savings_summary({}) == "ÐŸÐ¾ÐºÐ° Ð½ÐµÑ‚ Ð½Ð°ÐºÐ¾Ð¿Ð»ÐµÐ½Ð¸Ð¹."


def test_find_reached_goal() -> None:
    """Goal detection returns first satisfied category."""

    savings = {
        "ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ": {"current": 150, "goal": 100, "purpose": "test"},
        "Ð´Ñ€ÑƒÐ³Ð°Ñ": {"current": 50, "goal": 100, "purpose": "none"},
    }
    category, data = _find_reached_goal(savings)
    assert category == "ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ"
    assert data["goal"] == 100

===== tests/unit/test_household_debit_category.py =====

"""Tests for household debit category settings."""
from Bot.database import crud


def _fresh_db(tmp_path, monkeypatch) -> crud.FinanceDatabase:
    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None
    return crud.FinanceDatabase()


def test_set_and_get_household_debit_category(tmp_path, monkeypatch) -> None:
    """Household debit category should persist in user settings."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        db.set_household_debit_category(1, "alpha")
        assert db.get_household_debit_category(1) == "alpha"
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_apply_household_debit_category_updates_savings(tmp_path, monkeypatch) -> None:
    """Yes answer should debit savings from selected category."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        db.set_household_debit_category(2, "custom_cat")
        changed = db.apply_household_payment_answer(
            user_id=2,
            month="2026-01",
            question_code="q1",
            amount=100.0,
            answer="yes",
            debit_category="custom_cat",
        )
        assert changed is True
        savings_map = db.get_user_savings_map(2)
        assert savings_map.get("custom_cat") == -100.0
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_resolve_household_debit_category_fallback(tmp_path, monkeypatch) -> None:
    """Fallback should select first available income category."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        cursor = db.connection.cursor()
        cursor.execute(
            f"""
            INSERT INTO {crud.TABLES.income_categories} (user_id, code, title, percent, position, is_active)
            VALUES (?, ?, ?, ?, ?, 1)
            """,
            (3, "alpha", "Alpha", 50, 1),
        )
        cursor.execute(
            f"""
            INSERT INTO {crud.TABLES.income_categories} (user_id, code, title, percent, position, is_active)
            VALUES (?, ?, ?, ?, ?, 1)
            """,
            (3, "beta", "Beta", 50, 2),
        )
        db.connection.commit()

        code, title = db.resolve_household_debit_category(3)
        assert code == "alpha"
        assert title == "Alpha"
    finally:
        db.close()
        crud.FinanceDatabase._instance = None

===== tests/unit/test_household_idempotency.py =====

"""Tests for household idempotency handling."""
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock

import pytest

pytest.importorskip("aiogram")

from Bot.handlers.household_payments import handle_household_answer  # noqa: E402


class DummyState:
    def __init__(self, data: dict) -> None:
        self._data = data
        self.update_data = AsyncMock(side_effect=self._update)
        self.get_data = AsyncMock(side_effect=self._get)
        self.get_state = AsyncMock(return_value="state")

    async def _get(self) -> dict:
        return self._data

    async def _update(self, **kwargs) -> None:
        self._data.update(kwargs)


@pytest.mark.asyncio
async def test_handle_household_answer_skips_processed_code(monkeypatch) -> None:
    """Duplicate callbacks should not reapply DB updates."""

    db_stub = SimpleNamespace(apply_household_payment_answer=MagicMock(return_value=True))
    monkeypatch.setattr("Bot.handlers.household_payments.get_db", lambda: db_stub)

    message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    callback = SimpleNamespace(
        data="hh_pay:yes:q1",
        from_user=SimpleNamespace(id=1),
        message=message,
        bot=SimpleNamespace(edit_message_text=AsyncMock(return_value=None)),
        answer=AsyncMock(return_value=None),
    )

    state = SimpleNamespace(
        get_data=AsyncMock(
            return_value={
                "hh_month": "2025-01",
                "hh_questions": [
                    {"code": "q1", "text": "Q1", "amount": 10},
                    {"code": "q2", "text": "Q2", "amount": 5},
                ],
                "current_step_index": 0,
                "hh_index": 0,
                "hh_answers": {},
                "hh_ui_message_id": 10,
                "processed_steps": [],
            }
        ),
        update_data=AsyncMock(return_value=None),
        get_state=AsyncMock(return_value="state"),
    )

    await handle_household_answer(callback, state)
    assert db_stub.apply_household_payment_answer.call_count == 1

    state.get_data = AsyncMock(
        return_value={
            "hh_month": "2025-01",
            "hh_questions": [
                {"code": "q1", "text": "Q1", "amount": 10},
                {"code": "q2", "text": "Q2", "amount": 5},
            ],
            "current_step_index": 0,
            "hh_index": 0,
            "hh_answers": {"q1": "yes"},
            "hh_ui_message_id": 10,
            "processed_steps": ["q1"],
        }
    )

    await handle_household_answer(callback, state)
    assert db_stub.apply_household_payment_answer.call_count == 1


@pytest.mark.asyncio
async def test_handle_household_answer_no_updates_ui_on_unchanged_db(
    monkeypatch,
) -> None:
    """No answers should still update UI when DB reports no change."""

    db_stub = SimpleNamespace(apply_household_payment_answer=MagicMock(return_value=False))
    monkeypatch.setattr("Bot.handlers.household_payments.get_db", lambda: db_stub)

    message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    callback = SimpleNamespace(
        data="hh_pay:no:q1",
        from_user=SimpleNamespace(id=1),
        message=message,
        bot=SimpleNamespace(edit_message_text=AsyncMock(return_value=None)),
        answer=AsyncMock(return_value=None),
    )

    state = DummyState(
        {
            "hh_month": "2025-01",
            "hh_questions": [
                {"code": "q1", "text": "Q1", "amount": 10},
                {"code": "q2", "text": "Q2", "amount": 5},
            ],
            "current_step_index": 0,
            "hh_index": 0,
            "hh_answers": {},
            "hh_ui_message_id": 10,
            "processed_steps": [],
        }
    )

    await handle_household_answer(callback, state)

    assert db_stub.apply_household_payment_answer.call_count == 1
    kwargs = state.update_data.await_args.kwargs
    assert kwargs["hh_answers"]["q1"] == "no"
    assert "q1" in kwargs["processed_steps"]
    assert kwargs["current_step_index"] == 1
    callback.bot.edit_message_text.assert_awaited_once()


@pytest.mark.asyncio
async def test_handle_household_answer_no_double_tap_is_idempotent(
    monkeypatch,
) -> None:
    """Duplicate no answers should not reapply DB or UI updates."""

    db_stub = SimpleNamespace(apply_household_payment_answer=MagicMock(return_value=False))
    monkeypatch.setattr("Bot.handlers.household_payments.get_db", lambda: db_stub)

    message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    callback = SimpleNamespace(
        data="hh_pay:no:q1",
        from_user=SimpleNamespace(id=1),
        message=message,
        bot=SimpleNamespace(edit_message_text=AsyncMock(return_value=None)),
        answer=AsyncMock(return_value=None),
    )

    state = DummyState(
        {
            "hh_month": "2025-01",
            "hh_questions": [
                {"code": "q1", "text": "Q1", "amount": 10},
                {"code": "q2", "text": "Q2", "amount": 5},
            ],
            "current_step_index": 0,
            "hh_index": 0,
            "hh_answers": {},
            "hh_ui_message_id": 10,
            "processed_steps": [],
        }
    )

    await handle_household_answer(callback, state)
    await handle_household_answer(callback, state)

    assert db_stub.apply_household_payment_answer.call_count == 1
    callback.bot.edit_message_text.assert_awaited_once()

===== tests/unit/test_household_payments.py =====

"""Tests for household payments workflow."""
from datetime import datetime

import pytest

from Bot.config import settings
from Bot.database.crud import FinanceDatabase, TABLES
from Bot.handlers.household_payments import reset_household_cycle_if_needed
from Bot.utils.datetime_utils import current_month_str


@pytest.mark.asyncio
async def test_reset_cycle_creates_statuses_after_threshold() -> None:
    """Statuses should appear after threshold date only once."""

    db = FinanceDatabase()
    user_id = 99991
    month = "2025-01"
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payments} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payment_items} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    before_threshold = datetime(2025, 1, 5, 10, 0, tzinfo=settings.TIMEZONE)
    await reset_household_cycle_if_needed(user_id, db, now=before_threshold)
    assert not await db.household_status_exists(user_id, month)

    after_threshold = datetime(2025, 1, 6, 12, 0, tzinfo=settings.TIMEZONE)
    await reset_household_cycle_if_needed(user_id, db, now=after_threshold)
    assert await db.has_unpaid_household_questions(user_id, month)

    await reset_household_cycle_if_needed(user_id, db, now=after_threshold)
    cursor = db.connection.execute(
        f"SELECT COUNT(*) FROM {TABLES.household_payments} WHERE user_id = ? AND month = ?",
        (user_id, month),
    )
    assert cursor.fetchone()[0] == len(items)


@pytest.mark.asyncio
async def test_mark_and_check_unpaid_questions() -> None:
    """Marking paid questions should update unpaid check."""

    db = FinanceDatabase()
    user_id = 99992
    month = current_month_str(datetime(2025, 2, 6, 12, 0, tzinfo=settings.TIMEZONE))
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payments} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payment_items} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    await db.init_household_questions_for_month(user_id, month)
    assert await db.has_unpaid_household_questions(user_id, month)

    for item in items:
        await db.mark_household_question_paid(user_id, month, str(item.get("code")))
    assert not await db.has_unpaid_household_questions(user_id, month)


@pytest.mark.asyncio
async def test_question_flow_and_savings_update() -> None:
    """Yes/No answers adjust savings and skip paid questions."""

    db = FinanceDatabase()
    user_id = 99993
    month = current_month_str(datetime(2025, 3, 6, 12, 0, tzinfo=settings.TIMEZONE))
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payments} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.savings} WHERE user_id = ? AND category = 'Ð±Ñ‹Ñ‚'",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payment_items} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    db.update_saving(user_id, "Ð±Ñ‹Ñ‚", 5000)
    await db.init_household_questions_for_month(user_id, month)

    unpaid = await db.get_unpaid_household_questions(user_id, month)
    assert unpaid
    first_code = str(unpaid[0])
    first_item = next(item for item in items if str(item.get("code")) == first_code)
    amount = float(first_item.get("amount") or 0)

    changed = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="yes",
        debit_category="Ð±Ñ‹Ñ‚",
    )
    assert changed is True

    savings_map = db.get_user_savings_map(user_id)
    assert savings_map.get("Ð±Ñ‹Ñ‚") == 5000 - amount

    changed_again = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="yes",
        debit_category="Ð±Ñ‹Ñ‚",
    )
    assert changed_again is False

    changed_back = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="no",
        debit_category="Ð±Ñ‹Ñ‚",
    )
    assert changed_back is True
    savings_map = db.get_user_savings_map(user_id)
    assert savings_map.get("Ð±Ñ‹Ñ‚") == 5000

===== tests/unit/test_household_renderers.py =====

"""Tests for household renderers."""

from Bot.renderers.household import format_household_items, render_household_questions_text


def test_render_questions_text_marks_answers() -> None:
    questions = [
        {"code": "q1", "text": "ÐžÐ¿Ð»Ð°Ñ‚Ð¸Ð» Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚?", "amount": 100},
        {"code": "q2", "text": "ÐžÐ¿Ð»Ð°Ñ‚Ð¸Ð» ÑÐ²ÐµÑ‚?", "amount": 200},
    ]
    answers = {"q1": "yes", "q2": "no"}
    text = render_household_questions_text("2025-02", questions, answers, current_index=1)
    assert "âœ…" in text
    assert "âŒ" in text
    assert "2025-02" in text


def test_format_household_items() -> None:
    items = [
        {"code": "q1", "text": "Ð˜Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚?", "amount": 100},
        {"code": "q2", "text": "Ð¡Ð²ÐµÑ‚?", "amount": 200},
    ]
    text = format_household_items(items, unpaid_set={"q2"})
    assert "âœ…" in text
    assert "âŒ" in text
    assert "Ð˜Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚" in text

===== tests/unit/test_household_services.py =====

"""Tests for household services."""

from Bot.services.household import (
    build_household_questions,
    get_current_question,
    get_next_index,
    get_previous_index,
    should_ignore_answer,
    update_flow_state,
)


def test_flow_state_and_navigation() -> None:
    questions = build_household_questions(
        [
            {"code": "q1", "text": "ÐŸÐµÑ€Ð²Ñ‹Ð¹?", "amount": 100},
            {"code": "q2", "text": "Ð’Ñ‚Ð¾Ñ€Ð¾Ð¹?", "amount": 200},
        ]
    )
    flow = update_flow_state(
        month="2025-01",
        questions=questions,
        current_step_index=0,
        answers={},
        processed_steps=[],
    )
    assert flow.current_question_code == "q1"
    assert get_current_question(questions, 1)["code"] == "q2"
    assert get_next_index(0, questions) == 1
    assert get_next_index(1, questions) == 2
    assert get_previous_index(0) == 0
    assert get_previous_index(1) == 0


def test_idempotency_check() -> None:
    answers = {"q1": "yes"}
    processed_steps = {"q1"}
    assert should_ignore_answer(answers, processed_steps, "q1", "yes") is True
    assert should_ignore_answer(answers, processed_steps, "q1", "no") is False
    assert should_ignore_answer(answers, processed_steps, "q2", "yes") is False

===== tests/unit/test_imports.py =====

"""Basic import tests."""


def test_import_main() -> None:
    """Ensure main module is importable."""

    import Bot.main  # noqa: F401


def test_import_handlers() -> None:
    """Ensure handlers modules are importable."""

    import Bot.handlers.start  # noqa: F401
    import Bot.handlers.finances  # noqa: F401
    import Bot.handlers.household_payments  # noqa: F401
    import Bot.handlers.wishlist  # noqa: F401
    import Bot.handlers.callbacks  # noqa: F401
    import Bot.handlers.common  # noqa: F401


def test_register_routers_smoke() -> None:
    """Ensure register_routers includes key routers."""

    from aiogram import Dispatcher

    from Bot.handlers import household_payments, settings, start, wishlist
    from Bot.main import register_routers

    dp = Dispatcher()
    register_routers(dp)
    routers = list(getattr(dp, "sub_routers", []))

    assert start.router in routers
    assert household_payments.router in routers
    assert settings.router in routers
    assert wishlist.router in routers

===== tests/unit/test_income_categories.py =====

"""Tests for income category seeding and flow guards."""
import asyncio
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock

import pytest

from Bot.database import crud


def test_income_categories_not_seeded(tmp_path, monkeypatch) -> None:
    """Income categories should start empty for a new user."""

    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None

    db = crud.FinanceDatabase()
    try:
        assert db.list_active_income_categories(12345) == []
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_start_income_flow_with_empty_categories(monkeypatch) -> None:
    """Handler should stop flow when no income categories exist."""

    pytest.importorskip("aiogram")

    from Bot.handlers import finances  # noqa: WPS433

    db_stub = SimpleNamespace(list_active_income_categories=MagicMock(return_value=[]))
    monkeypatch.setattr("Bot.handlers.finances.get_db", lambda: db_stub)
    monkeypatch.setattr(
        "Bot.handlers.finances.build_main_menu_for_user",
        AsyncMock(return_value="menu"),
    )
    monkeypatch.setattr("Bot.handlers.finances.ui_register_message", AsyncMock())
    monkeypatch.setattr("Bot.handlers.finances.safe_delete_message", AsyncMock())

    sent_message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    message = SimpleNamespace(
        from_user=SimpleNamespace(id=1),
        chat=SimpleNamespace(id=20),
        message_id=5,
        bot=SimpleNamespace(),
        answer=AsyncMock(return_value=sent_message),
    )
    state = SimpleNamespace(clear=AsyncMock(), set_state=AsyncMock(), update_data=AsyncMock())

    async def _run() -> None:
        await finances.start_income_flow(message, state)

    asyncio.run(_run())

    assert db_stub.list_active_income_categories.call_count == 1
    state.set_state.assert_not_awaited()
    message.answer.assert_awaited_once()
    assert "ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸ Ð´Ð¾Ñ…Ð¾Ð´Ð° Ð½Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐ½Ñ‹" in message.answer.await_args.args[0]

===== tests/unit/test_telegram_safe.py =====

"""Tests for telegram_safe utilities."""
from unittest.mock import AsyncMock

import pytest

pytest.importorskip("aiogram")

from aiogram.exceptions import TelegramNetworkError  # noqa: E402

from Bot.utils.telegram_safe import safe_edit_message_text  # noqa: E402


@pytest.mark.asyncio
async def test_safe_edit_message_text_retries_network_error() -> None:
    """Network errors should trigger retries for edit operations."""

    bot = AsyncMock()
    bot.edit_message_text = AsyncMock(
        side_effect=[TelegramNetworkError("fail"), None]
    )

    result = await safe_edit_message_text(
        bot,
        chat_id=123,
        message_id=456,
        text="hello",
    )

    assert result is True
    assert bot.edit_message_text.call_count == 2

===== tests/unit/test_telegram_safe_delete.py =====

"""Tests for safe_delete_message."""

from unittest.mock import AsyncMock
import sys
import types
from pathlib import Path

import asyncio
import pytest

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

if "aiogram" not in sys.modules:
    aiogram = types.ModuleType("aiogram")
    exceptions = types.ModuleType("aiogram.exceptions")
    types_mod = types.ModuleType("aiogram.types")
    filters = types.ModuleType("aiogram.filters")
    fsm = types.ModuleType("aiogram.fsm")
    fsm_context = types.ModuleType("aiogram.fsm.context")

    class TelegramBadRequest(Exception):
        pass

    class TelegramNetworkError(Exception):
        pass

    exceptions.TelegramBadRequest = TelegramBadRequest
    exceptions.TelegramNetworkError = TelegramNetworkError

    class ReplyKeyboardMarkup:
        pass

    class ReplyKeyboardRemove:
        pass

    class Message:
        pass

    class InlineKeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    class InlineKeyboardMarkup:
        def __init__(self, *args, **kwargs):
            return None

    class KeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

===== Bot/utils/messages.py =====

"""Message constants for user-facing prompts and errors."""

ERR_INVALID_INPUT = "âš ï¸ ÐÐµ Ð¿Ð¾Ð½ÑÐ» Ð²Ð²Ð¾Ð´. Ð’Ñ‹Ð±ÐµÑ€Ð¸ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ Ð¸Ð»Ð¸ Ð²Ð²ÐµÐ´Ð¸ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ."
HINT_TIME_FORMAT = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸: Ñ‡Ñ‡:Ð¼Ð¼ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ 09:30)."
HINT_USE_BUTTONS = "ðŸ’¡ ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð½Ð¸Ð¶Ðµ."

===== Bot/utils/number_input.py =====

"""Utilities for parsing numeric input."""

from __future__ import annotations


def parse_int_choice(text: str) -> int | None:
    """Parse a simple integer choice like "2" or "+2"."""

    value = (text or "").strip()
    if not value:
        return None
    if value.startswith("+"):
        value = value[1:]
    if not value.isdigit():
        return None
    return int(value)


def parse_positive_int(text: str) -> int | None:
    """Parse a positive integer (> 0) from input."""

    value = parse_int_choice(text)
    if value is None or value <= 0:
        return None
    return value

===== Bot/utils/savings.py =====

            return decorator

    class Bot:
        pass

    class DummyF:
        class _Field:
            def __eq__(self, other):
                return ("eq", other)

        text = _Field()

    class FSMContext:
        pass

    class Command:
        def __init__(self, *args, **kwargs):
            return None

    types_mod.ReplyKeyboardMarkup = ReplyKeyboardMarkup
    types_mod.ReplyKeyboardRemove = ReplyKeyboardRemove
    types_mod.Message = Message
    types_mod.InlineKeyboardButton = InlineKeyboardButton
    types_mod.InlineKeyboardMarkup = InlineKeyboardMarkup
    types_mod.KeyboardButton = KeyboardButton
    aiogram.exceptions = exceptions
    aiogram.types = types_mod
    aiogram.Router = DummyRouter
    aiogram.F = DummyF()
    aiogram.Bot = Bot
    fsm_context.FSMContext = FSMContext
    fsm.context = fsm_context
    aiogram.fsm = fsm
    aiogram.filters = filters
    filters.Command = Command
    sys.modules["aiogram"] = aiogram
    sys.modules["aiogram.exceptions"] = exceptions
    sys.modules["aiogram.types"] = types_mod
    sys.modules["aiogram.filters"] = filters
    sys.modules["aiogram.fsm"] = fsm
    sys.modules["aiogram.fsm.context"] = fsm_context

if "aiohttp" not in sys.modules:
    aiohttp = types.ModuleType("aiohttp")

    class ClientConnectionError(Exception):
        pass

    class ClientOSError(Exception):
        pass

    aiohttp.ClientConnectionError = ClientConnectionError
    aiohttp.ClientOSError = ClientOSError
    sys.modules["aiohttp"] = aiohttp

from aiogram.exceptions import TelegramBadRequest  # noqa: E402

from Bot.utils.telegram_safe import safe_delete_message  # noqa: E402


def test_safe_delete_message_not_found() -> None:
    async def run() -> None:
        bot = AsyncMock()
        bot.delete_message = AsyncMock(
            side_effect=TelegramBadRequest("message to delete not found")
        )

        result = await safe_delete_message(bot, chat_id=1, message_id=2)

        assert result is False
        assert bot.delete_message.call_count == 1

    asyncio.run(run())

===== tests/unit/test_text_sanitizer.py =====

"""Tests for income text sanitizer."""

import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from Bot.utils.text_sanitizer import sanitize_income_title  # noqa: E402


def test_sanitize_income_title_removes_bank_suffixes() -> None:
    text = "Ð±Ñ‹Ñ‚Ð¾Ð²Ñ‹Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹ Ð½Ð° Ñ‚Ð¸Ð½ÑŒÐº (Ð¾Ð·Ð¾Ð½)"
    assert sanitize_income_title(text) == "Ð±Ñ‹Ñ‚Ð¾Ð²Ñ‹Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹"


def test_sanitize_income_title_trims_separators() -> None:
    text = "Ð˜Ð½Ð²ÐµÑÑ‚Ð¸Ñ†Ð¸Ð¸ â€” Ð½Ð° ÐÐ»ÑŒÑ„Ñƒ"
    assert sanitize_income_title(text) == "Ð˜Ð½Ð²ÐµÑÑ‚Ð¸Ñ†Ð¸Ð¸"


def test_sanitize_income_title_removes_tinkoff_suffix() -> None:
    text = "ÑƒÐ±Ð¸Ð» Ð±Ð¾Ð»ÑŒ â€” Ð½Ð° Ñ‚Ð¸Ð½ÑŒÐº"
    assert sanitize_income_title(text) == "ÑƒÐ±Ð¸Ð» Ð±Ð¾Ð»ÑŒ"


def test_sanitize_income_title_removes_ozon_suffix() -> None:
    text = "Ñ‡Ñ‚Ð¾-Ñ‚Ð¾ (Ð¾Ð·Ð¾Ð½)"
    assert sanitize_income_title(text) == "Ñ‡Ñ‚Ð¾-Ñ‚Ð¾"

===== tests/unit/test_ui_cleanup.py =====

"""Tests for UI cleanup utilities."""
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock
import asyncio
import sys
import types
from pathlib import Path

import pytest

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

if "aiogram" not in sys.modules:
    aiogram = types.ModuleType("aiogram")

    class DummyRouter:
        def message(self, *args, **kwargs):
            def decorator(func):
                return func

            return decorator

    class DummyF:
        class _Field:
            def __eq__(self, other):
                return ("eq", other)

        text = _Field()

    for attempt in range(retries + 1):
        try:
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                request_timeout=request_timeout,
            )
            return True, False
        except TelegramBadRequest as exc:
            lowered = str(exc).lower()
            if "message is not modified" in lowered:
                return True, False
            if "message to edit not found" in lowered:
                log.debug(
                    "Safe edit skipped (chat_id=%s, message_id=%s): %s",
                    chat_id,
                    message_id,
                    exc,
                )
                return False, False
            log.warning(
                "Safe edit failed (chat_id=%s, message_id=%s): %s",
                chat_id,
                message_id,
                exc,
            )
            if log.isEnabledFor(logging.DEBUG):
                log.debug("Safe edit failure details", exc_info=True)
            return False, False
        except Exception as exc:  # noqa: BLE001
            if _is_network_error(exc):
                _log_network_error(log, "edit_message_text", exc, attempt + 1, retries)
                if attempt < retries:
                    await asyncio.sleep(base_delay * 2**attempt)
                    continue
                return False, True
            log.warning(
