            (3, "beta", "Beta", 50, 2),
        )
        db.connection.commit()

        code, title = db.resolve_household_debit_category(3)
        assert code == "alpha"
        assert title == "Alpha"
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


===== tests/unit/test_household_idempotency.py =====

"""Tests for household idempotency handling."""
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock

import pytest

pytest.importorskip("aiogram")

from Bot.handlers.household_payments import handle_household_answer  # noqa: E402


class DummyState:
    def __init__(self, data: dict) -> None:
        self._data = data
        self.update_data = AsyncMock(side_effect=self._update)
        self.get_data = AsyncMock(side_effect=self._get)
        self.get_state = AsyncMock(return_value="state")

    async def _get(self) -> dict:
        return self._data

    async def _update(self, **kwargs) -> None:
        self._data.update(kwargs)


@pytest.mark.asyncio
async def test_handle_household_answer_skips_processed_code(monkeypatch) -> None:
    """Duplicate callbacks should not reapply DB updates."""

    db_stub = SimpleNamespace(apply_household_payment_answer=MagicMock(return_value=True))
    monkeypatch.setattr("Bot.handlers.household_payments.get_db", lambda: db_stub)

    message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    callback = SimpleNamespace(
        data="hh_pay:yes:q1",
        from_user=SimpleNamespace(id=1),
        message=message,
        bot=SimpleNamespace(edit_message_text=AsyncMock(return_value=None)),
        answer=AsyncMock(return_value=None),
    )

    state = SimpleNamespace(
        get_data=AsyncMock(
            return_value={
                "hh_month": "2025-01",
                "hh_questions": [
                    {"code": "q1", "text": "Q1", "amount": 10},
                    {"code": "q2", "text": "Q2", "amount": 5},
                ],
                "current_step_index": 0,
                "hh_index": 0,
                "hh_answers": {},
                "hh_ui_message_id": 10,
                "processed_steps": [],
            }
        ),
        update_data=AsyncMock(return_value=None),
        get_state=AsyncMock(return_value="state"),
    )

    await handle_household_answer(callback, state)
    assert db_stub.apply_household_payment_answer.call_count == 1

    state.get_data = AsyncMock(
        return_value={
            "hh_month": "2025-01",
            "hh_questions": [
                {"code": "q1", "text": "Q1", "amount": 10},
                {"code": "q2", "text": "Q2", "amount": 5},
            ],
            "current_step_index": 0,
            "hh_index": 0,
            "hh_answers": {"q1": "yes"},
            "hh_ui_message_id": 10,
            "processed_steps": ["q1"],
        }
    )

    await handle_household_answer(callback, state)
    assert db_stub.apply_household_payment_answer.call_count == 1


@pytest.mark.asyncio
async def test_handle_household_answer_no_updates_ui_on_unchanged_db(
    monkeypatch,
) -> None:
    """No answers should still update UI when DB reports no change."""

    db_stub = SimpleNamespace(apply_household_payment_answer=MagicMock(return_value=False))
    monkeypatch.setattr("Bot.handlers.household_payments.get_db", lambda: db_stub)

    message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    callback = SimpleNamespace(
        data="hh_pay:no:q1",
        from_user=SimpleNamespace(id=1),
        message=message,
        bot=SimpleNamespace(edit_message_text=AsyncMock(return_value=None)),
        answer=AsyncMock(return_value=None),
    )

    state = DummyState(
        {
            "hh_month": "2025-01",
            "hh_questions": [
                {"code": "q1", "text": "Q1", "amount": 10},
                {"code": "q2", "text": "Q2", "amount": 5},
            ],
            "current_step_index": 0,
            "hh_index": 0,
            "hh_answers": {},
            "hh_ui_message_id": 10,
            "processed_steps": [],
        }
    )

    await handle_household_answer(callback, state)

    assert db_stub.apply_household_payment_answer.call_count == 1
    kwargs = state.update_data.await_args.kwargs
    assert kwargs["hh_answers"]["q1"] == "no"
    assert "q1" in kwargs["processed_steps"]
    assert kwargs["current_step_index"] == 1
    callback.bot.edit_message_text.assert_awaited_once()


@pytest.mark.asyncio
async def test_handle_household_answer_no_double_tap_is_idempotent(
    monkeypatch,
) -> None:
    """Duplicate no answers should not reapply DB or UI updates."""

    db_stub = SimpleNamespace(apply_household_payment_answer=MagicMock(return_value=False))
    monkeypatch.setattr("Bot.handlers.household_payments.get_db", lambda: db_stub)

    message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    callback = SimpleNamespace(
        data="hh_pay:no:q1",
        from_user=SimpleNamespace(id=1),
        message=message,
        bot=SimpleNamespace(edit_message_text=AsyncMock(return_value=None)),
        answer=AsyncMock(return_value=None),
    )

    state = DummyState(
        {
            "hh_month": "2025-01",
            "hh_questions": [
                {"code": "q1", "text": "Q1", "amount": 10},
                {"code": "q2", "text": "Q2", "amount": 5},
            ],
            "current_step_index": 0,
            "hh_index": 0,
            "hh_answers": {},
            "hh_ui_message_id": 10,
            "processed_steps": [],
        }
    )

    await handle_household_answer(callback, state)
    await handle_household_answer(callback, state)

    assert db_stub.apply_household_payment_answer.call_count == 1
    callback.bot.edit_message_text.assert_awaited_once()


===== tests/unit/test_household_payments.py =====

"""Tests for household payments workflow."""
from datetime import datetime

import pytest

from Bot.config import settings
from Bot.database.crud import FinanceDatabase, TABLES
from Bot.handlers.household_payments import reset_household_cycle_if_needed
from Bot.utils.datetime_utils import current_month_str


@pytest.mark.asyncio
async def test_reset_cycle_creates_statuses_after_threshold() -> None:
    """Statuses should appear after threshold date only once."""

    db = FinanceDatabase()
    user_id = 99991
    month = "2025-01"
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payments} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payment_items} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    before_threshold = datetime(2025, 1, 5, 10, 0, tzinfo=settings.TIMEZONE)
    await reset_household_cycle_if_needed(user_id, db, now=before_threshold)
    assert not await db.household_status_exists(user_id, month)

    after_threshold = datetime(2025, 1, 6, 12, 0, tzinfo=settings.TIMEZONE)
    await reset_household_cycle_if_needed(user_id, db, now=after_threshold)
    assert await db.has_unpaid_household_questions(user_id, month)

    await reset_household_cycle_if_needed(user_id, db, now=after_threshold)
    cursor = db.connection.execute(
        f"SELECT COUNT(*) FROM {TABLES.household_payments} WHERE user_id = ? AND month = ?",
        (user_id, month),
    )
    assert cursor.fetchone()[0] == len(items)


@pytest.mark.asyncio
async def test_mark_and_check_unpaid_questions() -> None:
    """Marking paid questions should update unpaid check."""

    db = FinanceDatabase()
    user_id = 99992
    month = current_month_str(datetime(2025, 2, 6, 12, 0, tzinfo=settings.TIMEZONE))
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payments} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payment_items} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    await db.init_household_questions_for_month(user_id, month)
    assert await db.has_unpaid_household_questions(user_id, month)

    for item in items:
        await db.mark_household_question_paid(user_id, month, str(item.get("code")))
    assert not await db.has_unpaid_household_questions(user_id, month)


@pytest.mark.asyncio
async def test_question_flow_and_savings_update() -> None:
    """Yes/No answers adjust savings and skip paid questions."""

    db = FinanceDatabase()
    user_id = 99993
    month = current_month_str(datetime(2025, 3, 6, 12, 0, tzinfo=settings.TIMEZONE))
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payments} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.savings} WHERE user_id = ? AND category = 'быт'",
        (user_id,),
    )
    db.connection.execute(
        f"DELETE FROM {TABLES.household_payment_items} WHERE user_id = ?",
        (user_id,),
    )
    db.connection.commit()
    db.ensure_household_items_seeded(user_id)
    items = db.list_active_household_items(user_id)

    db.update_saving(user_id, "быт", 5000)
    await db.init_household_questions_for_month(user_id, month)

    unpaid = await db.get_unpaid_household_questions(user_id, month)
    assert unpaid
    first_code = str(unpaid[0])
    first_item = next(item for item in items if str(item.get("code")) == first_code)
    amount = float(first_item.get("amount") or 0)

    changed = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="yes",
        debit_category="быт",
    )
    assert changed is True

    savings_map = db.get_user_savings_map(user_id)
    assert savings_map.get("быт") == 5000 - amount

    changed_again = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="yes",
        debit_category="быт",
    )
    assert changed_again is False

    changed_back = db.apply_household_payment_answer(
        user_id=user_id,
        month=month,
        question_code=first_code,
        amount=amount,
        answer="no",
        debit_category="быт",
    )
    assert changed_back is True
    savings_map = db.get_user_savings_map(user_id)
    assert savings_map.get("быт") == 5000


===== tests/unit/test_household_renderers.py =====

"""Tests for household renderers."""

from Bot.renderers.household import format_household_items, render_household_questions_text


def test_render_questions_text_marks_answers() -> None:
    questions = [
        {"code": "q1", "text": "Оплатил интернет?", "amount": 100},
        {"code": "q2", "text": "Оплатил свет?", "amount": 200},
    ]
    answers = {"q1": "yes", "q2": "no"}
    text = render_household_questions_text("2025-02", questions, answers, current_index=1)
    assert "✅" in text
    assert "❌" in text
    assert "2025-02" in text


def test_format_household_items() -> None:
    items = [
        {"code": "q1", "text": "Интернет?", "amount": 100},
        {"code": "q2", "text": "Свет?", "amount": 200},
    ]
    text = format_household_items(items, unpaid_set={"q2"})
    assert "✅" in text
    assert "❌" in text
    assert "Интернет" in text


===== tests/unit/test_household_services.py =====

"""Tests for household services."""

from Bot.services.household import (
    build_household_questions,
    get_current_question,
    get_next_index,
    get_previous_index,
    should_ignore_answer,
    update_flow_state,
)


def test_flow_state_and_navigation() -> None:
    questions = build_household_questions(
        [
            {"code": "q1", "text": "Первый?", "amount": 100},
            {"code": "q2", "text": "Второй?", "amount": 200},
        ]
    )
    flow = update_flow_state(
        month="2025-01",
        questions=questions,
        current_step_index=0,
        answers={},
        processed_steps=[],
    )
    assert flow.current_question_code == "q1"
    assert get_current_question(questions, 1)["code"] == "q2"
    assert get_next_index(0, questions) == 1
    assert get_next_index(1, questions) == 2
    assert get_previous_index(0) == 0
    assert get_previous_index(1) == 0


def test_idempotency_check() -> None:
    answers = {"q1": "yes"}
    processed_steps = {"q1"}
    assert should_ignore_answer(answers, processed_steps, "q1", "yes") is True
    assert should_ignore_answer(answers, processed_steps, "q1", "no") is False
    assert should_ignore_answer(answers, processed_steps, "q2", "yes") is False


===== tests/unit/test_imports.py =====

"""Basic import tests."""


def test_import_main() -> None:
    """Ensure main module is importable."""

    import Bot.main  # noqa: F401


def test_import_handlers() -> None:
    """Ensure handlers modules are importable."""

    import Bot.handlers.start  # noqa: F401
    import Bot.handlers.finances  # noqa: F401
    import Bot.handlers.household_payments  # noqa: F401
    import Bot.handlers.wishlist  # noqa: F401
    import Bot.handlers.callbacks  # noqa: F401
    import Bot.handlers.common  # noqa: F401


def test_register_routers_smoke() -> None:
    """Ensure register_routers includes key routers."""

    from aiogram import Dispatcher

    from Bot.handlers import household_payments, settings, start, wishlist
    from Bot.main import register_routers

    dp = Dispatcher()
    register_routers(dp)
    routers = list(getattr(dp, "sub_routers", []))

    assert start.router in routers
    assert household_payments.router in routers
    assert settings.router in routers
    assert wishlist.router in routers


===== tests/unit/test_income_categories.py =====

"""Tests for income category seeding and flow guards."""
import asyncio
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock

import pytest

from Bot.database import crud


def test_income_categories_not_seeded(tmp_path, monkeypatch) -> None:
    """Income categories should start empty for a new user."""

    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None

    db = crud.FinanceDatabase()
    try:
        assert db.list_active_income_categories(12345) == []
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_start_income_flow_with_empty_categories(monkeypatch) -> None:
    """Handler should stop flow when no income categories exist."""

    pytest.importorskip("aiogram")

    from Bot.handlers import finances  # noqa: WPS433

    db_stub = SimpleNamespace(list_active_income_categories=MagicMock(return_value=[]))
    monkeypatch.setattr("Bot.handlers.finances.get_db", lambda: db_stub)
    monkeypatch.setattr(
        "Bot.handlers.finances.build_main_menu_for_user",
        AsyncMock(return_value="menu"),
    )
    monkeypatch.setattr("Bot.handlers.finances.ui_register_message", AsyncMock())
    monkeypatch.setattr("Bot.handlers.finances.safe_delete_message", AsyncMock())

    sent_message = SimpleNamespace(message_id=10, chat=SimpleNamespace(id=20))
    message = SimpleNamespace(
        from_user=SimpleNamespace(id=1),
        chat=SimpleNamespace(id=20),
        message_id=5,
        bot=SimpleNamespace(),
        answer=AsyncMock(return_value=sent_message),
    )
    state = SimpleNamespace(clear=AsyncMock(), set_state=AsyncMock(), update_data=AsyncMock())

    async def _run() -> None:
        await finances.start_income_flow(message, state)

    asyncio.run(_run())

    assert db_stub.list_active_income_categories.call_count == 1
    state.set_state.assert_not_awaited()
    message.answer.assert_awaited_once()
    assert "Категории дохода не настроены" in message.answer.await_args.args[0]


===== tests/unit/test_telegram_safe.py =====

"""Tests for telegram_safe utilities."""
from unittest.mock import AsyncMock

import pytest

pytest.importorskip("aiogram")

from aiogram.exceptions import TelegramNetworkError  # noqa: E402

from Bot.utils.telegram_safe import safe_edit_message_text  # noqa: E402


@pytest.mark.asyncio
async def test_safe_edit_message_text_retries_network_error() -> None:
    """Network errors should trigger retries for edit operations."""

    bot = AsyncMock()
    bot.edit_message_text = AsyncMock(
        side_effect=[TelegramNetworkError("fail"), None]
    )

    result = await safe_edit_message_text(
        bot,
        chat_id=123,
        message_id=456,
        text="hello",
    )

    assert result is True
    assert bot.edit_message_text.call_count == 2


===== tests/unit/test_telegram_safe_delete.py =====

"""Tests for safe_delete_message."""

from unittest.mock import AsyncMock
import sys
import types
from pathlib import Path

import asyncio
import pytest

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

if "aiogram" not in sys.modules:
    aiogram = types.ModuleType("aiogram")
    exceptions = types.ModuleType("aiogram.exceptions")
    types_mod = types.ModuleType("aiogram.types")
    filters = types.ModuleType("aiogram.filters")
    fsm = types.ModuleType("aiogram.fsm")
    fsm_context = types.ModuleType("aiogram.fsm.context")

    class TelegramBadRequest(Exception):
        pass

    class TelegramNetworkError(Exception):
        pass

    exceptions.TelegramBadRequest = TelegramBadRequest
    exceptions.TelegramNetworkError = TelegramNetworkError

    class ReplyKeyboardMarkup:
        pass

    class ReplyKeyboardRemove:
        pass

    class Message:
        pass

    class InlineKeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    class InlineKeyboardMarkup:
        def __init__(self, *args, **kwargs):
            return None

    class KeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    class DummyRouter:
        def message(self, *args, **kwargs):
            def decorator(func):
                return func

            return decorator

    class Bot:
        pass

    class DummyF:
        class _Field:
            def __eq__(self, other):
                return ("eq", other)

        text = _Field()

    class FSMContext:
        pass

    class Command:
        def __init__(self, *args, **kwargs):
            return None

    types_mod.ReplyKeyboardMarkup = ReplyKeyboardMarkup
    types_mod.ReplyKeyboardRemove = ReplyKeyboardRemove
    types_mod.Message = Message
    types_mod.InlineKeyboardButton = InlineKeyboardButton
    types_mod.InlineKeyboardMarkup = InlineKeyboardMarkup
    types_mod.KeyboardButton = KeyboardButton
    aiogram.exceptions = exceptions
    aiogram.types = types_mod
    aiogram.Router = DummyRouter
    aiogram.F = DummyF()
    aiogram.Bot = Bot
    fsm_context.FSMContext = FSMContext
    fsm.context = fsm_context
    aiogram.fsm = fsm
    aiogram.filters = filters
    filters.Command = Command
    sys.modules["aiogram"] = aiogram
    sys.modules["aiogram.exceptions"] = exceptions
    sys.modules["aiogram.types"] = types_mod
    sys.modules["aiogram.filters"] = filters
    sys.modules["aiogram.fsm"] = fsm
    sys.modules["aiogram.fsm.context"] = fsm_context

if "aiohttp" not in sys.modules:
    aiohttp = types.ModuleType("aiohttp")

    class ClientConnectionError(Exception):
        pass

    class ClientOSError(Exception):
        pass

    aiohttp.ClientConnectionError = ClientConnectionError
    aiohttp.ClientOSError = ClientOSError
    sys.modules["aiohttp"] = aiohttp

from aiogram.exceptions import TelegramBadRequest  # noqa: E402

from Bot.utils.telegram_safe import safe_delete_message  # noqa: E402


def test_safe_delete_message_not_found() -> None:
    async def run() -> None:
        bot = AsyncMock()
        bot.delete_message = AsyncMock(
            side_effect=TelegramBadRequest("message to delete not found")
        )

        result = await safe_delete_message(bot, chat_id=1, message_id=2)

        assert result is False
        assert bot.delete_message.call_count == 1

    asyncio.run(run())


===== tests/unit/test_text_sanitizer.py =====

"""Tests for income text sanitizer."""

import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from Bot.utils.text_sanitizer import sanitize_income_title  # noqa: E402


def test_sanitize_income_title_removes_bank_suffixes() -> None:
    text = "бытовые расходы на тиньк (озон)"
    assert sanitize_income_title(text) == "бытовые расходы"


def test_sanitize_income_title_trims_separators() -> None:
    text = "Инвестиции — на Альфу"
    assert sanitize_income_title(text) == "Инвестиции"


def test_sanitize_income_title_removes_tinkoff_suffix() -> None:
    text = "убил боль — на тиньк"
    assert sanitize_income_title(text) == "убил боль"


def test_sanitize_income_title_removes_ozon_suffix() -> None:
    text = "что-то (озон)"
    assert sanitize_income_title(text) == "что-то"


===== tests/unit/test_ui_cleanup.py =====

"""Tests for UI cleanup utilities."""
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock
import asyncio
import sys
import types
from pathlib import Path

import pytest

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

if "aiogram" not in sys.modules:
    aiogram = types.ModuleType("aiogram")

    class DummyRouter:
        def message(self, *args, **kwargs):
            def decorator(func):
                return func

            return decorator

    class DummyF:
        class _Field:
            def __eq__(self, other):
                return ("eq", other)

        text = _Field()

    class Bot:
        pass

    aiogram.F = DummyF()
    aiogram.Router = DummyRouter
    aiogram.Bot = Bot

    exceptions = types.ModuleType("aiogram.exceptions")

    class TelegramBadRequest(Exception):
        pass

    exceptions.TelegramBadRequest = TelegramBadRequest
    aiogram.exceptions = exceptions

    filters = types.ModuleType("aiogram.filters")

    class Command:
        def __init__(self, *args, **kwargs):
            return None

    filters.Command = Command
    aiogram.filters = filters

    fsm = types.ModuleType("aiogram.fsm")
    fsm_context = types.ModuleType("aiogram.fsm.context")

    class FSMContext:
        pass

    fsm_context.FSMContext = FSMContext
    fsm.context = fsm_context
    aiogram.fsm = fsm

    types_mod = types.ModuleType("aiogram.types")

    class Message:
        pass

    class ReplyKeyboardMarkup:
        pass

    class ReplyKeyboardRemove:
        pass

    class InlineKeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    class InlineKeyboardMarkup:
        def __init__(self, *args, **kwargs):
            return None

    class KeyboardButton:
        def __init__(self, *args, **kwargs):
            return None

    types_mod.Message = Message
    types_mod.ReplyKeyboardMarkup = ReplyKeyboardMarkup
    types_mod.ReplyKeyboardRemove = ReplyKeyboardRemove
    types_mod.InlineKeyboardButton = InlineKeyboardButton
    types_mod.InlineKeyboardMarkup = InlineKeyboardMarkup
    types_mod.KeyboardButton = KeyboardButton
    aiogram.types = types_mod

    sys.modules["aiogram"] = aiogram
    sys.modules["aiogram.exceptions"] = exceptions
    sys.modules["aiogram.filters"] = filters
    sys.modules["aiogram.fsm"] = fsm
    sys.modules["aiogram.fsm.context"] = fsm_context
    sys.modules["aiogram.types"] = types_mod

from Bot.handlers.start import back_to_main
from Bot.utils.ui_cleanup import (
    ui_cleanup_to_context,
    ui_register_protected_message,
    ui_set_welcome_message,
    ui_track_message,
)


class DummyState:
    """Minimal FSMContext stand-in for unit tests."""

    def __init__(self, initial=None) -> None:
        self.data = dict(initial or {})

    async def get_data(self) -> dict:
        return dict(self.data)

    async def update_data(self, **kwargs) -> None:
        self.data.update(kwargs)


class DummyBot:
    """Minimal bot mock with async delete_message."""

    def __init__(self) -> None:
        self.delete_message = AsyncMock()
        self.edit_message_text = AsyncMock()
        self.send_message = AsyncMock()


def test_ui_track_deduplicates() -> None:
    """Tracking avoids duplicate message ids."""

    async def run_test() -> None:
        state = DummyState()
        await ui_track_message(state, 1, 10)
        await ui_track_message(state, 1, 10)
        data = await state.get_data()
        assert data["ui_tracked_message_ids"] == [10]

    asyncio.run(run_test())


def test_ui_cleanup_keeps_welcome() -> None:
    """Cleanup removes tracked messages while keeping welcome."""

    async def run_test() -> None:
        state = DummyState(
            {
                "ui_welcome_message_id": 111,
                "ui_tracked_message_ids": [111, 222, 333],
            }
        )

        bot = DummyBot()
        await ui_cleanup_to_context(bot, state, 1, "MAIN_MENU")

        deleted_ids = {
            call.kwargs["message_id"] for call in bot.delete_message.call_args_list
        }
        assert deleted_ids == {222, 333}
        data = await state.get_data()
        assert data["ui_tracked_message_ids"] == []

    asyncio.run(run_test())


def test_ui_register_protected_not_tracked() -> None:
    """Protected messages are stored separately from tracked list."""

    async def run_test() -> None:
        state = DummyState()
        await ui_register_protected_message(state, 1, 55)
        data = await state.get_data()
        assert data.get("ui_protected_message_ids") == [55]
        assert data.get("ui_tracked_message_ids") in (None, [])

    asyncio.run(run_test())


def test_back_to_main_deletes_and_cleans(monkeypatch) -> None:
    """back_to_main deletes user message, cleans UI, and renders menu."""

    async def run_test() -> None:
        state = DummyState({"ui_welcome_message_id": 55})
        cleanup_mock = AsyncMock()
        render_mock = AsyncMock()
        build_menu_mock = AsyncMock(return_value=MagicMock())
        safe_delete_mock = AsyncMock(return_value=True)

        monkeypatch.setattr("Bot.handlers.start.ui_cleanup_to_context", cleanup_mock)
        monkeypatch.setattr("Bot.handlers.start.ui_render_screen", render_mock)
        monkeypatch.setattr(
            "Bot.handlers.start.build_main_menu_for_user", build_menu_mock
        )
        monkeypatch.setattr("Bot.handlers.start.ui_safe_delete_message", safe_delete_mock)

        message = SimpleNamespace(
            chat=SimpleNamespace(id=1),
            from_user=SimpleNamespace(id=2),
            message_id=10,
            bot=SimpleNamespace(),
        )

        await back_to_main(message, state)

        safe_delete_mock.assert_awaited_once()
        cleanup_mock.assert_awaited_once()
        _, kwargs = cleanup_mock.await_args
        assert kwargs.get("keep_ids") is None
        build_menu_mock.assert_awaited_once_with(2)
        render_mock.assert_awaited_once()

    asyncio.run(run_test())


def test_welcome_reused_on_start() -> None:
    """Welcome message is reused when id exists."""

    async def run_test() -> None:
        state = DummyState({"ui_welcome_message_id": 77})
        bot = DummyBot()
        bot.send_message.return_value = SimpleNamespace(message_id=88)

        welcome_id = await ui_set_welcome_message(bot, state, 1, "Hello")

        assert welcome_id == 77
        bot.edit_message_text.assert_awaited_once()
        bot.send_message.assert_not_called()

    asyncio.run(run_test())


===== tests/unit/test_utils.py =====

"""Utility tests."""
from Bot.utils.logging import init_logging


def test_init_logging_returns_logger() -> None:
    """init_logging should return a logger instance."""

    logger = init_logging()
    assert logger.name == "Bot.utils.logging"


===== tests/unit/test_wishlist_debit_category.py =====

"""Tests for wishlist debit category settings."""
from Bot.database import crud


def _fresh_db(tmp_path, monkeypatch) -> crud.FinanceDatabase:
    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None
    return crud.FinanceDatabase()


def test_set_and_get_wishlist_debit_category(tmp_path, monkeypatch) -> None:
    """Wishlist debit category should persist in user settings."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        db.set_wishlist_debit_category(1, "alpha")
        assert db.get_wishlist_debit_category(1) == "alpha"
        db.set_wishlist_debit_category(1, None)
        assert db.get_wishlist_debit_category(1) is None
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


===== tests/unit/test_wishlist_purchase.py =====

"""Tests for wishlist purchase flow."""
from Bot.database import crud


def _fresh_db(tmp_path, monkeypatch) -> crud.FinanceDatabase:
    db_path = tmp_path / "finance.db"
    monkeypatch.setattr(crud, "DB_PATH", db_path)
    crud.FinanceDatabase._instance = None
    return crud.FinanceDatabase()


def test_purchase_wishlist_without_debit(tmp_path, monkeypatch) -> None:
    """Purchase without debit should not change savings."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        wish_id = db.add_wish(1, "Laptop", 100.0, None, "Work")
        result = db.purchase_wish(1, wish_id, None)
        assert result.get("status") == "no_debit"
        wish = db.get_wish(wish_id)
        assert wish is not None
        assert wish.get("is_purchased") == 1
        assert wish.get("debited_at") is None
        savings_map = db.get_user_savings_map(1)
        assert "alpha" not in savings_map
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


def test_purchase_wishlist_debit_idempotent(tmp_path, monkeypatch) -> None:
    """Purchase should debit once and be idempotent."""

    db = _fresh_db(tmp_path, monkeypatch)
    try:
        wish_id = db.add_wish(2, "Phone", 50.0, None, "Fun")
        db.update_saving(2, "alpha", 100.0)
        result = db.purchase_wish(2, wish_id, "alpha")
        assert result.get("status") == "debited"
        savings_map = db.get_user_savings_map(2)
        assert savings_map.get("alpha") == 50.0
        result_again = db.purchase_wish(2, wish_id, "alpha")
        assert result_again.get("status") == "already"
        savings_map_again = db.get_user_savings_map(2)
        assert savings_map_again.get("alpha") == 50.0
        wish = db.get_wish(wish_id)
        assert wish is not None
        assert wish.get("debited_at") is not None
    finally:
        db.close()
        crud.FinanceDatabase._instance = None


===== utils/__init__.py =====

from Bot.utils import *  # noqa: F401,F403


===== utils/logging.py =====

from Bot.utils.logging import *  # noqa: F401,F403
